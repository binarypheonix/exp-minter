{"ast":null,"code":"import _slicedToArray from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { useEffect, useRef, useState, useCallback } from \"./react-deps.js\";\nexport default (function () {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$base = _ref.base,\n      base = _ref$base === void 0 ? \"\" : _ref$base;\n\n  var _useState = useState(currentPathname(base)),\n      _useState2 = _slicedToArray(_useState, 2),\n      path = _useState2[0],\n      update = _useState2[1];\n\n  var prevPath = useRef(path);\n  useEffect(function () {\n    patchHistoryEvents(); // this function checks if the location has been changed since the\n    // last render and updates the state only when needed.\n    // unfortunately, we can't rely on `path` value here, since it can be stale,\n    // that's why we store the last pathname in a ref.\n\n    var checkForUpdates = function checkForUpdates() {\n      var pathname = currentPathname(base);\n      prevPath.current !== pathname && update(prevPath.current = pathname);\n    };\n\n    var events = [\"popstate\", \"pushState\", \"replaceState\"];\n    events.map(function (e) {\n      return addEventListener(e, checkForUpdates);\n    }); // it's possible that an update has occurred between render and the effect handler,\n    // so we run additional check on mount to catch these updates. Based on:\n    // https://gist.github.com/bvaughn/e25397f70e8c65b0ae0d7c90b731b189\n\n    checkForUpdates();\n    return function () {\n      return events.map(function (e) {\n        return removeEventListener(e, checkForUpdates);\n      });\n    };\n  }, [base]); // the 2nd argument of the `useLocation` return value is a function\n  // that allows to perform a navigation.\n  //\n  // the function reference should stay the same between re-renders, so that\n  // it can be passed down as an element prop without any performance concerns.\n\n  var navigate = useCallback(function (to) {\n    var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref2$replace = _ref2.replace,\n        replace = _ref2$replace === void 0 ? false : _ref2$replace;\n\n    return history[replace ? \"replaceState\" : \"pushState\"](0, 0, base + to);\n  }, [base]);\n  return [path, navigate];\n}); // While History API does have `popstate` event, the only\n// proper way to listen to changes via `push/replaceState`\n// is to monkey-patch these methods.\n//\n// See https://stackoverflow.com/a/4585031\n\nvar patched = 0;\n\nvar patchHistoryEvents = function patchHistoryEvents() {\n  if (patched) return;\n  [\"pushState\", \"replaceState\"].map(function (type) {\n    var original = history[type];\n\n    history[type] = function () {\n      var result = original.apply(this, arguments);\n      var event = new Event(type);\n      event.arguments = arguments;\n      dispatchEvent(event);\n      return result;\n    };\n  });\n  return patched = 1;\n};\n\nvar currentPathname = function currentPathname(base) {\n  var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : location.pathname;\n  return !path.indexOf(base) ? path.slice(base.length) || \"/\" : path;\n};","map":{"version":3,"sources":["/Users/frankenstein/projects/minter/node_modules/wouter/use-location.js"],"names":["useEffect","useRef","useState","useCallback","base","currentPathname","path","update","prevPath","patchHistoryEvents","checkForUpdates","pathname","current","events","map","e","addEventListener","removeEventListener","navigate","to","replace","history","patched","type","original","result","apply","arguments","event","Event","dispatchEvent","location","indexOf","slice","length"],"mappings":"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","sourcesContent":["import { useEffect, useRef, useState, useCallback } from \"./react-deps.js\";\n\nexport default ({ base = \"\" } = {}) => {\n  const [path, update] = useState(currentPathname(base));\n  const prevPath = useRef(path);\n\n  useEffect(() => {\n    patchHistoryEvents();\n\n    // this function checks if the location has been changed since the\n    // last render and updates the state only when needed.\n    // unfortunately, we can't rely on `path` value here, since it can be stale,\n    // that's why we store the last pathname in a ref.\n    const checkForUpdates = () => {\n      const pathname = currentPathname(base);\n      prevPath.current !== pathname && update((prevPath.current = pathname));\n    };\n\n    const events = [\"popstate\", \"pushState\", \"replaceState\"];\n    events.map((e) => addEventListener(e, checkForUpdates));\n\n    // it's possible that an update has occurred between render and the effect handler,\n    // so we run additional check on mount to catch these updates. Based on:\n    // https://gist.github.com/bvaughn/e25397f70e8c65b0ae0d7c90b731b189\n    checkForUpdates();\n\n    return () => events.map((e) => removeEventListener(e, checkForUpdates));\n  }, [base]);\n\n  // the 2nd argument of the `useLocation` return value is a function\n  // that allows to perform a navigation.\n  //\n  // the function reference should stay the same between re-renders, so that\n  // it can be passed down as an element prop without any performance concerns.\n  const navigate = useCallback(\n    (to, { replace = false } = {}) =>\n      history[replace ? \"replaceState\" : \"pushState\"](0, 0, base + to),\n    [base]\n  );\n\n  return [path, navigate];\n};\n\n// While History API does have `popstate` event, the only\n// proper way to listen to changes via `push/replaceState`\n// is to monkey-patch these methods.\n//\n// See https://stackoverflow.com/a/4585031\n\nlet patched = 0;\n\nconst patchHistoryEvents = () => {\n  if (patched) return;\n\n  [\"pushState\", \"replaceState\"].map((type) => {\n    const original = history[type];\n\n    history[type] = function() {\n      const result = original.apply(this, arguments);\n      const event = new Event(type);\n      event.arguments = arguments;\n\n      dispatchEvent(event);\n      return result;\n    };\n  });\n\n  return (patched = 1);\n};\n\nconst currentPathname = (base, path = location.pathname) =>\n  !path.indexOf(base) ? path.slice(base.length) || \"/\" : path;\n"]},"metadata":{},"sourceType":"module"}