{"ast":null,"code":"import { createSlice } from '@reduxjs/toolkit';\nimport { createAssetContractAction, mintTokenAction, transferTokenAction, listTokenAction, cancelTokenSaleAction, buyTokenAction, mintCsvTokensAction } from '../async/actions';\nimport { getContractNftsQuery, getNftAssetContractQuery, getWalletAssetContractsQuery } from '../async/queries';\nimport { ErrorKind } from '../async/errors';\nconst defaultStatus = {\n  status: 'ready',\n  error: null\n};\nconst initialState = {\n  createAssetContract: defaultStatus,\n  mintToken: defaultStatus,\n  mintCsvTokens: defaultStatus,\n  transferToken: defaultStatus,\n  listToken: defaultStatus,\n  cancelTokenSale: defaultStatus,\n  buyToken: defaultStatus,\n  getContractNfts: defaultStatus,\n  getNftAssetContract: defaultStatus,\n  getWalletAssetContracts: defaultStatus\n};\n\nfunction methodMap(method, action) {\n  return {\n    method,\n    action\n  };\n}\n\nconst slice = createSlice({\n  name: 'status',\n  initialState,\n  reducers: {\n    setStatus(state, {\n      payload\n    }) {\n      state[payload.method].status = payload.status;\n    },\n\n    clearError(state, {\n      payload\n    }) {\n      state[payload.method].error = null;\n    }\n\n  },\n  extraReducers: ({\n    addCase\n  }) => {\n    [methodMap('createAssetContract', createAssetContractAction), methodMap('mintToken', mintTokenAction), methodMap('mintCsvTokens', mintCsvTokensAction), methodMap('transferToken', transferTokenAction), methodMap('listToken', listTokenAction), methodMap('cancelTokenSale', cancelTokenSaleAction), methodMap('buyToken', buyTokenAction), methodMap('getContractNfts', getContractNftsQuery), methodMap('getNftAssetContract', getNftAssetContractQuery), methodMap('getWalletAssetContracts', getWalletAssetContractsQuery)].forEach(({\n      method,\n      action\n    }) => {\n      addCase(action.pending, state => {\n        state[method].status = 'in_transit';\n      });\n      addCase(action.fulfilled, state => {\n        state[method].status = 'complete';\n      });\n      addCase(action.rejected, (state, action) => {\n        const rejectValue = action.payload ? action.payload : {\n          kind: ErrorKind.UnknownError,\n          message: 'Unknown error'\n        };\n        state[method].error = {\n          rejectValue,\n          serialized: action.error\n        };\n      });\n    });\n  }\n});\nexport const {\n  setStatus,\n  clearError\n} = slice.actions;\nexport default slice;","map":{"version":3,"sources":["/Users/frankenstein/projects/minter/src/reducer/slices/status.ts"],"names":["createSlice","createAssetContractAction","mintTokenAction","transferTokenAction","listTokenAction","cancelTokenSaleAction","buyTokenAction","mintCsvTokensAction","getContractNftsQuery","getNftAssetContractQuery","getWalletAssetContractsQuery","ErrorKind","defaultStatus","status","error","initialState","createAssetContract","mintToken","mintCsvTokens","transferToken","listToken","cancelTokenSale","buyToken","getContractNfts","getNftAssetContract","getWalletAssetContracts","methodMap","method","action","slice","name","reducers","setStatus","state","payload","clearError","extraReducers","addCase","forEach","pending","fulfilled","rejected","rejectValue","kind","UnknownError","message","serialized","actions"],"mappings":"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","sourcesContent":["import { createSlice, PayloadAction, SerializedError } from '@reduxjs/toolkit';\nimport {\n  createAssetContractAction,\n  mintTokenAction,\n  transferTokenAction,\n  listTokenAction,\n  cancelTokenSaleAction,\n  buyTokenAction,\n  mintCsvTokensAction\n} from '../async/actions';\nimport {\n  getContractNftsQuery,\n  getNftAssetContractQuery,\n  getWalletAssetContractsQuery\n} from '../async/queries';\nimport { ErrorKind, RejectValue } from '../async/errors';\n\nexport type StatusKey = 'ready' | 'in_transit' | 'complete';\n\nexport interface Status {\n  status: StatusKey;\n  error: {\n    rejectValue: RejectValue;\n    serialized: SerializedError;\n  } | null;\n}\n\nexport interface StatusState {\n  createAssetContract: Status;\n  mintToken: Status;\n  mintCsvTokens: Status;\n  transferToken: Status;\n  listToken: Status;\n  cancelTokenSale: Status;\n  buyToken: Status;\n  getContractNfts: Status;\n  getNftAssetContract: Status;\n  getWalletAssetContracts: Status;\n}\n\nexport type Method = keyof StatusState;\n\nconst defaultStatus: Status = { status: 'ready', error: null };\n\nconst initialState: StatusState = {\n  createAssetContract: defaultStatus,\n  mintToken: defaultStatus,\n  mintCsvTokens: defaultStatus,\n  transferToken: defaultStatus,\n  listToken: defaultStatus,\n  cancelTokenSale: defaultStatus,\n  buyToken: defaultStatus,\n  getContractNfts: defaultStatus,\n  getNftAssetContract: defaultStatus,\n  getWalletAssetContracts: defaultStatus\n};\n\ntype SetStatusAction = PayloadAction<{ method: Method; status: StatusKey }>;\ntype ClearErrorAction = PayloadAction<{ method: Method }>;\n\nfunction methodMap<A>(method: keyof StatusState, action: A) {\n  return { method, action };\n}\n\nconst slice = createSlice({\n  name: 'status',\n  initialState,\n  reducers: {\n    setStatus(state, { payload }: SetStatusAction) {\n      state[payload.method].status = payload.status;\n    },\n    clearError(state, { payload }: ClearErrorAction) {\n      state[payload.method].error = null;\n    }\n  },\n  extraReducers: ({ addCase }) => {\n    [\n      methodMap('createAssetContract', createAssetContractAction),\n      methodMap('mintToken', mintTokenAction),\n      methodMap('mintCsvTokens', mintCsvTokensAction),\n      methodMap('transferToken', transferTokenAction),\n      methodMap('listToken', listTokenAction),\n      methodMap('cancelTokenSale', cancelTokenSaleAction),\n      methodMap('buyToken', buyTokenAction),\n      methodMap('getContractNfts', getContractNftsQuery),\n      methodMap('getNftAssetContract', getNftAssetContractQuery),\n      methodMap('getWalletAssetContracts', getWalletAssetContractsQuery)\n    ].forEach(({ method, action }) => {\n      addCase(action.pending, state => {\n        state[method].status = 'in_transit';\n      });\n      addCase(action.fulfilled, state => {\n        state[method].status = 'complete';\n      });\n      addCase(action.rejected, (state, action) => {\n        const rejectValue = action.payload\n          ? action.payload\n          : {\n              kind: ErrorKind.UnknownError,\n              message: 'Unknown error'\n            };\n        state[method].error = {\n          rejectValue,\n          serialized: action.error\n        };\n      });\n    });\n  }\n});\n\nexport const { setStatus, clearError } = slice.actions;\n\nexport default slice;\n"]},"metadata":{},"sourceType":"module"}