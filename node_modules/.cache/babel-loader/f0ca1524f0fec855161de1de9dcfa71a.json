{"ast":null,"code":"import _classCallCheck from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nexport var ExposedPromiseStatus;\n\n(function (ExposedPromiseStatus) {\n  ExposedPromiseStatus[\"PENDING\"] = \"pending\";\n  ExposedPromiseStatus[\"RESOLVED\"] = \"resolved\";\n  ExposedPromiseStatus[\"REJECTED\"] = \"rejected\";\n})(ExposedPromiseStatus || (ExposedPromiseStatus = {}));\n\nvar notInitialized = function notInitialized() {\n  throw new Error('ExposedPromise not initialized yet.');\n};\n/**\n * Exposed promise allow you to create a promise and then resolve it later, from the outside\n */\n\n\nexport var ExposedPromise = /*#__PURE__*/function () {\n  function ExposedPromise() {\n    var _this = this;\n\n    _classCallCheck(this, ExposedPromise);\n\n    this._resolve = notInitialized;\n    this._reject = notInitialized;\n    this._status = ExposedPromiseStatus.PENDING;\n    this._promise = new Promise(function (innerResolve, innerReject) {\n      _this._resolve = function (value) {\n        if (_this.isSettled()) {\n          return;\n        }\n\n        _this._promiseResult = value;\n        innerResolve(value);\n        _this._status = ExposedPromiseStatus.RESOLVED;\n        return;\n      };\n\n      _this._reject = function (reason) {\n        if (_this.isSettled()) {\n          return;\n        }\n\n        _this._promiseError = reason;\n        innerReject(reason);\n        _this._status = ExposedPromiseStatus.REJECTED;\n        return;\n      };\n    });\n  }\n\n  _createClass(ExposedPromise, [{\n    key: \"promise\",\n    get: function get() {\n      return this._promise;\n    }\n  }, {\n    key: \"resolve\",\n    get: function get() {\n      return this._resolve;\n    }\n  }, {\n    key: \"reject\",\n    get: function get() {\n      return this._reject;\n    }\n  }, {\n    key: \"status\",\n    get: function get() {\n      return this._status;\n    }\n  }, {\n    key: \"promiseResult\",\n    get: function get() {\n      return this._promiseResult;\n    }\n  }, {\n    key: \"promiseError\",\n    get: function get() {\n      return this._promiseError;\n    }\n  }, {\n    key: \"isPending\",\n    value: function isPending() {\n      return this.status === ExposedPromiseStatus.PENDING;\n    }\n  }, {\n    key: \"isResolved\",\n    value: function isResolved() {\n      return this.status === ExposedPromiseStatus.RESOLVED;\n    }\n  }, {\n    key: \"isRejected\",\n    value: function isRejected() {\n      return this.status === ExposedPromiseStatus.REJECTED;\n    }\n  }, {\n    key: \"isSettled\",\n    value: function isSettled() {\n      return this.isResolved() || this.isRejected();\n    }\n  }], [{\n    key: \"resolve\",\n    value: function resolve(value) {\n      var promise = new ExposedPromise();\n      promise.resolve(value);\n      return promise;\n    }\n  }, {\n    key: \"reject\",\n    value: function reject(reason) {\n      var promise = new ExposedPromise();\n      promise.reject(reason);\n      return promise;\n    }\n  }]);\n\n  return ExposedPromise;\n}();","map":{"version":3,"sources":["../../../src/utils/exposed-promise.ts"],"names":[],"mappings":";;AAAA,OAAA,IAAY,oBAAZ;;AAAA,CAAA,UAAY,oBAAZ,EAAgC;AAC9B,EAAA,oBAAA,CAAA,SAAA,CAAA,GAAA,SAAA;AACA,EAAA,oBAAA,CAAA,UAAA,CAAA,GAAA,UAAA;AACA,EAAA,oBAAA,CAAA,UAAA,CAAA,GAAA,UAAA;AACD,CAJD,EAAY,oBAAoB,KAApB,oBAAoB,GAAA,EAAA,CAAhC;;AASA,IAAM,cAAc,GAAG,SAAjB,cAAiB,GAAY;AACjC,QAAM,IAAI,KAAJ,CAAU,qCAAV,CAAN;AACD,CAFD;AAIA;;AAEG;;;AACH,WAAa,cAAb;AA6BE,4BAAA;AAAA;;AAAA;;AA1BQ,SAAA,QAAA,GAAuB,cAAvB;AACA,SAAA,OAAA,GAAqB,cAArB;AACA,SAAA,OAAA,GAAgC,oBAAoB,CAAC,OAArD;AAyBN,SAAK,QAAL,GAAgB,IAAI,OAAJ,CAAe,UAAC,YAAD,EAA2B,WAA3B,EAA2D;AACxF,MAAA,KAAI,CAAC,QAAL,GAAgB,UAAC,KAAD,EAAoB;AAClC,YAAI,KAAI,CAAC,SAAL,EAAJ,EAAsB;AACpB;AACD;;AAED,QAAA,KAAI,CAAC,cAAL,GAAsB,KAAtB;AAEA,QAAA,YAAY,CAAC,KAAD,CAAZ;AAEA,QAAA,KAAI,CAAC,OAAL,GAAe,oBAAoB,CAAC,QAApC;AAEA;AACD,OAZD;;AAaA,MAAA,KAAI,CAAC,OAAL,GAAe,UAAC,MAAD,EAAqB;AAClC,YAAI,KAAI,CAAC,SAAL,EAAJ,EAAsB;AACpB;AACD;;AAED,QAAA,KAAI,CAAC,aAAL,GAAqB,MAArB;AAEA,QAAA,WAAW,CAAC,MAAD,CAAX;AAEA,QAAA,KAAI,CAAC,OAAL,GAAe,oBAAoB,CAAC,QAApC;AAEA;AACD,OAZD;AAaD,KA3Be,CAAhB;AA4BD;;AA1DH;AAAA;AAAA,SASE,eAAkB;AAChB,aAAO,KAAK,QAAZ;AACD;AAXH;AAAA;AAAA,SAaE,eAAkB;AAChB,aAAO,KAAK,QAAZ;AACD;AAfH;AAAA;AAAA,SAgBE,eAAiB;AACf,aAAO,KAAK,OAAZ;AACD;AAlBH;AAAA;AAAA,SAmBE,eAAiB;AACf,aAAO,KAAK,OAAZ;AACD;AArBH;AAAA;AAAA,SAsBE,eAAwB;AACtB,aAAO,KAAK,cAAZ;AACD;AAxBH;AAAA;AAAA,SAyBE,eAAuB;AACrB,aAAO,KAAK,aAAZ;AACD;AA3BH;AAAA;AAAA,WA0ES,qBAAS;AACd,aAAO,KAAK,MAAL,KAAgB,oBAAoB,CAAC,OAA5C;AACD;AA5EH;AAAA;AAAA,WA8ES,sBAAU;AACf,aAAO,KAAK,MAAL,KAAgB,oBAAoB,CAAC,QAA5C;AACD;AAhFH;AAAA;AAAA,WAkFS,sBAAU;AACf,aAAO,KAAK,MAAL,KAAgB,oBAAoB,CAAC,QAA5C;AACD;AApFH;AAAA;AAAA,WAsFS,qBAAS;AACd,aAAO,KAAK,UAAL,MAAqB,KAAK,UAAL,EAA5B;AACD;AAxFH;AAAA;AAAA,WA4DS,iBAAkB,KAAlB,EAA2B;AAChC,UAAM,OAAO,GAAG,IAAI,cAAJ,EAAhB;AACA,MAAA,OAAO,CAAC,OAAR,CAAgB,KAAhB;AAEA,aAAO,OAAP;AACD;AAjEH;AAAA;AAAA,WAmES,gBAAsC,MAAtC,EAAgD;AACrD,UAAM,OAAO,GAAG,IAAI,cAAJ,EAAhB;AACA,MAAA,OAAO,CAAC,MAAR,CAAe,MAAf;AAEA,aAAO,OAAP;AACD;AAxEH;;AAAA;AAAA","sourceRoot":"","sourcesContent":["export var ExposedPromiseStatus;\n(function (ExposedPromiseStatus) {\n    ExposedPromiseStatus[\"PENDING\"] = \"pending\";\n    ExposedPromiseStatus[\"RESOLVED\"] = \"resolved\";\n    ExposedPromiseStatus[\"REJECTED\"] = \"rejected\";\n})(ExposedPromiseStatus || (ExposedPromiseStatus = {}));\nconst notInitialized = () => {\n    throw new Error('ExposedPromise not initialized yet.');\n};\n/**\n * Exposed promise allow you to create a promise and then resolve it later, from the outside\n */\nexport class ExposedPromise {\n    constructor() {\n        this._resolve = notInitialized;\n        this._reject = notInitialized;\n        this._status = ExposedPromiseStatus.PENDING;\n        this._promise = new Promise((innerResolve, innerReject) => {\n            this._resolve = (value) => {\n                if (this.isSettled()) {\n                    return;\n                }\n                this._promiseResult = value;\n                innerResolve(value);\n                this._status = ExposedPromiseStatus.RESOLVED;\n                return;\n            };\n            this._reject = (reason) => {\n                if (this.isSettled()) {\n                    return;\n                }\n                this._promiseError = reason;\n                innerReject(reason);\n                this._status = ExposedPromiseStatus.REJECTED;\n                return;\n            };\n        });\n    }\n    get promise() {\n        return this._promise;\n    }\n    get resolve() {\n        return this._resolve;\n    }\n    get reject() {\n        return this._reject;\n    }\n    get status() {\n        return this._status;\n    }\n    get promiseResult() {\n        return this._promiseResult;\n    }\n    get promiseError() {\n        return this._promiseError;\n    }\n    static resolve(value) {\n        const promise = new ExposedPromise();\n        promise.resolve(value);\n        return promise;\n    }\n    static reject(reason) {\n        const promise = new ExposedPromise();\n        promise.reject(reason);\n        return promise;\n    }\n    isPending() {\n        return this.status === ExposedPromiseStatus.PENDING;\n    }\n    isResolved() {\n        return this.status === ExposedPromiseStatus.RESOLVED;\n    }\n    isRejected() {\n        return this.status === ExposedPromiseStatus.REJECTED;\n    }\n    isSettled() {\n        return this.isResolved() || this.isRejected();\n    }\n}\n//# sourceMappingURL=exposed-promise.js.map"]},"metadata":{},"sourceType":"module"}