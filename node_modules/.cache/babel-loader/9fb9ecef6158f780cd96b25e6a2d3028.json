{"ast":null,"code":"import { HttpBackend } from '@taquito/http-utils';\nimport { Schema, ParameterSchema } from '@taquito/michelson-encoder';\nimport { bytes2Char } from '@taquito/utils';\nexport { bytes2Char, char2Bytes } from '@taquito/utils';\nimport { Protocols, BigMapAbstraction } from '@taquito/taquito';\nimport BigNumber from 'bignumber.js';\nimport CryptoJS from 'crypto-js';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nfunction __generator(thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n}\n\nfunction __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n}\n\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++) {\n    ar = ar.concat(__read(arguments[i]));\n  }\n\n  return ar;\n}\n\nvar HttpHandler =\n/** @class */\nfunction () {\n  function HttpHandler() {\n    this.httpBackend = new HttpBackend();\n  }\n\n  HttpHandler.prototype.getMetadata = function (_contractAbstraction, _a, _context) {\n    var protocol = _a.protocol,\n        location = _a.location;\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_b) {\n        return [2\n        /*return*/\n        , this.httpBackend.createRequest({\n          url: protocol + \":\" + decodeURIComponent(location),\n          method: 'GET',\n          mimeType: \"text; charset=utf-8\",\n          json: false\n        })];\n      });\n    });\n  };\n\n  return HttpHandler;\n}();\n\nvar BigMapMetadataNotFound =\n/** @class */\nfunction () {\n  function BigMapMetadataNotFound() {\n    this.name = 'BigMapMetadataNotFound';\n    this.message = 'Non-compliance with the TZIP-016 standard. No big map named metadata was found in the contract storage.';\n  }\n\n  return BigMapMetadataNotFound;\n}();\n\nvar MetadataNotFound =\n/** @class */\nfunction () {\n  function MetadataNotFound(info) {\n    this.info = info;\n    this.name = 'MetadataNotFound';\n    this.message = \"No metadata was found in the contract storage. \" + info;\n  }\n\n  return MetadataNotFound;\n}();\n\nvar UriNotFound =\n/** @class */\nfunction () {\n  function UriNotFound() {\n    this.name = 'UriNotFound';\n    this.message = 'Non-compliance with the TZIP-016 standard. No URI found in the contract storage.';\n  }\n\n  return UriNotFound;\n}();\n\nvar InvalidUri =\n/** @class */\nfunction () {\n  function InvalidUri(uri) {\n    this.uri = uri;\n    this.name = 'InvalidUri';\n    this.message = \"Non-compliance with the TZIP-016 standard. The URI is invalid: \" + uri + \".\";\n  }\n\n  return InvalidUri;\n}();\n\nvar InvalidMetadata =\n/** @class */\nfunction () {\n  function InvalidMetadata(invalidMetadata) {\n    this.invalidMetadata = invalidMetadata;\n    this.name = 'InvalidMetadata';\n    this.message = \"The metadata found at the pointed ressource are not compliant with tzip16 standard: \" + invalidMetadata + \".\";\n  }\n\n  return InvalidMetadata;\n}();\n\nvar ProtocolNotSupported =\n/** @class */\nfunction () {\n  function ProtocolNotSupported(protocol) {\n    this.protocol = protocol;\n    this.name = 'ProtocolNotSupported';\n    this.message = \"The protocol found in the URI is not supported: \" + protocol + \".\";\n  }\n\n  return ProtocolNotSupported;\n}();\n\nvar InvalidMetadataType =\n/** @class */\nfunction () {\n  function InvalidMetadataType() {\n    this.name = 'InvalidMetadataType';\n    this.message = 'The contract does not comply with the tzip16 standard. The type of metadata should be bytes.';\n  }\n\n  return InvalidMetadataType;\n}();\n\nvar UnconfiguredMetadataProviderError =\n/** @class */\nfunction () {\n  function UnconfiguredMetadataProviderError() {\n    this.name = 'UnconfiguredMetadataProviderError';\n    this.message = 'No metadata provider has been configured. The default one can be configured by calling addExtension(new Tzip16Module()) on your TezosToolkit instance.';\n  }\n\n  return UnconfiguredMetadataProviderError;\n}();\n\nvar ForbiddenInstructionInViewCode =\n/** @class */\nfunction () {\n  function ForbiddenInstructionInViewCode(instruction) {\n    this.instruction = instruction;\n    this.name = 'ForbiddenInstructionInViewCode';\n    this.message = \"Erreur found in the code of the view. It contains a forbidden instruction: \" + instruction + \".\";\n  }\n\n  return ForbiddenInstructionInViewCode;\n}();\n\nvar NoParameterExpectedError =\n/** @class */\nfunction () {\n  function NoParameterExpectedError(viewName, args) {\n    this.viewName = viewName;\n    this.args = args;\n    this.name = 'NoParameterExpectedError';\n    this.message = viewName + \" Received \" + args.length + \" arguments while expecting no parameter or 'Unit'\";\n  }\n\n  return NoParameterExpectedError;\n}();\n\nvar InvalidViewParameterError =\n/** @class */\nfunction () {\n  function InvalidViewParameterError(viewName, sigs, args) {\n    this.viewName = viewName;\n    this.sigs = sigs;\n    this.args = args;\n    this.name = 'InvalidViewParameterError';\n    this.message = viewName + \" Received \" + args.length + \" arguments while expecting one of the following signatures (\" + JSON.stringify(sigs) + \")\";\n  }\n\n  return InvalidViewParameterError;\n}();\n\nvar typeOfValueToFind = {\n  prim: 'big_map',\n  args: [{\n    prim: 'string'\n  }, {\n    prim: 'bytes'\n  }],\n  annots: ['%metadata']\n};\n\nvar TezosStorageHandler =\n/** @class */\nfunction () {\n  function TezosStorageHandler() {\n    this.TEZOS_STORAGE_REGEX = /^(?:\\/\\/(KT1\\w{33})(?:\\.(.+))?\\/)?([\\w|\\%]+)$/;\n  }\n\n  TezosStorageHandler.prototype.getMetadata = function (contractAbstraction, _a, context) {\n    var location = _a.location;\n    return __awaiter(this, void 0, void 0, function () {\n      var parsedTezosStorageUri, storage, bigMapId, bytes;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            parsedTezosStorageUri = this.parseTezosStorageUri(location);\n\n            if (!parsedTezosStorageUri) {\n              throw new InvalidUri(\"tezos-storage:\" + location);\n            }\n\n            return [4\n            /*yield*/\n            , context.rpc.getScript(parsedTezosStorageUri.contractAddress || contractAbstraction.address)];\n\n          case 1:\n            storage = _b.sent();\n            bigMapId = Schema.fromRPCResponse({\n              script: storage\n            }).FindFirstInTopLevelPair(storage.storage, typeOfValueToFind);\n\n            if (!bigMapId) {\n              throw new BigMapMetadataNotFound();\n            }\n\n            return [4\n            /*yield*/\n            , context.contract.getBigMapKeyByID(bigMapId['int'].toString(), parsedTezosStorageUri.path, new Schema(typeOfValueToFind))];\n\n          case 2:\n            bytes = _b.sent();\n\n            if (!bytes) {\n              throw new MetadataNotFound(\"No '\" + parsedTezosStorageUri.path + \"' key found in the big map %metadata of the contract \" + (parsedTezosStorageUri.contractAddress || contractAbstraction.address));\n            }\n\n            if (!/^[0-9a-fA-F]*$/.test(bytes)) {\n              throw new InvalidMetadataType();\n            }\n\n            return [2\n            /*return*/\n            , bytes2Char(bytes)];\n        }\n      });\n    });\n  };\n  /**\r\n   * @description Extract the smart contract address, the network and the path pointing to the metadata from the uri\r\n   * @returns an object which contains the properties allowing to find where the metadata are located or it returns undefined if the uri is not valid\r\n   * @param tezosStorageURI URI (without the tezos-storage prefix)\r\n   */\n\n\n  TezosStorageHandler.prototype.parseTezosStorageUri = function (tezosStorageURI) {\n    var extractor = this.TEZOS_STORAGE_REGEX.exec(tezosStorageURI);\n    if (!extractor) return;\n    return {\n      contractAddress: extractor[1],\n      network: extractor[2],\n      path: decodeURIComponent(extractor[3])\n    };\n  };\n\n  return TezosStorageHandler;\n}();\n\nvar IpfsHttpHandler =\n/** @class */\nfunction () {\n  function IpfsHttpHandler(ipfsGatheway) {\n    this._httpBackend = new HttpBackend();\n    this._ipfsGateway = ipfsGatheway ? ipfsGatheway : 'ipfs.io';\n  }\n\n  IpfsHttpHandler.prototype.getMetadata = function (_contractAbstraction, _a, _context) {\n    var location = _a.location;\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_b) {\n        return [2\n        /*return*/\n        , this._httpBackend.createRequest({\n          url: \"https://\" + this._ipfsGateway + \"/ipfs/\" + location.substring(2) + \"/\",\n          method: 'GET',\n          headers: {\n            'Content-Type': 'text/plain'\n          },\n          mimeType: \"text; charset=utf-8\",\n          json: false\n        })];\n      });\n    });\n  };\n\n  return IpfsHttpHandler;\n}();\n\nvar ViewImplementationType;\n\n(function (ViewImplementationType) {\n  ViewImplementationType[\"MICHELSON_STORAGE\"] = \"michelsonStorageView\";\n  ViewImplementationType[\"REST_API_QUERY\"] = \"restApiQuery\";\n})(ViewImplementationType || (ViewImplementationType = {}));\n\nvar MichelsonStorageView =\n/** @class */\nfunction () {\n  function MichelsonStorageView(viewName, contract, rpc, returnType, code, viewParameterType) {\n    this.viewName = viewName;\n    this.contract = contract;\n    this.rpc = rpc;\n    this.returnType = returnType;\n    this.code = code;\n    this.viewParameterType = viewParameterType;\n\n    this.validateArgs = function (args, schema, viewName) {\n      var sigs = schema.ExtractSignatures();\n\n      if (!sigs.find(function (x) {\n        return x.length === args.length;\n      })) {\n        throw new InvalidViewParameterError(viewName, sigs, args);\n      }\n    };\n  }\n  /**\r\n   * @description According to the tzip-16 standard, the following instructions must not be used in the code of the view:\r\n   * 'AMOUNT', 'CREATE_CONTRACT', 'SENDER', 'SET_DELEGATE', 'SOURCE', and 'TRANSFER_TOKENS'\r\n   * The method throw an error if an illegal instruction is found\r\n   */\n\n\n  MichelsonStorageView.prototype.findForbiddenInstructionInViewCode = function (code) {\n    var e_1, _a, e_2, _b;\n\n    var illegalInstructions = ['AMOUNT', 'CREATE_CONTRACT', 'SENDER', 'SET_DELEGATE', 'SOURCE', 'TRANSFER_TOKENS'];\n\n    try {\n      for (var illegalInstructions_1 = __values(illegalInstructions), illegalInstructions_1_1 = illegalInstructions_1.next(); !illegalInstructions_1_1.done; illegalInstructions_1_1 = illegalInstructions_1.next()) {\n        var forbiddenInstruction = illegalInstructions_1_1.value;\n\n        try {\n          for (var code_1 = (e_2 = void 0, __values(code)), code_1_1 = code_1.next(); !code_1_1.done; code_1_1 = code_1.next()) {\n            var instruction = code_1_1.value;\n\n            if (instruction.prim === forbiddenInstruction) {\n              throw new ForbiddenInstructionInViewCode(forbiddenInstruction);\n            }\n\n            if (instruction.args && instruction.args.length !== 0) {\n              this.findForbiddenInstructionInViewCode(instruction.args);\n            }\n          }\n        } catch (e_2_1) {\n          e_2 = {\n            error: e_2_1\n          };\n        } finally {\n          try {\n            if (code_1_1 && !code_1_1.done && (_b = code_1.return)) _b.call(code_1);\n          } finally {\n            if (e_2) throw e_2.error;\n          }\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (illegalInstructions_1_1 && !illegalInstructions_1_1.done && (_a = illegalInstructions_1.return)) _a.call(illegalInstructions_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  };\n  /**\r\n   * @description According to the tzip-16 standard, in the first version of the specification, the instruction SELF should only be used before ADDRESS\r\n   * The method throws an error is the instruction SELF is present, but not followed by ADDRESS\r\n   */\n\n\n  MichelsonStorageView.prototype.illegalUseOfSelfInstruction = function (code) {\n    var e_3, _a;\n\n    try {\n      for (var code_2 = __values(code), code_2_1 = code_2.next(); !code_2_1.done; code_2_1 = code_2.next()) {\n        var instruction = code_2_1.value;\n\n        if (instruction.prim === 'SELF') {\n          var index = code.indexOf(instruction);\n          var nextInstruction = code[index + 1] ? code[index + 1].prim : undefined;\n\n          if (nextInstruction !== 'ADDRESS') {\n            throw new ForbiddenInstructionInViewCode('the instruction SELF should only be used before ADDRESS');\n          }\n        }\n\n        if (instruction.args && instruction.args.length !== 0) {\n          this.illegalUseOfSelfInstruction(instruction.args);\n        }\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (code_2_1 && !code_2_1.done && (_a = code_2.return)) _a.call(code_2);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n  };\n  /**\r\n   * @description Loops through the view's code and replace SELF, BALANCE, NOW, and CHAIN_ID with Michelson expressions that match the current context, if applicable.\r\n   */\n\n\n  MichelsonStorageView.prototype.adaptViewCodeToContext = function (code, contractBalance, blockTimeStamp, chainId) {\n    var _this = this;\n\n    var instructionsToReplace = {\n      SELF: [{\n        prim: 'PUSH',\n        args: [{\n          prim: 'address'\n        }, {\n          string: this.contract.address\n        }]\n      }, {\n        prim: 'CONTRACT',\n        args: [{\n          prim: 'unit'\n        }]\n      }, {\n        prim: 'IF_NONE',\n        args: [[{\n          prim: 'UNIT'\n        }, {\n          prim: 'FAILWITH'\n        }], []]\n      }],\n      BALANCE: [{\n        prim: 'PUSH',\n        args: [{\n          prim: 'mutez'\n        }, {\n          int: contractBalance\n        }]\n      }],\n      NOW: [{\n        prim: 'PUSH',\n        args: [{\n          prim: 'timestamp'\n        }, {\n          string: blockTimeStamp\n        }]\n      }],\n      CHAIN_ID: [{\n        prim: 'PUSH',\n        args: [{\n          prim: 'string'\n        }, {\n          string: chainId\n        }]\n      }]\n    };\n    code.forEach(function (x, i) {\n      for (var instruction in instructionsToReplace) {\n        if (x.prim === instruction) {\n          code[i] = Object(instructionsToReplace)[instruction];\n        }\n\n        if (x.args && x.args.length !== 0) {\n          _this.adaptViewCodeToContext(x.args, contractBalance, blockTimeStamp, chainId);\n        }\n      }\n    });\n    return code;\n  };\n\n  MichelsonStorageView.prototype.formatArgsAndParameter = function (argView) {\n    var args = argView;\n    var viewParameterType = this.viewParameterType;\n\n    if (!viewParameterType) {\n      viewParameterType = {\n        args: [],\n        prim: 'unit',\n        annots: []\n      };\n    }\n\n    if (viewParameterType.prim === 'unit') {\n      if (args.length === 0) {\n        args = ['Unit'];\n      }\n\n      if (args.length !== 0 && args[0] !== 'Unit') {\n        throw new NoParameterExpectedError(this.viewName, argView);\n      }\n    }\n\n    var parameterViewSchema = new ParameterSchema(viewParameterType);\n    this.validateArgs(args, parameterViewSchema, this.viewName);\n    var arg = parameterViewSchema.Encode.apply(parameterViewSchema, __spread(args));\n    return {\n      arg: arg,\n      viewParameterType: viewParameterType\n    };\n  };\n\n  MichelsonStorageView.prototype.executeView = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, arg, viewParameterType, storageType, storageArgs, storageValue, chainId, contractBalance, block, blockTimestamp, protocolHash, code, viewScript, result, viewResultSchema;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            // validate view code against tzip-16 specifications\n            this.findForbiddenInstructionInViewCode(this.code);\n            this.illegalUseOfSelfInstruction(this.code);\n            _a = this.formatArgsAndParameter(args), arg = _a.arg, viewParameterType = _a.viewParameterType;\n            storageType = this.contract.script.code.find(function (x) {\n              return x.prim === 'storage';\n            });\n            storageArgs = storageType.args[0];\n            storageValue = this.contract.script.storage;\n            return [4\n            /*yield*/\n            , this.rpc.getChainId()];\n\n          case 1:\n            chainId = _b.sent();\n            return [4\n            /*yield*/\n            , this.rpc.getBalance(this.contract.address)];\n\n          case 2:\n            contractBalance = _b.sent().toString();\n            return [4\n            /*yield*/\n            , this.rpc.getBlock()];\n\n          case 3:\n            block = _b.sent();\n            blockTimestamp = block.header.timestamp.toString();\n            protocolHash = block.protocol;\n            code = this.adaptViewCodeToContext(this.code, contractBalance, blockTimestamp, chainId);\n\n            if (!this.viewParameterType) {\n              code.unshift({\n                prim: 'CDR'\n              });\n            }\n\n            viewScript = {\n              script: [{\n                prim: 'parameter',\n                args: [{\n                  prim: 'pair',\n                  args: [viewParameterType, storageArgs]\n                }]\n              }, {\n                prim: 'storage',\n                args: [{\n                  prim: 'option',\n                  args: [this.returnType]\n                }]\n              }, {\n                prim: 'code',\n                args: [[{\n                  prim: 'CAR'\n                }, code, {\n                  prim: 'SOME'\n                }, {\n                  prim: 'NIL',\n                  args: [{\n                    prim: 'operation'\n                  }]\n                }, {\n                  prim: 'PAIR'\n                }]]\n              }],\n              storage: {\n                prim: 'None'\n              },\n              input: {\n                prim: 'Pair',\n                args: [arg, storageValue]\n              },\n              amount: '0',\n              chain_id: chainId\n            }; // Fix for Edo which required a balance property when calling the run_code endpoint\n\n            if (protocolHash === Protocols.PtEdo2Zk || protocolHash === Protocols.PsFLorena) {\n              Object.assign(viewScript, {\n                balance: '0'\n              });\n            }\n\n            return [4\n            /*yield*/\n            , this.rpc.runCode(viewScript)];\n\n          case 4:\n            result = _b.sent();\n            viewResultSchema = new ParameterSchema(this.returnType);\n            return [2\n            /*return*/\n            , viewResultSchema.Execute(result.storage.args[0])];\n        }\n      });\n    });\n  };\n\n  return MichelsonStorageView;\n}();\n\nvar ViewFactory =\n/** @class */\nfunction () {\n  function ViewFactory() {}\n\n  ViewFactory.prototype.getView = function (viewName, rpc, contract, viewImplementation) {\n    if (this.isMichelsonStorageView(viewImplementation)) {\n      var viewValues_1 = viewImplementation[ViewImplementationType.MICHELSON_STORAGE];\n\n      if (!viewValues_1.returnType || !viewValues_1.code) {\n        console.warn(viewName + \" is missing mandatory code or returnType property therefore it will be skipped.\");\n        return;\n      }\n\n      return function () {\n        var view = new MichelsonStorageView(viewName, contract, rpc, viewValues_1.returnType, viewValues_1.code, viewValues_1.parameter);\n        return view;\n      };\n    }\n  };\n\n  ViewFactory.prototype.getImplementationType = function (viewImplementation) {\n    return Object.keys(viewImplementation)[0];\n  };\n\n  ViewFactory.prototype.isMichelsonStorageView = function (viewImplementation) {\n    return this.getImplementationType(viewImplementation) === ViewImplementationType.MICHELSON_STORAGE;\n  };\n\n  return ViewFactory;\n}();\n\nvar metadataBigMapType = {\n  prim: 'big_map',\n  args: [{\n    prim: 'string'\n  }, {\n    prim: 'bytes'\n  }],\n  annots: ['%metadata']\n};\n\nvar Tzip16ContractAbstraction =\n/** @class */\nfunction () {\n  function Tzip16ContractAbstraction(constractAbstraction, context) {\n    this.constractAbstraction = constractAbstraction;\n    this.context = context;\n    this._viewFactory = new ViewFactory();\n    this._metadataViewsObject = {};\n    this._metadataProvider = context.metadataProvider;\n  }\n\n  Tzip16ContractAbstraction.prototype.findMetadataBigMap = function () {\n    var metadataBigMapId = this.constractAbstraction.schema.FindFirstInTopLevelPair(this.constractAbstraction.script.storage, metadataBigMapType);\n\n    if (!metadataBigMapId) {\n      throw new BigMapMetadataNotFound();\n    }\n\n    return new BigMapAbstraction(new BigNumber(metadataBigMapId['int']), new Schema(metadataBigMapType), this.context.contract);\n  };\n\n  Tzip16ContractAbstraction.prototype.getUriOrFail = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var metadataBigMap, uri;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            metadataBigMap = this.findMetadataBigMap();\n            return [4\n            /*yield*/\n            , metadataBigMap.get('')];\n\n          case 1:\n            uri = _a.sent();\n\n            if (!uri) {\n              throw new UriNotFound();\n            }\n\n            return [2\n            /*return*/\n            , uri];\n        }\n      });\n    });\n  };\n  /**\r\n   * @description Return an object containing the metadata, the uri, an optional integrity check result and an optional sha256 hash\r\n   */\n\n\n  Tzip16ContractAbstraction.prototype.getMetadata = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var uri, _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!this._metadataProvider) {\n              throw new UnconfiguredMetadataProviderError();\n            }\n\n            if (!!this._metadataEnvelope) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , this.getUriOrFail()];\n\n          case 1:\n            uri = _b.sent();\n            _a = this;\n            return [4\n            /*yield*/\n            , this._metadataProvider.provideMetadata(this.constractAbstraction, bytes2Char(uri), this.context)];\n\n          case 2:\n            _a._metadataEnvelope = _b.sent();\n            _b.label = 3;\n\n          case 3:\n            return [2\n            /*return*/\n            , this._metadataEnvelope];\n        }\n      });\n    });\n  };\n\n  Tzip16ContractAbstraction.prototype.metadataViews = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!(Object.keys(this._metadataViewsObject).length === 0)) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.initializeMetadataViewsList()];\n\n          case 1:\n            _a.sent();\n\n            _a.label = 2;\n\n          case 2:\n            return [2\n            /*return*/\n            , this._metadataViewsObject];\n        }\n      });\n    });\n  };\n\n  Tzip16ContractAbstraction.prototype.initializeMetadataViewsList = function () {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var metadata, metadataViews;\n\n      var _this = this;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.getMetadata()];\n\n          case 1:\n            metadata = _b.sent().metadata;\n            metadataViews = {};\n            (_a = metadata.views) === null || _a === void 0 ? void 0 : _a.forEach(function (view) {\n              return _this.createViewImplementations(view, metadataViews);\n            });\n            this._metadataViewsObject = metadataViews;\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  Tzip16ContractAbstraction.prototype.generateIndexedViewName = function (viewName, metadataViews) {\n    var i = 1;\n\n    if (viewName in metadataViews) {\n      while (\"\" + viewName + i in metadataViews) {\n        i++;\n      }\n\n      viewName = \"\" + viewName + i;\n    }\n\n    return viewName;\n  };\n\n  Tzip16ContractAbstraction.prototype.createViewImplementations = function (view, metadataViews) {\n    var e_1, _a;\n\n    var _b;\n\n    try {\n      for (var _c = __values((_b = view === null || view === void 0 ? void 0 : view.implementations) !== null && _b !== void 0 ? _b : []), _d = _c.next(); !_d.done; _d = _c.next()) {\n        var viewImplementation = _d.value;\n\n        if (view.name) {\n          // when views have the same name, add an index at the end of the name\n          var viewName = this.generateIndexedViewName(view.name, metadataViews);\n\n          var metadataView = this._viewFactory.getView(viewName, this.context.rpc, this.constractAbstraction, viewImplementation);\n\n          if (metadataView) {\n            metadataViews[viewName] = metadataView;\n          } else {\n            console.warn(\"Skipped generating \" + viewName + \" because the view has an unsupported type: \" + this._viewFactory.getImplementationType(viewImplementation));\n          }\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  };\n\n  return Tzip16ContractAbstraction;\n}();\n\nvar ABSTRACTION_KEY = Symbol(\"Tzip16ContractAbstractionObjectKey\");\n\nfunction tzip16(abs, context) {\n  return Object.assign(abs, {\n    // namespace tzip16\n    tzip16: function tzip16() {\n      if (!this[ABSTRACTION_KEY]) {\n        this[ABSTRACTION_KEY] = new Tzip16ContractAbstraction(this, context);\n      }\n\n      return this[ABSTRACTION_KEY];\n    }\n  });\n}\n\nfunction calculateSHA256Hash(preimage) {\n  return CryptoJS.SHA256(preimage).toString(CryptoJS.enc.Hex);\n}\n/**\r\n * @description: Metadata Provider\r\n */\n\n\nvar MetadataProvider =\n/** @class */\nfunction () {\n  function MetadataProvider(handlers) {\n    this.handlers = handlers;\n    this.PROTOCOL_REGEX = /(?:sha256\\:\\/\\/0x(.*)\\/)?(https?|ipfs|tezos-storage)\\:(.*)/;\n  }\n  /**\r\n   * @description Fetch the metadata by using the appropriate handler based on the protcol found in the URI\r\n   * @returns an object which contains the uri, the metadata, an optional integrity check result and an optional SHA256 hash\r\n   * @param _contractAbstraction the contract abstraction which contains the URI in its storage\r\n   * @param _uri the decoded uri found in the storage\r\n   * @param context the TezosToolkit Context\r\n   */\n\n\n  MetadataProvider.prototype.provideMetadata = function (contractAbstraction, uri, context) {\n    return __awaiter(this, void 0, void 0, function () {\n      var uriInfo, handler, metadata, sha256Hash, metadataJSON;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            uriInfo = this.extractProtocolInfo(uri);\n\n            if (!uriInfo || !uriInfo.location) {\n              throw new InvalidUri(uri);\n            }\n\n            handler = this.handlers.get(uriInfo.protocol);\n\n            if (!handler) {\n              throw new ProtocolNotSupported(uriInfo.protocol);\n            }\n\n            return [4\n            /*yield*/\n            , handler.getMetadata(contractAbstraction, uriInfo, context)];\n\n          case 1:\n            metadata = _a.sent();\n            sha256Hash = calculateSHA256Hash(metadata);\n\n            try {\n              metadataJSON = JSON.parse(metadata);\n            } catch (ex) {\n              throw new InvalidMetadata(metadata);\n            }\n\n            return [2\n            /*return*/\n            , {\n              uri: uri,\n              metadata: metadataJSON,\n              integrityCheckResult: uriInfo.sha256hash ? uriInfo.sha256hash === sha256Hash : undefined,\n              sha256Hash: uriInfo.sha256hash ? sha256Hash : undefined\n            }];\n        }\n      });\n    });\n  };\n\n  MetadataProvider.prototype.extractProtocolInfo = function (_uri) {\n    var extractor = this.PROTOCOL_REGEX.exec(_uri);\n    if (!extractor) return;\n    return {\n      sha256hash: extractor[1],\n      protocol: extractor[2],\n      location: extractor[3]\n    };\n  };\n\n  return MetadataProvider;\n}();\n\nvar DEFAULT_HANDLERS = new Map([['http', new HttpHandler()], ['https', new HttpHandler()], ['tezos-storage', new TezosStorageHandler()], ['ipfs', new IpfsHttpHandler()]]);\n\nvar Tzip16Module =\n/** @class */\nfunction () {\n  function Tzip16Module(metadataProvider) {\n    this._metadataProvider = metadataProvider ? metadataProvider : new MetadataProvider(DEFAULT_HANDLERS);\n  }\n\n  Tzip16Module.prototype.configureContext = function (context) {\n    Object.assign(context, {\n      metadataProvider: this._metadataProvider\n    });\n  };\n\n  return Tzip16Module;\n}(); // IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!\n\n/* tslint:disable */\n\n\nvar VERSION = {\n  \"commitHash\": \"334454ed1f3717affb11a943e271fe2a6330a0c5\",\n  \"version\": \"9.0.1\"\n};\n/* tslint:enable */\n\nexport { BigMapMetadataNotFound, DEFAULT_HANDLERS, ForbiddenInstructionInViewCode, HttpHandler, InvalidMetadata, InvalidMetadataType, InvalidUri, InvalidViewParameterError, IpfsHttpHandler, MetadataNotFound, MetadataProvider, MichelsonStorageView, NoParameterExpectedError, ProtocolNotSupported, TezosStorageHandler, Tzip16ContractAbstraction, Tzip16Module, UnconfiguredMetadataProviderError, UriNotFound, VERSION, ViewFactory, ViewImplementationType, calculateSHA256Hash, tzip16 };","map":{"version":3,"sources":["../src/handlers/http-handler.ts","../src/tzip16-errors.ts","../src/handlers/tezos-storage-handler.ts","../src/handlers/ipfs-handler.ts","../src/metadata-interface.ts","../src/viewKind/michelson-storage-view.ts","../src/viewKind/viewFactory.ts","../src/tzip16-contract-abstraction.ts","../src/composer.ts","../src/tzip16-utils.ts","../src/metadata-provider.ts","../src/tzip16-extension.ts","../src/version.ts"],"names":[],"mappings":"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","sourcesContent":["import { HttpBackend } from \"@taquito/http-utils\";\nimport { ContractAbstraction, ContractProvider, Wallet, Context } from \"@taquito/taquito\";\nimport { Handler, Tzip16Uri } from \"../metadata-provider\";\n\nexport class HttpHandler implements Handler {\n    httpBackend: HttpBackend;\n    constructor() {\n        this.httpBackend = new HttpBackend();\n    }\n    async getMetadata(_contractAbstraction: ContractAbstraction<ContractProvider | Wallet>, { protocol, location }: Tzip16Uri, _context: Context) {\n        return this.httpBackend.createRequest<string>({\n            url: `${protocol}:${decodeURIComponent(location)}`,\n            method: 'GET',\n            mimeType: \"text; charset=utf-8\",\n            json: false\n        })\n    }\n}","export class BigMapMetadataNotFound implements Error {\n    name = 'BigMapMetadataNotFound';\n    message = 'Non-compliance with the TZIP-016 standard. No big map named metadata was found in the contract storage.';\n}\n\nexport class MetadataNotFound implements Error {\n    name: string = 'MetadataNotFound';\n    message: string;\n\n    constructor(public info: string) {\n        this.message = `No metadata was found in the contract storage. ${info}`;\n    }\n}\n\nexport class UriNotFound implements Error {\n    name = 'UriNotFound';\n    message = 'Non-compliance with the TZIP-016 standard. No URI found in the contract storage.';\n}\n\nexport class InvalidUri implements Error {\n    name: string = 'InvalidUri';\n    message: string;\n\n    constructor(public uri: string) {\n        this.message = `Non-compliance with the TZIP-016 standard. The URI is invalid: ${uri}.`;\n    }\n}\n\nexport class InvalidMetadata implements Error {\n    name: string = 'InvalidMetadata';\n    message: string;\n\n    constructor(public invalidMetadata: string) {\n        this.message = `The metadata found at the pointed ressource are not compliant with tzip16 standard: ${invalidMetadata}.`;\n    }\n}\n\nexport class ProtocolNotSupported implements Error {\n    name: string = 'ProtocolNotSupported';\n    message: string;\n\n    constructor(public protocol: string) {\n        this.message = `The protocol found in the URI is not supported: ${protocol}.`;\n    }\n}\n\nexport class InvalidMetadataType implements Error {\n    name = 'InvalidMetadataType';\n    message = 'The contract does not comply with the tzip16 standard. The type of metadata should be bytes.';\n}\n\nexport class UnconfiguredMetadataProviderError implements Error {\n    name = 'UnconfiguredMetadataProviderError';\n    message =\n        'No metadata provider has been configured. The default one can be configured by calling addExtension(new Tzip16Module()) on your TezosToolkit instance.';\n}\n\nexport class ForbiddenInstructionInViewCode implements Error {\n    name: string = 'ForbiddenInstructionInViewCode';\n    message: string;\n\n    constructor(public instruction: string) {\n        this.message = `Erreur found in the code of the view. It contains a forbidden instruction: ${instruction}.`;\n    }\n}\n\nexport class NoParameterExpectedError implements Error {\n    name: string = 'NoParameterExpectedError';\n    message: string;\n    constructor(public viewName: string, public args: any[]) {\n        this.message = `${viewName} Received ${args.length} arguments while expecting no parameter or 'Unit'`;\n    }\n}\n\nexport class InvalidViewParameterError implements Error {\n    name: string = 'InvalidViewParameterError';\n    message: string;\n    constructor(public viewName: string, public sigs: any[], public args: any[]) {\n        this.message = `${viewName} Received ${args.length} arguments while expecting one of the following signatures (${JSON.stringify(sigs)})`;\n    }\n}","import { Schema } from '@taquito/michelson-encoder';\nimport { Context, ContractAbstraction, ContractProvider, Wallet } from '@taquito/taquito';\nimport { Handler, Tzip16Uri } from '../metadata-provider';\nimport { bytes2Char } from '@taquito/utils';\nimport { InvalidMetadataType, BigMapMetadataNotFound, InvalidUri, MetadataNotFound } from '../tzip16-errors';\n\nconst typeOfValueToFind = {\n    prim: 'big_map',\n    args: [{ prim: 'string' }, { prim: 'bytes' }],\n    annots: ['%metadata']\n};\n\ntype BigMapId = { int: string };\n\nexport class TezosStorageHandler implements Handler {\n    private readonly TEZOS_STORAGE_REGEX = /^(?:\\/\\/(KT1\\w{33})(?:\\.(.+))?\\/)?([\\w|\\%]+)$/;\n\n    async getMetadata(\n        contractAbstraction: ContractAbstraction<ContractProvider | Wallet>,\n        { location }: Tzip16Uri,\n        context: Context\n    ) {\n        const parsedTezosStorageUri = this.parseTezosStorageUri(location);\n        if (!parsedTezosStorageUri) {\n            throw new InvalidUri(`tezos-storage:${location}`);\n        }\n        const storage: any = await context.rpc.getScript(parsedTezosStorageUri.contractAddress || contractAbstraction.address);\n        const bigMapId = Schema.fromRPCResponse({ script: storage }).FindFirstInTopLevelPair<BigMapId>(\n            storage.storage,\n            typeOfValueToFind\n        );\n\n        if (!bigMapId) {\n            throw new BigMapMetadataNotFound();\n        }\n\n        const bytes = await context.contract.getBigMapKeyByID<string>(\n            bigMapId['int'].toString(),\n            parsedTezosStorageUri.path,\n            new Schema(typeOfValueToFind)\n        );\n\n        if (!bytes) {\n            throw new MetadataNotFound(`No '${parsedTezosStorageUri.path}' key found in the big map %metadata of the contract ${parsedTezosStorageUri.contractAddress || contractAbstraction.address}`);\n        }\n\n        if (!/^[0-9a-fA-F]*$/.test(bytes)) {\n            throw new InvalidMetadataType();\n        }\n        return bytes2Char(bytes);\n    }\n\n    /**\n     * @description Extract the smart contract address, the network and the path pointing to the metadata from the uri\n     * @returns an object which contains the properties allowing to find where the metadata are located or it returns undefined if the uri is not valid\n     * @param tezosStorageURI URI (without the tezos-storage prefix)\n     */\n    private parseTezosStorageUri(tezosStorageURI: string) {\n        const extractor = this.TEZOS_STORAGE_REGEX.exec(tezosStorageURI);\n        if (!extractor) return;\n        return {\n            contractAddress: extractor[1],\n            network: extractor[2],\n            path: decodeURIComponent(extractor[3])\n        };\n    }\n}\n","import { HttpBackend } from \"@taquito/http-utils\";\nimport { ContractAbstraction, ContractProvider, Wallet, Context } from \"@taquito/taquito\";\nimport { Handler, Tzip16Uri } from \"../metadata-provider\";\n\nexport class IpfsHttpHandler implements Handler {\n    private _ipfsGateway: string;\n    private _httpBackend = new HttpBackend();\n\n    constructor(ipfsGatheway?:string){\n        this._ipfsGateway = ipfsGatheway? ipfsGatheway: 'ipfs.io';\n    }\n\n    async getMetadata(_contractAbstraction: ContractAbstraction<ContractProvider | Wallet>, { location }: Tzip16Uri, _context: Context): Promise<string> {\n        return this._httpBackend.createRequest<string>({\n            url: `https://${this._ipfsGateway}/ipfs/${location.substring(2)}/`,\n            method: 'GET',\n            headers: {'Content-Type': 'text/plain'},\n            mimeType: \"text; charset=utf-8\",\n            json: false\n        })\n    }\n}","import { MichelsonV1Expression } from '@taquito/rpc';\nexport interface MetadataInterface {\n\tname?: string;\n\tdescription?: string;\n\tversion?: string;\n\tlicense?: { name: string; details?: string };\n\tauthors?: string[];\n\thomepage?: string;\n\tsource?: { tools?: string[]; location?: string };\n\tinterfaces?: string[];\n\terrors?: ErrorsTzip16;\n\tviews?: Views;\n}\n\nexport type ErrorsTzip16 = Array<\n\t| { error: MichelineTzip16Expression; expansion: MichelineTzip16Expression; languages?: string[] }\n\t| { view: string; languages?: string[] }\n>;\n\nexport enum ViewImplementationType {\n\tMICHELSON_STORAGE = 'michelsonStorageView',\n\tREST_API_QUERY = 'restApiQuery'\n}\n\nexport type ViewImplementation =\n\t| { [ViewImplementationType.MICHELSON_STORAGE]: MichelsonStorageViewType }\n\t| { [ViewImplementationType.REST_API_QUERY]: RestApiQueryType };\n\nexport interface ViewDefinition {\n\tname?: string;\n\tdescription?: string;\n\timplementations?: ViewImplementation[];\n\tpure?: boolean;\n}\n\nexport type Views = ViewDefinition[];\n\nexport type MichelsonStorageViewType = {\n\tparameter?: MichelineTzip16Expression;\n\treturnType: MichelineTzip16Expression;\n\tcode: MichelineTzip16Expression;\n\tannotations?: Array<{ name: string; description: string }>;\n\tversion?: string;\n};\n\nexport type RestApiQueryType = {\n\tspecificationUri: string;\n\tbaseUri?: string;\n\tpath: string;\n\tmethod?: 'GET' | 'POST' | 'PUT';\n};\n\nexport type MichelineTzip16Expression =\n\t| MichelsonV1Expression\n\t| MichelineTzip16Expression[]\n\t| { prim: Unistring; args?: MichelineTzip16Expression[]; annots?: string[] };\n\ntype Unistring = string | { invalid_utf8_string: number[] };\n","import { ParameterSchema } from '@taquito/michelson-encoder';\nimport { RpcClient, MichelsonV1Expression, MichelsonV1ExpressionExtended } from '@taquito/rpc';\nimport { ContractAbstraction, ContractProvider, Protocols, Wallet } from '@taquito/taquito';\nimport { ForbiddenInstructionInViewCode, InvalidViewParameterError, NoParameterExpectedError } from '../tzip16-errors';\nimport { View } from './interface';\n\nexport class MichelsonStorageView implements View {\n    constructor(\n        private viewName: string,\n        private contract: ContractAbstraction<ContractProvider | Wallet>,\n        private rpc: RpcClient,\n        private returnType: MichelsonV1Expression,\n        private code: MichelsonV1ExpressionExtended[],\n        private viewParameterType?: MichelsonV1ExpressionExtended\n    ) { }\n\n    /**\n     * @description According to the tzip-16 standard, the following instructions must not be used in the code of the view:\n     * 'AMOUNT', 'CREATE_CONTRACT', 'SENDER', 'SET_DELEGATE', 'SOURCE', and 'TRANSFER_TOKENS'\n     * The method throw an error if an illegal instruction is found\n     */\n    private findForbiddenInstructionInViewCode(code: MichelsonV1ExpressionExtended[]) {\n        const illegalInstructions = [\n            'AMOUNT',\n            'CREATE_CONTRACT',\n            'SENDER',\n            'SET_DELEGATE',\n            'SOURCE',\n            'TRANSFER_TOKENS'\n        ];\n\n        for (let forbiddenInstruction of illegalInstructions) {\n            for (let instruction of code) {\n                if (instruction.prim === forbiddenInstruction) {\n                    throw new ForbiddenInstructionInViewCode(forbiddenInstruction);\n                }\n                if (instruction.args && instruction.args.length !== 0) {\n                    this.findForbiddenInstructionInViewCode(instruction.args as any);\n                }\n            }\n        }\n    }\n\n    /**\n     * @description According to the tzip-16 standard, in the first version of the specification, the instruction SELF should only be used before ADDRESS\n     * The method throws an error is the instruction SELF is present, but not followed by ADDRESS\n     */\n    private illegalUseOfSelfInstruction(code: MichelsonV1ExpressionExtended[]) {\n        for (let instruction of code) {\n            if (instruction.prim === 'SELF') {\n                const index = code.indexOf(instruction);\n                const nextInstruction = code[index + 1] ? code[index + 1].prim : undefined;\n                if (nextInstruction !== 'ADDRESS') {\n                    throw new ForbiddenInstructionInViewCode('the instruction SELF should only be used before ADDRESS');\n                }\n            }\n            if (instruction.args && instruction.args.length !== 0) {\n                this.illegalUseOfSelfInstruction(instruction.args as any);\n            }\n        }\n    }\n\n    /**\n     * @description Loops through the view's code and replace SELF, BALANCE, NOW, and CHAIN_ID with Michelson expressions that match the current context, if applicable.\n     */\n    private adaptViewCodeToContext(\n        code: MichelsonV1ExpressionExtended[],\n        contractBalance: string,\n        blockTimeStamp: string,\n        chainId: string\n    ) {\n        const instructionsToReplace = {\n            SELF: [\n                { prim: 'PUSH', args: [{ prim: 'address' }, { string: this.contract.address }] },\n                { prim: 'CONTRACT', args: [{ prim: 'unit' }] },\n                { prim: 'IF_NONE', args: [[{ prim: 'UNIT' }, { prim: 'FAILWITH' }], []] }\n            ],\n            BALANCE: [{ prim: 'PUSH', args: [{ prim: 'mutez' }, { int: contractBalance }] }],\n            NOW: [{ prim: 'PUSH', args: [{ prim: 'timestamp' }, { string: blockTimeStamp }] }],\n            CHAIN_ID: [{ prim: 'PUSH', args: [{ prim: 'string' }, { string: chainId }] }]\n        };\n\n        code.forEach((x: any, i: any) => {\n            for (let instruction in instructionsToReplace) {\n                if (x.prim === instruction) {\n                    code[i] = Object(instructionsToReplace)[instruction];\n                }\n                if (x.args && x.args.length !== 0) {\n                    this.adaptViewCodeToContext(x.args, contractBalance, blockTimeStamp, chainId);\n                }\n            }\n        });\n        return code;\n    }\n\n    private validateArgs = (args: any[], schema: ParameterSchema, viewName: string) => {\n        const sigs = schema.ExtractSignatures();\n\n        if (!sigs.find((x: any[]) => x.length === args.length)) {\n            throw new InvalidViewParameterError(viewName, sigs, args);\n        }\n    };\n\n    private formatArgsAndParameter(argView: any[]) {\n        let args = argView;\n        let viewParameterType = this.viewParameterType;\n        if (!viewParameterType) {\n            viewParameterType = { args: [], prim: 'unit', annots: [] };\n        }\n\n        if (viewParameterType.prim === 'unit') {\n            if (args.length === 0) {\n                args = ['Unit'];\n            }\n            if (args.length !== 0 && args[0] !== 'Unit') {\n                throw new NoParameterExpectedError(this.viewName, argView);\n            }\n        }\n        const parameterViewSchema = new ParameterSchema(viewParameterType);\n        this.validateArgs(args, parameterViewSchema, this.viewName);\n        const arg = parameterViewSchema.Encode(...args);\n        return { arg, viewParameterType };\n    }\n\n    async executeView(...args: any[]) {\n        // validate view code against tzip-16 specifications\n        this.findForbiddenInstructionInViewCode(this.code);\n        this.illegalUseOfSelfInstruction(this.code);\n\n        const { arg, viewParameterType } = this.formatArgsAndParameter(args);\n\n        const storageType: any = this.contract.script.code.find((x: any) => x.prim === 'storage');\n        const storageArgs = storageType.args[0];\n        const storageValue: any = this.contract.script.storage;\n\n        // currentContext\n        const chainId = await this.rpc.getChainId();\n        const contractBalance = (await this.rpc.getBalance(this.contract.address)).toString();\n        const block = await this.rpc.getBlock();\n        const blockTimestamp = block.header.timestamp.toString();\n        const protocolHash = block.protocol;\n\n        const code = this.adaptViewCodeToContext(this.code, contractBalance, blockTimestamp, chainId);\n\n        if(!this.viewParameterType) {\n            code.unshift({ prim: 'CDR' })\n        }\n\n        const viewScript = {\n            script: [\n                { prim: 'parameter', args: [{ prim: 'pair', args: [viewParameterType, storageArgs] }] },\n                { prim: 'storage', args: [{ prim: 'option', args: [this.returnType] }] },\n                {\n                    prim: 'code',\n                    args: [\n                        [\n                            { prim: 'CAR' }, \n                            code,\n                            { prim: 'SOME' }, \n                            { prim: 'NIL', args: [{ prim: 'operation' }] }, \n                            { prim: 'PAIR' }\n                        ]\n                    ]\n                }\n            ],\n            storage: { prim: 'None' },\n            input: { prim: 'Pair', args: [arg, storageValue] },\n            amount: '0',\n            chain_id: chainId\n        };\n\n        // Fix for Edo which required a balance property when calling the run_code endpoint\n        if(protocolHash === Protocols.PtEdo2Zk || protocolHash === Protocols.PsFLorena) {\n            Object.assign(viewScript, { balance: '0' });\n        }\n\n        const result: any = await this.rpc.runCode(viewScript as any);\n        const viewResultSchema = new ParameterSchema(this.returnType);\n        return viewResultSchema.Execute(result.storage.args[0]);\n    }\n}\n","import { RpcClient } from '@taquito/rpc';\nimport { ContractAbstraction, ContractProvider, Wallet } from '@taquito/taquito';\nimport { ViewImplementation, ViewImplementationType } from '../metadata-interface';\nimport { MichelsonStorageView } from './michelson-storage-view';\n\nexport class ViewFactory {\n    getView(\n        viewName: string,\n        rpc: RpcClient,\n        contract: ContractAbstraction<ContractProvider | Wallet>,\n        viewImplementation: ViewImplementation\n    ) {\n        if (this.isMichelsonStorageView(viewImplementation)) {\n            const viewValues = viewImplementation[ViewImplementationType.MICHELSON_STORAGE];\n            if (!viewValues.returnType || !viewValues.code) {\n                console.warn(\n                    `${viewName} is missing mandatory code or returnType property therefore it will be skipped.`\n                );\n                return;\n            }\n            return () => {\n                const view = new MichelsonStorageView(\n                    viewName,\n                    contract,\n                    rpc,\n                    viewValues.returnType as any,\n                    viewValues.code as any,\n                    viewValues.parameter as any\n                );\n                return view;\n            };\n        }\n    }\n\n    getImplementationType(viewImplementation: ViewImplementation) {\n        return Object.keys(viewImplementation)[0];\n    }\n\n    private isMichelsonStorageView(\n        viewImplementation: ViewImplementation\n    ): viewImplementation is { [ViewImplementationType.MICHELSON_STORAGE]: any } {\n        return this.getImplementationType(viewImplementation) === ViewImplementationType.MICHELSON_STORAGE;\n    }\n}\n","import { BigMapAbstraction, Context, ContractAbstraction, ContractProvider, Wallet } from '@taquito/taquito';\nimport { bytes2Char } from '@taquito/utils';\nimport { MetadataEnvelope, MetadataProviderInterface } from './metadata-provider';\nimport { BigMapMetadataNotFound, UnconfiguredMetadataProviderError, UriNotFound } from './tzip16-errors';\nimport BigNumber from 'bignumber.js';\nimport { Schema } from '@taquito/michelson-encoder';\nimport { ViewFactory } from './viewKind/viewFactory';\nimport { View } from './viewKind/interface';\nimport { ViewDefinition } from './metadata-interface';\n\nexport type MetadataContext = Context & {\n    metadataProvider: MetadataProviderInterface;\n};\n\ntype BigMapId = { int: string };\n\nconst metadataBigMapType = {\n    prim: 'big_map',\n    args: [{ prim: 'string' }, { prim: 'bytes' }],\n    annots: ['%metadata']\n};\nexport class Tzip16ContractAbstraction {\n    private _metadataProvider: MetadataProviderInterface;\n    private _metadataEnvelope?: MetadataEnvelope;\n    private _viewFactory = new ViewFactory();\n    private _metadataViewsObject: { [key: string]: () => View } = {};\n\n    constructor(\n        private constractAbstraction: ContractAbstraction<ContractProvider | Wallet>,\n        private context: MetadataContext\n    ) {\n        this._metadataProvider = context.metadataProvider;\n    }\n\n    private findMetadataBigMap(): BigMapAbstraction {\n        const metadataBigMapId = this.constractAbstraction.schema.FindFirstInTopLevelPair<BigMapId>(\n            this.constractAbstraction.script.storage,\n            metadataBigMapType\n        );\n\n        if (!metadataBigMapId) {\n            throw new BigMapMetadataNotFound();\n        }\n\n        return new BigMapAbstraction(\n            new BigNumber(metadataBigMapId['int']),\n            new Schema(metadataBigMapType),\n            this.context.contract\n        );\n    }\n\n    private async getUriOrFail() {\n        const metadataBigMap = this.findMetadataBigMap();\n        const uri = await metadataBigMap.get<string>('');\n        if (!uri) {\n            throw new UriNotFound();\n        }\n        return uri;\n    }\n\n    /**\n     * @description Return an object containing the metadata, the uri, an optional integrity check result and an optional sha256 hash\n     */\n    async getMetadata() {\n        if (!this._metadataProvider) {\n            throw new UnconfiguredMetadataProviderError();\n        }\n        if (!this._metadataEnvelope) {\n            const uri = await this.getUriOrFail();\n            this._metadataEnvelope = await this._metadataProvider.provideMetadata(\n                this.constractAbstraction,\n                bytes2Char(uri),\n                this.context\n            );\n        }\n        return this._metadataEnvelope;\n    }\n\n    async metadataViews() {\n        if (Object.keys(this._metadataViewsObject).length === 0) {\n            await this.initializeMetadataViewsList();\n        }\n        return this._metadataViewsObject;\n    }\n\n    private async initializeMetadataViewsList() {\n        const { metadata } = await this.getMetadata();\n        const metadataViews: any = {};\n        metadata.views?.forEach((view) => this.createViewImplementations(view, metadataViews))\n        this._metadataViewsObject = metadataViews;\n    }\n\n    private generateIndexedViewName(viewName: string, metadataViews: {}) {\n        let i = 1;\n        if (viewName in metadataViews) {\n            while (`${viewName}${i}` in metadataViews) {\n                i++;\n            }\n            viewName = `${viewName}${i}`;\n        }\n        return viewName;\n    }\n\n    private createViewImplementations(view: ViewDefinition, metadataViews: any) {\n        for (let viewImplementation of view?.implementations ?? []) {\n            if (view.name) {\n                // when views have the same name, add an index at the end of the name\n                const viewName = this.generateIndexedViewName(view.name, metadataViews);\n                const metadataView = this._viewFactory.getView(\n                    viewName,\n                    this.context.rpc,\n                    this.constractAbstraction,\n                    viewImplementation\n                );\n                if (metadataView) {\n                    metadataViews[viewName] = metadataView;\n                } else {\n                    console.warn(`Skipped generating ${viewName} because the view has an unsupported type: ${this._viewFactory.getImplementationType(viewImplementation)}`)\n                }\n            }\n        }\n    }\n}\n","import { Context, ContractAbstraction, ContractProvider, Wallet } from \"@taquito/taquito\";\nimport { MetadataContext, Tzip16ContractAbstraction } from './tzip16-contract-abstraction'\n\nconst ABSTRACTION_KEY = Symbol(\"Tzip16ContractAbstractionObjectKey\");\n\nexport function tzip16<T extends ContractAbstraction<ContractProvider | Wallet>>(abs: T, context: Context) {\n    return Object.assign(abs, {\n        // namespace tzip16\n        tzip16 (this: ContractAbstraction<ContractProvider | Wallet> & { [ABSTRACTION_KEY]?: Tzip16ContractAbstraction}) {\n            if (!this[ABSTRACTION_KEY]) {\n                this[ABSTRACTION_KEY] = new Tzip16ContractAbstraction(this, context as MetadataContext);\n            }\n            \n            return this[ABSTRACTION_KEY]!\n        }\n    })\n}","import CryptoJS from \"crypto-js\";\n\nexport function calculateSHA256Hash(preimage: string): string {\n    return CryptoJS.SHA256(preimage).toString(CryptoJS.enc.Hex);\n}","import { ContractAbstraction, ContractProvider, Wallet, Context } from '@taquito/taquito';\nimport { MetadataInterface } from './metadata-interface';\nimport { MetadataContext } from './tzip16-contract-abstraction';\nimport { InvalidMetadata, InvalidUri, ProtocolNotSupported } from './tzip16-errors';\nimport { calculateSHA256Hash } from './tzip16-utils';\n\nexport interface MetadataProviderInterface {\n    provideMetadata(contractAbstraction: ContractAbstraction<ContractProvider | Wallet>, uri: string, context: MetadataContext): Promise<MetadataEnvelope>;\n}\n\nexport interface MetadataEnvelope {\n    uri: string;\n    integrityCheckResult?: boolean;\n    sha256Hash?: string;\n    metadata: MetadataInterface;\n}\nexport interface Handler {\n    getMetadata(\n        contractAbstraction: ContractAbstraction<ContractProvider | Wallet>,\n        uri: Tzip16Uri,\n        context: Context\n    ): Promise<string>\n}\n\nexport interface Tzip16Uri {\n    sha256hash: string | undefined;\n    protocol: string;\n    location: string;\n}\n\n/**\n * @description: Metadata Provider\n */\nexport class MetadataProvider implements MetadataProviderInterface {\n    private readonly PROTOCOL_REGEX = /(?:sha256\\:\\/\\/0x(.*)\\/)?(https?|ipfs|tezos-storage)\\:(.*)/;\n\n    constructor(private handlers: Map<string, Handler>) {}\n\n    /**\n     * @description Fetch the metadata by using the appropriate handler based on the protcol found in the URI\n     * @returns an object which contains the uri, the metadata, an optional integrity check result and an optional SHA256 hash\n     * @param _contractAbstraction the contract abstraction which contains the URI in its storage\n     * @param _uri the decoded uri found in the storage\n     * @param context the TezosToolkit Context\n     */\n    async provideMetadata(contractAbstraction: ContractAbstraction<ContractProvider | Wallet>, uri: string, context: Context): Promise<MetadataEnvelope> {\n\n        const uriInfo = this.extractProtocolInfo(uri);\n        if (!uriInfo || !uriInfo.location) {\n            throw new InvalidUri(uri);\n        }\n\n        const handler = this.handlers.get(uriInfo.protocol);\n        if (!handler) {\n            throw new ProtocolNotSupported(uriInfo.protocol);\n        }\n\n        const metadata = await handler.getMetadata(contractAbstraction, uriInfo, context);\n        const sha256Hash = calculateSHA256Hash(metadata);\n        let metadataJSON;\n        try {\n            metadataJSON = JSON.parse(metadata);\n        } catch (ex) {\n            throw new InvalidMetadata(metadata);\n        }\n\n        return {\n            uri,\n            metadata: metadataJSON,\n            integrityCheckResult: uriInfo.sha256hash ? uriInfo.sha256hash === sha256Hash : undefined,\n            sha256Hash: uriInfo.sha256hash ? sha256Hash : undefined\n        }\n    }\n\n    private extractProtocolInfo(_uri: string) {\n        const extractor = this.PROTOCOL_REGEX.exec(_uri);\n        if (!extractor) return;\n        return {\n            sha256hash: extractor[1],\n            protocol: extractor[2],\n            location: extractor[3]\n        }\n    }\n}\n","import { Context, Extension } from \"@taquito/taquito\";\nimport { Handler, MetadataProvider, MetadataProviderInterface } from \"./metadata-provider\";\nimport { HttpHandler } from \"./handlers/http-handler\";\nimport { TezosStorageHandler } from \"./handlers/tezos-storage-handler\";\nimport { IpfsHttpHandler } from \"./handlers/ipfs-handler\";\n\nexport const DEFAULT_HANDLERS = new Map<string, Handler>([\n    ['http', new HttpHandler()],\n    ['https', new HttpHandler()],\n    ['tezos-storage', new TezosStorageHandler()],\n    ['ipfs', new IpfsHttpHandler()]\n])\nexport class Tzip16Module implements Extension {\n    private _metadataProvider: MetadataProviderInterface;\n\n    constructor(metadataProvider?: MetadataProviderInterface) {\n        this._metadataProvider = metadataProvider ? metadataProvider : new MetadataProvider(DEFAULT_HANDLERS);\n    }\n\n    configureContext(context: Context) {\n        Object.assign(context, { metadataProvider: this._metadataProvider });\n    }\n}","\n// IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!\n/* tslint:disable */\nexport const VERSION = {\n    \"commitHash\": \"334454ed1f3717affb11a943e271fe2a6330a0c5\",\n    \"version\": \"9.0.1\"\n};\n/* tslint:enable */\n"]},"metadata":{},"sourceType":"module"}