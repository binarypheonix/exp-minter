{"ast":null,"code":"import _regeneratorRuntime from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _classCallCheck from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { StorageKey, P2PTransport, TransportStatus } from '..';\nimport { Logger } from '../utils/Logger';\nvar logger = new Logger('DappP2PTransport');\n/**\n * @internalapi\n *\n *\n */\n\nexport var DappP2PTransport = /*#__PURE__*/function (_P2PTransport) {\n  _inherits(DappP2PTransport, _P2PTransport);\n\n  var _super = _createSuper(DappP2PTransport);\n\n  function DappP2PTransport(name, keyPair, storage, matrixNodes, iconUrl, appUrl) {\n    _classCallCheck(this, DappP2PTransport);\n\n    return _super.call(this, name, keyPair, storage, matrixNodes, StorageKey.TRANSPORT_P2P_PEERS_DAPP, iconUrl, appUrl);\n  }\n\n  _createClass(DappP2PTransport, [{\n    key: \"startOpenChannelListener\",\n    value: function startOpenChannelListener() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _this = this;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", this.client.listenForChannelOpening(function (peer) {\n                  return __awaiter(_this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                    return _regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            logger.log('listenForNewPeer', \"new publicKey\", peer.publicKey);\n                            _context.next = 3;\n                            return this.addPeer(peer);\n\n                          case 3:\n                            this._isConnected = TransportStatus.CONNECTED;\n\n                            if (this.newPeerListener) {\n                              this.newPeerListener(peer);\n                              this.newPeerListener = undefined; // TODO: Remove this once we use the id\n                            }\n\n                          case 5:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee, this);\n                  }));\n                }));\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n  }, {\n    key: \"listenForNewPeer\",\n    value: function listenForNewPeer(newPeerListener) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                logger.log('listenForNewPeer');\n                this.newPeerListener = newPeerListener;\n\n              case 2:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n  }, {\n    key: \"stopListeningForNewPeers\",\n    value: function stopListeningForNewPeers() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                logger.log('stopListeningForNewPeers');\n                this.newPeerListener = undefined;\n\n              case 2:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n  }]);\n\n  return DappP2PTransport;\n}(P2PTransport);","map":{"version":3,"sources":["../../../src/transports/DappP2PTransport.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,SAAkB,UAAlB,EAA8B,YAA9B,EAA4C,eAA5C,QAAmE,IAAnE;AAEA,SAAS,MAAT,QAAuB,iBAAvB;AAEA,IAAM,MAAM,GAAG,IAAI,MAAJ,CAAW,kBAAX,CAAf;AAEA;;;;AAIG;;AACH,WAAa,gBAAb;AAAA;;AAAA;;AAIE,4BACE,IADF,EAEE,OAFF,EAGE,OAHF,EAIE,WAJF,EAKE,OALF,EAME,MANF,EAMiB;AAAA;;AAAA,6BAET,IAFS,EAEH,OAFG,EAEM,OAFN,EAEe,WAFf,EAE4B,UAAU,CAAC,wBAFvC,EAEiE,OAFjE,EAE0E,MAF1E;AAGhB;;AAbH;AAAA;AAAA,WAee,oCAAwB;;;;;;;;kDAC5B,KAAK,MAAL,CAAY,uBAAZ,CAAoC,UAAO,IAAP;AAAA,yBAAe,SAAA,CAAA,KAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,wCAAA;AAAA;AAAA;AAAA;AAAA;AACxD,4BAAA,MAAM,CAAC,GAAP,CAAW,kBAAX,mBAAgD,IAAI,CAAC,SAArD;AADwD;AAGxD,mCAAM,KAAK,OAAL,CAAa,IAAb,CAAN;;AAHwD;AAKxD,iCAAK,YAAL,GAAoB,eAAe,CAAC,SAApC;;AAEA,gCAAI,KAAK,eAAT,EAA0B;AACxB,mCAAK,eAAL,CAAqB,IAArB;AACA,mCAAK,eAAL,GAAuB,SAAvB,CAFwB,CAES;AAClC;;AAVuD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAA,EAAf;AAAA,iBAApC,C;;;;;;;;;AAYR;AA5BH;AAAA;AAAA,WA8Be,0BACX,eADW,EACgD;;;;;;AAE3D,gBAAA,MAAM,CAAC,GAAP,CAAW,kBAAX;AACA,qBAAK,eAAL,GAAuB,eAAvB;;;;;;;;;AACD;AAnCH;AAAA;AAAA,WAqCe,oCAAwB;;;;;;AACnC,gBAAA,MAAM,CAAC,GAAP,CAAW,0BAAX;AACA,qBAAK,eAAL,GAAuB,SAAvB;;;;;;;;;AACD;AAxCH;;AAAA;AAAA,EAAsC,YAAtC","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { StorageKey, P2PTransport, TransportStatus } from '..';\nimport { Logger } from '../utils/Logger';\nconst logger = new Logger('DappP2PTransport');\n/**\n * @internalapi\n *\n *\n */\nexport class DappP2PTransport extends P2PTransport {\n    constructor(name, keyPair, storage, matrixNodes, iconUrl, appUrl) {\n        super(name, keyPair, storage, matrixNodes, StorageKey.TRANSPORT_P2P_PEERS_DAPP, iconUrl, appUrl);\n    }\n    startOpenChannelListener() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.client.listenForChannelOpening((peer) => __awaiter(this, void 0, void 0, function* () {\n                logger.log('listenForNewPeer', `new publicKey`, peer.publicKey);\n                yield this.addPeer(peer);\n                this._isConnected = TransportStatus.CONNECTED;\n                if (this.newPeerListener) {\n                    this.newPeerListener(peer);\n                    this.newPeerListener = undefined; // TODO: Remove this once we use the id\n                }\n            }));\n        });\n    }\n    listenForNewPeer(newPeerListener) {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.log('listenForNewPeer');\n            this.newPeerListener = newPeerListener;\n        });\n    }\n    stopListeningForNewPeers() {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.log('stopListeningForNewPeers');\n            this.newPeerListener = undefined;\n        });\n    }\n}\n//# sourceMappingURL=DappP2PTransport.js.map"]},"metadata":{},"sourceType":"module"}