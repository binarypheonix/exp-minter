{"ast":null,"code":"import _slicedToArray from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _regeneratorRuntime from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport * as bs58check from 'bs58check';\nimport * as sodium from 'libsodium-wrappers';\n/* eslint-disable prefer-arrow/prefer-arrow-functions */\n\n/**\n * Convert a value to hex\n *\n * @param value\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nexport function toHex(value) {\n  return Buffer.from(value).toString('hex');\n}\n/**\n * Get the hex hash of a value\n *\n * @param key\n */\n\nexport function getHexHash(key) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return sodium.ready;\n\n          case 2:\n            return _context.abrupt(\"return\", toHex(sodium.crypto_generichash(32, key)));\n\n          case 3:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n}\n/**\n * Get a keypair from a seed\n *\n * @param seed\n */\n\nexport function getKeypairFromSeed(seed) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return sodium.ready;\n\n          case 2:\n            return _context2.abrupt(\"return\", sodium.crypto_sign_seed_keypair(sodium.crypto_generichash(32, sodium.from_string(seed))));\n\n          case 3:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n}\n/**\n * Encrypt a message with a shared key\n *\n * @param message\n * @param sharedKey\n */\n\nexport function encryptCryptoboxPayload(message, sharedKey) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n    var nonce, combinedPayload;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return sodium.ready;\n\n          case 2:\n            nonce = Buffer.from(sodium.randombytes_buf(sodium.crypto_secretbox_NONCEBYTES));\n            combinedPayload = Buffer.concat([nonce, Buffer.from(sodium.crypto_secretbox_easy(Buffer.from(message, 'utf8'), nonce, sharedKey))]);\n            return _context3.abrupt(\"return\", toHex(combinedPayload));\n\n          case 5:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n}\n/**\n * Decrypt a message with a shared key\n *\n * @param payload\n * @param sharedKey\n */\n\nexport function decryptCryptoboxPayload(payload, sharedKey) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n    var nonce, ciphertext;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return sodium.ready;\n\n          case 2:\n            nonce = payload.slice(0, sodium.crypto_secretbox_NONCEBYTES);\n            ciphertext = payload.slice(sodium.crypto_secretbox_NONCEBYTES);\n            return _context4.abrupt(\"return\", Buffer.from(sodium.crypto_secretbox_open_easy(ciphertext, nonce, sharedKey)).toString('utf8'));\n\n          case 5:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n}\n/**\n * Encrypt a message with a public key\n *\n * @param payload\n * @param publicKey\n */\n\nexport function sealCryptobox(payload, publicKey) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n    var kxSelfPublicKey, encryptedMessage;\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _context5.next = 2;\n            return sodium.ready;\n\n          case 2:\n            kxSelfPublicKey = sodium.crypto_sign_ed25519_pk_to_curve25519(Buffer.from(publicKey)); // Secret bytes to scalar bytes\n\n            encryptedMessage = sodium.crypto_box_seal(payload, kxSelfPublicKey);\n            return _context5.abrupt(\"return\", toHex(encryptedMessage));\n\n          case 5:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n}\n/**\n * Decrypt a message with public + private key\n *\n * @param encryptedPayload\n * @param publicKey\n * @param privateKey\n */\n\nexport function openCryptobox(encryptedPayload, publicKey, privateKey) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n    var kxSelfPrivateKey, kxSelfPublicKey, decryptedMessage;\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _context6.next = 2;\n            return sodium.ready;\n\n          case 2:\n            kxSelfPrivateKey = sodium.crypto_sign_ed25519_sk_to_curve25519(Buffer.from(privateKey)); // Secret bytes to scalar bytes\n\n            kxSelfPublicKey = sodium.crypto_sign_ed25519_pk_to_curve25519(Buffer.from(publicKey)); // Secret bytes to scalar bytes\n\n            decryptedMessage = sodium.crypto_box_seal_open(encryptedPayload, kxSelfPublicKey, kxSelfPrivateKey);\n            return _context6.abrupt(\"return\", Buffer.from(decryptedMessage).toString());\n\n          case 6:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n}\n/**\n * Get an address from the public key\n *\n * @param publicKey\n */\n\nexport function getAddressFromPublicKey(publicKey) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n    var prefixes, prefix, plainPublicKey, entries, index, _entries$index, key, value, decoded, payload;\n\n    return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            _context7.next = 2;\n            return sodium.ready;\n\n          case 2:\n            prefixes = {\n              // tz1...\n              edpk: {\n                length: 54,\n                prefix: Buffer.from(new Uint8Array([6, 161, 159]))\n              },\n              // tz2...\n              sppk: {\n                length: 55,\n                prefix: Buffer.from(new Uint8Array([6, 161, 161]))\n              },\n              // tz3...\n              p2pk: {\n                length: 55,\n                prefix: Buffer.from(new Uint8Array([6, 161, 164]))\n              }\n            };\n\n            if (!(publicKey.length === 64)) {\n              _context7.next = 8;\n              break;\n            }\n\n            prefix = prefixes.edpk.prefix;\n            plainPublicKey = publicKey;\n            _context7.next = 20;\n            break;\n\n          case 8:\n            entries = Object.entries(prefixes);\n            index = 0;\n\n          case 10:\n            if (!(index < entries.length)) {\n              _context7.next = 20;\n              break;\n            }\n\n            _entries$index = _slicedToArray(entries[index], 2), key = _entries$index[0], value = _entries$index[1];\n\n            if (!(publicKey.startsWith(key) && publicKey.length === value.length)) {\n              _context7.next = 17;\n              break;\n            }\n\n            prefix = value.prefix;\n            decoded = bs58check.decode(publicKey);\n            plainPublicKey = decoded.slice(key.length, decoded.length).toString('hex');\n            return _context7.abrupt(\"break\", 20);\n\n          case 17:\n            index++;\n            _context7.next = 10;\n            break;\n\n          case 20:\n            if (!(!prefix || !plainPublicKey)) {\n              _context7.next = 22;\n              break;\n            }\n\n            throw new Error(\"invalid publicKey: \".concat(publicKey));\n\n          case 22:\n            payload = sodium.crypto_generichash(20, Buffer.from(plainPublicKey, 'hex'));\n            return _context7.abrupt(\"return\", bs58check.encode(Buffer.concat([prefix, Buffer.from(payload)])));\n\n          case 24:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n}\n/**\n * Get the recipient string used in the matrix message\n *\n * @param recipientHash\n * @param relayServer\n */\n\nexport function recipientString(recipientHash, relayServer) {\n  return \"@\".concat(recipientHash, \":\").concat(relayServer);\n}\n/* eslint-enable prefer-arrow/prefer-arrow-functions */","map":{"version":3,"sources":["../../../src/utils/crypto.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as bs58check from 'bs58check';\nimport * as sodium from 'libsodium-wrappers';\n/* eslint-disable prefer-arrow/prefer-arrow-functions */\n/**\n * Convert a value to hex\n *\n * @param value\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function toHex(value) {\n    return Buffer.from(value).toString('hex');\n}\n/**\n * Get the hex hash of a value\n *\n * @param key\n */\nexport function getHexHash(key) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield sodium.ready;\n        return toHex(sodium.crypto_generichash(32, key));\n    });\n}\n/**\n * Get a keypair from a seed\n *\n * @param seed\n */\nexport function getKeypairFromSeed(seed) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield sodium.ready;\n        return sodium.crypto_sign_seed_keypair(sodium.crypto_generichash(32, sodium.from_string(seed)));\n    });\n}\n/**\n * Encrypt a message with a shared key\n *\n * @param message\n * @param sharedKey\n */\nexport function encryptCryptoboxPayload(message, sharedKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield sodium.ready;\n        const nonce = Buffer.from(sodium.randombytes_buf(sodium.crypto_secretbox_NONCEBYTES));\n        const combinedPayload = Buffer.concat([\n            nonce,\n            Buffer.from(sodium.crypto_secretbox_easy(Buffer.from(message, 'utf8'), nonce, sharedKey))\n        ]);\n        return toHex(combinedPayload);\n    });\n}\n/**\n * Decrypt a message with a shared key\n *\n * @param payload\n * @param sharedKey\n */\nexport function decryptCryptoboxPayload(payload, sharedKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield sodium.ready;\n        const nonce = payload.slice(0, sodium.crypto_secretbox_NONCEBYTES);\n        const ciphertext = payload.slice(sodium.crypto_secretbox_NONCEBYTES);\n        return Buffer.from(sodium.crypto_secretbox_open_easy(ciphertext, nonce, sharedKey)).toString('utf8');\n    });\n}\n/**\n * Encrypt a message with a public key\n *\n * @param payload\n * @param publicKey\n */\nexport function sealCryptobox(payload, publicKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield sodium.ready;\n        const kxSelfPublicKey = sodium.crypto_sign_ed25519_pk_to_curve25519(Buffer.from(publicKey)); // Secret bytes to scalar bytes\n        const encryptedMessage = sodium.crypto_box_seal(payload, kxSelfPublicKey);\n        return toHex(encryptedMessage);\n    });\n}\n/**\n * Decrypt a message with public + private key\n *\n * @param encryptedPayload\n * @param publicKey\n * @param privateKey\n */\nexport function openCryptobox(encryptedPayload, publicKey, privateKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield sodium.ready;\n        const kxSelfPrivateKey = sodium.crypto_sign_ed25519_sk_to_curve25519(Buffer.from(privateKey)); // Secret bytes to scalar bytes\n        const kxSelfPublicKey = sodium.crypto_sign_ed25519_pk_to_curve25519(Buffer.from(publicKey)); // Secret bytes to scalar bytes\n        const decryptedMessage = sodium.crypto_box_seal_open(encryptedPayload, kxSelfPublicKey, kxSelfPrivateKey);\n        return Buffer.from(decryptedMessage).toString();\n    });\n}\n/**\n * Get an address from the public key\n *\n * @param publicKey\n */\nexport function getAddressFromPublicKey(publicKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield sodium.ready;\n        const prefixes = {\n            // tz1...\n            edpk: {\n                length: 54,\n                prefix: Buffer.from(new Uint8Array([6, 161, 159]))\n            },\n            // tz2...\n            sppk: {\n                length: 55,\n                prefix: Buffer.from(new Uint8Array([6, 161, 161]))\n            },\n            // tz3...\n            p2pk: {\n                length: 55,\n                prefix: Buffer.from(new Uint8Array([6, 161, 164]))\n            }\n        };\n        let prefix;\n        let plainPublicKey;\n        if (publicKey.length === 64) {\n            prefix = prefixes.edpk.prefix;\n            plainPublicKey = publicKey;\n        }\n        else {\n            const entries = Object.entries(prefixes);\n            for (let index = 0; index < entries.length; index++) {\n                const [key, value] = entries[index];\n                if (publicKey.startsWith(key) && publicKey.length === value.length) {\n                    prefix = value.prefix;\n                    const decoded = bs58check.decode(publicKey);\n                    plainPublicKey = decoded.slice(key.length, decoded.length).toString('hex');\n                    break;\n                }\n            }\n        }\n        if (!prefix || !plainPublicKey) {\n            throw new Error(`invalid publicKey: ${publicKey}`);\n        }\n        const payload = sodium.crypto_generichash(20, Buffer.from(plainPublicKey, 'hex'));\n        return bs58check.encode(Buffer.concat([prefix, Buffer.from(payload)]));\n    });\n}\n/**\n * Get the recipient string used in the matrix message\n *\n * @param recipientHash\n * @param relayServer\n */\nexport function recipientString(recipientHash, relayServer) {\n    return `@${recipientHash}:${relayServer}`;\n}\n/* eslint-enable prefer-arrow/prefer-arrow-functions */\n//# sourceMappingURL=crypto.js.map"]},"metadata":{},"sourceType":"module"}