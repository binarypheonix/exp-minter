{"ast":null,"code":"import { createAsyncThunk } from '@reduxjs/toolkit';\nimport { getNftAssetContract, getContractNfts, getMarketplaceNfts, getWalletNftAssetContracts, loadMarketplaceNft, getNftAssetContracts } from '../../lib/nfts/queries';\nimport { ErrorKind } from './errors';\nexport const getNftAssetContractQuery = createAsyncThunk('query/getNftAssetContract', async (address, api) => {\n  const {\n    getState,\n    rejectWithValue\n  } = api;\n  const {\n    system\n  } = getState();\n\n  try {\n    return await getNftAssetContract(system, address);\n  } catch (e) {\n    return rejectWithValue({\n      kind: ErrorKind.GetNftAssetContractFailed,\n      message: `Failed to retrieve asset contract: ${address}`\n    });\n  }\n});\nexport const getContractNftsQuery = createAsyncThunk('query/getContractNfts', async (address, {\n  getState,\n  rejectWithValue\n}) => {\n  const {\n    system,\n    collections\n  } = getState();\n\n  try {\n    const tokens = await getContractNfts(system, address);\n    return {\n      address,\n      tokens\n    };\n  } catch (e) {\n    var _collections$collecti, _collections$collecti2, _collections$collecti3;\n\n    return rejectWithValue({\n      kind: ErrorKind.GetContractNftsFailed,\n      message: `Failed to retrieve contract nfts from: ${(_collections$collecti = (_collections$collecti2 = collections.collections[address]) === null || _collections$collecti2 === void 0 ? void 0 : (_collections$collecti3 = _collections$collecti2.metadata) === null || _collections$collecti3 === void 0 ? void 0 : _collections$collecti3.name) !== null && _collections$collecti !== void 0 ? _collections$collecti : address}`\n    });\n  }\n});\nexport const getWalletAssetContractsQuery = createAsyncThunk('query/getWalletNftAssetContracts', async (_, {\n  getState,\n  rejectWithValue\n}) => {\n  const {\n    system\n  } = getState();\n\n  if (system.status !== 'WalletConnected') {\n    return rejectWithValue({\n      kind: ErrorKind.WalletNotConnected,\n      message: \"Could not retrieve wallet's asset contracts: no wallet connected\"\n    });\n  }\n\n  try {\n    return await getWalletNftAssetContracts(system);\n  } catch (e) {\n    console.log(e);\n    return rejectWithValue({\n      kind: ErrorKind.GetWalletNftAssetContractsFailed,\n      message: \"Failed to retrieve wallet's asset contracts\"\n    });\n  }\n});\nexport const getAssetContractsQuery = createAsyncThunk('query/getNftAssetContracts', async (address, {\n  getState,\n  rejectWithValue\n}) => {\n  const {\n    system\n  } = getState();\n\n  if (system.status !== 'WalletConnected') {\n    return rejectWithValue({\n      kind: ErrorKind.WalletNotConnected,\n      message: \"Could not retrieve wallet's asset contracts: no wallet connected\"\n    });\n  }\n\n  try {\n    return await getNftAssetContracts(system, address);\n  } catch (e) {\n    console.log(e);\n    return rejectWithValue({\n      kind: ErrorKind.GetNftAssetContractsFailed,\n      message: \"Failed to retrieve asset contracts\"\n    });\n  }\n});\nexport const getMarketplaceNftsQuery = createAsyncThunk('query/getMarketplaceNfts', async (address, {\n  getState,\n  rejectWithValue\n}) => {\n  const {\n    system\n  } = getState();\n\n  try {\n    const tokens = await getMarketplaceNfts(system, address); // Load 9 initially (1-feature + at least 2 rows)\n\n    for (const i in tokens.slice(0, 9)) {\n      tokens[i] = await loadMarketplaceNft(system, tokens[i]);\n    }\n\n    return {\n      tokens\n    };\n  } catch (e) {\n    return rejectWithValue({\n      kind: ErrorKind.GetMarketplaceNftsFailed,\n      message: `Failed to retrieve marketplace nfts from: ${address}`\n    });\n  }\n});\nexport const loadMoreMarketplaceNftsQuery = createAsyncThunk('query/loadMoreMarketplaceNftsQuery', async (_, {\n  getState,\n  rejectWithValue\n}) => {\n  const {\n    system,\n    marketplace\n  } = getState();\n\n  try {\n    var _marketplace$marketpl;\n\n    const tokens = (_marketplace$marketpl = marketplace.marketplace.tokens) !== null && _marketplace$marketpl !== void 0 ? _marketplace$marketpl : []; // Load 8 more (at least 2 rows)\n\n    const iStart = tokens.findIndex(x => !x.loaded);\n    const iEnd = iStart + 8; // Need to rebuild the array\n\n    const tokensAfter = await Promise.all(tokens.map(async (x, i) => i >= iStart && i < iEnd ? await loadMarketplaceNft(system, x) : x));\n    return {\n      tokens: tokensAfter\n    };\n  } catch (e) {\n    return rejectWithValue({\n      kind: ErrorKind.GetMarketplaceNftsFailed,\n      message: `Failed to load marketplace nfts`\n    });\n  }\n});","map":{"version":3,"sources":["/Users/frankenstein/projects/minter/src/reducer/async/queries.ts"],"names":["createAsyncThunk","getNftAssetContract","getContractNfts","getMarketplaceNfts","getWalletNftAssetContracts","loadMarketplaceNft","getNftAssetContracts","ErrorKind","getNftAssetContractQuery","address","api","getState","rejectWithValue","system","e","kind","GetNftAssetContractFailed","message","getContractNftsQuery","collections","tokens","GetContractNftsFailed","metadata","name","getWalletAssetContractsQuery","_","status","WalletNotConnected","console","log","GetWalletNftAssetContractsFailed","getAssetContractsQuery","GetNftAssetContractsFailed","getMarketplaceNftsQuery","i","slice","GetMarketplaceNftsFailed","loadMoreMarketplaceNftsQuery","marketplace","iStart","findIndex","x","loaded","iEnd","tokensAfter","Promise","all","map"],"mappings":"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","sourcesContent":["import { createAsyncThunk } from '@reduxjs/toolkit';\nimport { State } from '../index';\nimport {\n  getNftAssetContract,\n  getContractNfts,\n  getMarketplaceNfts,\n  getWalletNftAssetContracts,\n  MarketplaceNftLoadingData,\n  loadMarketplaceNft,\n  getNftAssetContracts\n} from '../../lib/nfts/queries';\nimport { Nft, AssetContract } from '../../lib/nfts/decoders';\nimport { ErrorKind, RejectValue } from './errors';\n\ntype Opts = { state: State; rejectValue: RejectValue };\n\nexport const getNftAssetContractQuery = createAsyncThunk<\n  AssetContract,\n  string,\n  Opts\n>('query/getNftAssetContract', async (address, api) => {\n  const { getState, rejectWithValue } = api;\n  const { system } = getState();\n  try {\n    return await getNftAssetContract(system, address);\n  } catch (e) {\n    return rejectWithValue({\n      kind: ErrorKind.GetNftAssetContractFailed,\n      message: `Failed to retrieve asset contract: ${address}`\n    });\n  }\n});\n\nexport const getContractNftsQuery = createAsyncThunk<\n  { address: string; tokens: Nft[] },\n  string,\n  Opts\n>('query/getContractNfts', async (address, { getState, rejectWithValue }) => {\n  const { system, collections } = getState();\n  try {\n    const tokens = await getContractNfts(system, address);\n    return { address, tokens };\n  } catch (e) {\n    return rejectWithValue({\n      kind: ErrorKind.GetContractNftsFailed,\n      message: `Failed to retrieve contract nfts from: ${\n        collections.collections[address]?.metadata?.name ?? address\n      }`\n    });\n  }\n});\n\nexport const getWalletAssetContractsQuery = createAsyncThunk<\n  AssetContract[],\n  undefined,\n  Opts\n>(\n  'query/getWalletNftAssetContracts',\n  async (_, { getState, rejectWithValue }) => {\n    const { system } = getState();\n    if (system.status !== 'WalletConnected') {\n      return rejectWithValue({\n        kind: ErrorKind.WalletNotConnected,\n        message:\n          \"Could not retrieve wallet's asset contracts: no wallet connected\"\n      });\n    }\n    try {\n      return await getWalletNftAssetContracts(system);\n    } catch (e) {\n      console.log(e);\n      return rejectWithValue({\n        kind: ErrorKind.GetWalletNftAssetContractsFailed,\n        message: \"Failed to retrieve wallet's asset contracts\"\n      });\n    }\n  }\n);\n\nexport const getAssetContractsQuery = createAsyncThunk<\n  AssetContract[],\n  string,\n  Opts\n>(\n  'query/getNftAssetContracts',\n  async (address, { getState, rejectWithValue }) => {\n    const { system } = getState();\n    if (system.status !== 'WalletConnected') {\n      return rejectWithValue({\n        kind: ErrorKind.WalletNotConnected,\n        message:\n          \"Could not retrieve wallet's asset contracts: no wallet connected\"\n      });\n    }\n    try {\n      return await getNftAssetContracts(system, address);\n    } catch (e) {\n      console.log(e);\n      return rejectWithValue({\n        kind: ErrorKind.GetNftAssetContractsFailed,\n        message: \"Failed to retrieve asset contracts\"\n      });\n    }\n  }\n);\n\nexport const getMarketplaceNftsQuery = createAsyncThunk<\n  { tokens: MarketplaceNftLoadingData[] },\n  string,\n  Opts\n>(\n  'query/getMarketplaceNfts',\n  async (address, { getState, rejectWithValue }) => {\n    const { system } = getState();\n    try {\n      const tokens = await getMarketplaceNfts(system, address);\n\n      // Load 9 initially (1-feature + at least 2 rows)\n      for (const i in tokens.slice(0, 9)) {\n        tokens[i] = await loadMarketplaceNft(system, tokens[i]);\n      }\n\n      return { tokens };\n    } catch (e) {\n      return rejectWithValue({\n        kind: ErrorKind.GetMarketplaceNftsFailed,\n        message: `Failed to retrieve marketplace nfts from: ${address}`\n      });\n    }\n  }\n);\n\nexport const loadMoreMarketplaceNftsQuery = createAsyncThunk<\n  { tokens: MarketplaceNftLoadingData[] },\n  {},\n  Opts\n>(\n  'query/loadMoreMarketplaceNftsQuery',\n  async (_, { getState, rejectWithValue }) => {\n    const { system, marketplace } = getState();\n    try {\n      const tokens = marketplace.marketplace.tokens ?? [];\n\n      // Load 8 more (at least 2 rows)\n      const iStart = tokens.findIndex(x => !x.loaded);\n      const iEnd = iStart + 8;\n\n      // Need to rebuild the array\n      const tokensAfter = await Promise.all(\n        tokens.map(async (x, i) =>\n          i >= iStart && i < iEnd ? await loadMarketplaceNft(system, x) : x\n        )\n      );\n\n      return { tokens: tokensAfter };\n    } catch (e) {\n      return rejectWithValue({\n        kind: ErrorKind.GetMarketplaceNftsFailed,\n        message: `Failed to load marketplace nfts`\n      });\n    }\n  }\n);\n"]},"metadata":{},"sourceType":"module"}