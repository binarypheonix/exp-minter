{"ast":null,"code":"/**\n * The `Applicative` type class extends the `Apply` type class with a `of` function, which can be used to create values\n * of type `f a` from values of type `a`.\n *\n * Where `Apply` provides the ability to lift functions of two or more arguments to functions whose arguments are\n * wrapped using `f`, and `Functor` provides the ability to lift functions of one argument, `pure` can be seen as the\n * function which lifts functions of _zero_ arguments. That is, `Applicative` functors support a lifting operation for\n * any number of function arguments.\n *\n * Instances must satisfy the following laws in addition to the `Apply` laws:\n *\n * 1. Identity: `A.ap(A.of(a => a), fa) <-> fa`\n * 2. Homomorphism: `A.ap(A.of(ab), A.of(a)) <-> A.of(ab(a))`\n * 3. Interchange: `A.ap(fab, A.of(a)) <-> A.ap(A.of(ab => ab(a)), fab)`\n *\n * Note. `Functor`'s `map` can be derived: `A.map(x, f) = A.ap(A.of(f), x)`\n *\n * @since 2.0.0\n */\nimport { ap, getApplySemigroup } from './Apply';\nimport { pipe } from './function';\nimport { getFunctorComposition } from './Functor';\nexport function getApplicativeMonoid(F) {\n  var f = getApplySemigroup(F);\n  return function (M) {\n    return {\n      concat: f(M).concat,\n      empty: F.of(M.empty)\n    };\n  };\n}\n/** @deprecated */\n\nexport function getApplicativeComposition(F, G) {\n  var map = getFunctorComposition(F, G).map;\n\n  var _ap = ap(F, G);\n\n  return {\n    map: map,\n    of: function (a) {\n      return F.of(G.of(a));\n    },\n    ap: function (fgab, fga) {\n      return pipe(fgab, _ap(fga));\n    }\n  };\n}","map":{"version":3,"sources":["/Users/frankenstein/projects/minter/node_modules/fp-ts/es6/Applicative.js"],"names":["ap","getApplySemigroup","pipe","getFunctorComposition","getApplicativeMonoid","F","f","M","concat","empty","of","getApplicativeComposition","G","map","_ap","a","fgab","fga"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,EAAT,EAAaC,iBAAb,QAAsC,SAAtC;AACA,SAASC,IAAT,QAAqB,YAArB;AACA,SAASC,qBAAT,QAAsC,WAAtC;AACA,OAAO,SAASC,oBAAT,CAA8BC,CAA9B,EAAiC;AACpC,MAAIC,CAAC,GAAGL,iBAAiB,CAACI,CAAD,CAAzB;AACA,SAAO,UAAUE,CAAV,EAAa;AAAE,WAAQ;AAC1BC,MAAAA,MAAM,EAAEF,CAAC,CAACC,CAAD,CAAD,CAAKC,MADa;AAE1BC,MAAAA,KAAK,EAAEJ,CAAC,CAACK,EAAF,CAAKH,CAAC,CAACE,KAAP;AAFmB,KAAR;AAGjB,GAHL;AAIH;AACD;;AACA,OAAO,SAASE,yBAAT,CAAmCN,CAAnC,EAAsCO,CAAtC,EAAyC;AAC5C,MAAIC,GAAG,GAAGV,qBAAqB,CAACE,CAAD,EAAIO,CAAJ,CAArB,CAA4BC,GAAtC;;AACA,MAAIC,GAAG,GAAGd,EAAE,CAACK,CAAD,EAAIO,CAAJ,CAAZ;;AACA,SAAO;AACHC,IAAAA,GAAG,EAAEA,GADF;AAEHH,IAAAA,EAAE,EAAE,UAAUK,CAAV,EAAa;AAAE,aAAOV,CAAC,CAACK,EAAF,CAAKE,CAAC,CAACF,EAAF,CAAKK,CAAL,CAAL,CAAP;AAAuB,KAFvC;AAGHf,IAAAA,EAAE,EAAE,UAAUgB,IAAV,EAAgBC,GAAhB,EAAqB;AAAE,aAAOf,IAAI,CAACc,IAAD,EAAOF,GAAG,CAACG,GAAD,CAAV,CAAX;AAA8B;AAHtD,GAAP;AAKH","sourcesContent":["/**\n * The `Applicative` type class extends the `Apply` type class with a `of` function, which can be used to create values\n * of type `f a` from values of type `a`.\n *\n * Where `Apply` provides the ability to lift functions of two or more arguments to functions whose arguments are\n * wrapped using `f`, and `Functor` provides the ability to lift functions of one argument, `pure` can be seen as the\n * function which lifts functions of _zero_ arguments. That is, `Applicative` functors support a lifting operation for\n * any number of function arguments.\n *\n * Instances must satisfy the following laws in addition to the `Apply` laws:\n *\n * 1. Identity: `A.ap(A.of(a => a), fa) <-> fa`\n * 2. Homomorphism: `A.ap(A.of(ab), A.of(a)) <-> A.of(ab(a))`\n * 3. Interchange: `A.ap(fab, A.of(a)) <-> A.ap(A.of(ab => ab(a)), fab)`\n *\n * Note. `Functor`'s `map` can be derived: `A.map(x, f) = A.ap(A.of(f), x)`\n *\n * @since 2.0.0\n */\nimport { ap, getApplySemigroup } from './Apply';\nimport { pipe } from './function';\nimport { getFunctorComposition } from './Functor';\nexport function getApplicativeMonoid(F) {\n    var f = getApplySemigroup(F);\n    return function (M) { return ({\n        concat: f(M).concat,\n        empty: F.of(M.empty)\n    }); };\n}\n/** @deprecated */\nexport function getApplicativeComposition(F, G) {\n    var map = getFunctorComposition(F, G).map;\n    var _ap = ap(F, G);\n    return {\n        map: map,\n        of: function (a) { return F.of(G.of(a)); },\n        ap: function (fgab, fga) { return pipe(fgab, _ap(fga)); }\n    };\n}\n"]},"metadata":{},"sourceType":"module"}