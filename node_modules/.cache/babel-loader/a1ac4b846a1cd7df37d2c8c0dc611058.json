{"ast":null,"code":"import _slicedToArray from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _regeneratorRuntime from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _classCallCheck from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { keys } from '../utils/utils';\nimport { MatrixRoom, MatrixRoomStatus } from './models/MatrixRoom';\nimport { StorageKey } from '..';\nvar PRESERVED_FIELDS = ['syncToken', 'rooms'];\n/**\n * The class managing the local state of matrix\n */\n\nexport var MatrixClientStore = /*#__PURE__*/function () {\n  function MatrixClientStore(storage) {\n    var _this = this;\n\n    _classCallCheck(this, MatrixClientStore);\n\n    this.storage = storage;\n    /**\n     * The state of the matrix client\n     */\n\n    this.state = {\n      isRunning: false,\n      userId: undefined,\n      deviceId: undefined,\n      txnNo: 0,\n      accessToken: undefined,\n      syncToken: undefined,\n      pollingTimeout: undefined,\n      pollingRetries: 0,\n      rooms: {}\n    };\n    /**\n     * Listeners that will be called when the state changes\n     */\n\n    this.onStateChangedListeners = new Map();\n    /**\n     * A promise that resolves once the client is ready\n     */\n\n    this.waitReadyPromise = new Promise(function (resolve, reject) {\n      return __awaiter(_this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                _context.next = 3;\n                return this.initFromStorage();\n\n              case 3:\n                resolve();\n                _context.next = 9;\n                break;\n\n              case 6:\n                _context.prev = 6;\n                _context.t0 = _context[\"catch\"](0);\n                reject(_context.t0);\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 6]]);\n      }));\n    });\n  }\n  /**\n   * Get an item from the state\n   *\n   * @param key\n   */\n\n\n  _createClass(MatrixClientStore, [{\n    key: \"get\",\n    value: function get(key) {\n      return this.state[key];\n    }\n    /**\n     * Get the room from an ID or room instance\n     *\n     * @param roomOrId\n     */\n\n  }, {\n    key: \"getRoom\",\n    value: function getRoom(roomOrId) {\n      var room = MatrixRoom.from(roomOrId, MatrixRoomStatus.UNKNOWN);\n      return this.state.rooms[room.id] || room;\n    }\n    /**\n     * Update the state with a partial state\n     *\n     * @param stateUpdate\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(stateUpdate) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var oldState;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.waitReady();\n\n              case 2:\n                oldState = Object.assign({}, this.state);\n                this.setState(stateUpdate);\n                this.updateStorage(stateUpdate);\n                this.notifyListeners(oldState, this.state, stateUpdate);\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n    /**\n     * Register listeners that are called once the state has changed\n     *\n     * @param listener\n     * @param subscribed\n     */\n\n  }, {\n    key: \"onStateChanged\",\n    value: function onStateChanged(listener) {\n      var _this2 = this;\n\n      for (var _len = arguments.length, subscribed = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        subscribed[_key - 1] = arguments[_key];\n      }\n\n      if (subscribed.length > 0) {\n        subscribed.forEach(function (key) {\n          _this2.onStateChangedListeners.set(key, listener);\n        });\n      } else {\n        this.onStateChangedListeners.set('all', listener);\n      }\n    }\n    /**\n     * A promise that resolves once the client is ready\n     */\n\n  }, {\n    key: \"waitReady\",\n    value: function waitReady() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", this.waitReadyPromise);\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n    /**\n     * Read state from storage\n     */\n\n  }, {\n    key: \"initFromStorage\",\n    value: function initFromStorage() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var preserved;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.storage.get(StorageKey.MATRIX_PRESERVED_STATE);\n\n              case 2:\n                preserved = _context4.sent;\n                this.setState(preserved);\n\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n    /**\n     * Prepare data before persisting it in storage\n     *\n     * @param toStore\n     */\n\n  }, {\n    key: \"prepareData\",\n    value: function prepareData(toStore) {\n      var requiresPreparation = ['rooms'];\n      var toStoreCopy = requiresPreparation.some(function (key) {\n        return toStore[key] !== undefined;\n      }) ? JSON.parse(JSON.stringify(toStore)) : toStore; // there is no need for saving messages in a persistent storage\n\n      Object.values(toStoreCopy.rooms || {}).forEach(function (room) {\n        room.messages = [];\n      });\n      return toStoreCopy;\n    }\n    /**\n     * Persist state in storage\n     *\n     * @param stateUpdate\n     */\n\n  }, {\n    key: \"updateStorage\",\n    value: function updateStorage(stateUpdate) {\n      var _this3 = this;\n\n      var updatedCachedFields = Object.entries(stateUpdate).filter(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            key = _ref2[0],\n            value = _ref2[1];\n\n        return PRESERVED_FIELDS.includes(key) && Boolean(value);\n      });\n\n      if (updatedCachedFields.length > 0) {\n        var filteredState = {};\n        PRESERVED_FIELDS.forEach(function (key) {\n          filteredState[key] = _this3.state[key];\n        });\n        this.storage.set(StorageKey.MATRIX_PRESERVED_STATE, this.prepareData(filteredState));\n      }\n    }\n    /**\n     * Set the state\n     *\n     * @param partialState\n     */\n\n  }, {\n    key: \"setState\",\n    value: function setState(partialState) {\n      this.state = {\n        isRunning: partialState.isRunning || this.state.isRunning,\n        userId: partialState.userId || this.state.userId,\n        deviceId: partialState.deviceId || this.state.deviceId,\n        txnNo: partialState.txnNo || this.state.txnNo,\n        accessToken: partialState.accessToken || this.state.accessToken,\n        syncToken: partialState.syncToken || this.state.syncToken,\n        pollingTimeout: partialState.pollingTimeout || this.state.pollingTimeout,\n        pollingRetries: partialState.pollingRetries || this.state.pollingRetries,\n        rooms: this.mergeRooms(this.state.rooms, partialState.rooms)\n      };\n    }\n    /**\n     * Merge room records and eliminate duplicates\n     *\n     * @param oldRooms\n     * @param _newRooms\n     */\n\n  }, {\n    key: \"mergeRooms\",\n    value: function mergeRooms(oldRooms, _newRooms) {\n      if (!_newRooms) {\n        return oldRooms;\n      }\n\n      var newRooms = Array.isArray(_newRooms) ? _newRooms : Object.values(_newRooms);\n      var merged = Object.assign({}, oldRooms);\n      newRooms.forEach(function (newRoom) {\n        merged[newRoom.id] = MatrixRoom.merge(newRoom, oldRooms[newRoom.id]);\n      });\n      return merged;\n    }\n    /**\n     * Notify listeners of state changes\n     *\n     * @param oldState\n     * @param newState\n     * @param stateChange\n     */\n\n  }, {\n    key: \"notifyListeners\",\n    value: function notifyListeners(oldState, newState, stateChange) {\n      var _this4 = this;\n\n      var listenForAll = this.onStateChangedListeners.get('all');\n\n      if (listenForAll) {\n        listenForAll(oldState, newState, stateChange);\n      }\n\n      keys(stateChange).filter(function (key) {\n        return stateChange[key] !== undefined;\n      }).forEach(function (key) {\n        var listener = _this4.onStateChangedListeners.get(key);\n\n        if (listener) {\n          listener(oldState, newState, stateChange);\n        }\n      });\n    }\n  }]);\n\n  return MatrixClientStore;\n}();","map":{"version":3,"sources":["../../../src/matrix-client/MatrixClientStore.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { keys } from '../utils/utils';\nimport { MatrixRoom, MatrixRoomStatus } from './models/MatrixRoom';\nimport { StorageKey } from '..';\nconst PRESERVED_FIELDS = ['syncToken', 'rooms'];\n/**\n * The class managing the local state of matrix\n */\nexport class MatrixClientStore {\n    constructor(storage) {\n        this.storage = storage;\n        /**\n         * The state of the matrix client\n         */\n        this.state = {\n            isRunning: false,\n            userId: undefined,\n            deviceId: undefined,\n            txnNo: 0,\n            accessToken: undefined,\n            syncToken: undefined,\n            pollingTimeout: undefined,\n            pollingRetries: 0,\n            rooms: {}\n        };\n        /**\n         * Listeners that will be called when the state changes\n         */\n        this.onStateChangedListeners = new Map();\n        /**\n         * A promise that resolves once the client is ready\n         */\n        this.waitReadyPromise = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield this.initFromStorage();\n                resolve();\n            }\n            catch (error) {\n                reject(error);\n            }\n        }));\n    }\n    /**\n     * Get an item from the state\n     *\n     * @param key\n     */\n    get(key) {\n        return this.state[key];\n    }\n    /**\n     * Get the room from an ID or room instance\n     *\n     * @param roomOrId\n     */\n    getRoom(roomOrId) {\n        const room = MatrixRoom.from(roomOrId, MatrixRoomStatus.UNKNOWN);\n        return this.state.rooms[room.id] || room;\n    }\n    /**\n     * Update the state with a partial state\n     *\n     * @param stateUpdate\n     */\n    update(stateUpdate) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.waitReady();\n            const oldState = Object.assign({}, this.state);\n            this.setState(stateUpdate);\n            this.updateStorage(stateUpdate);\n            this.notifyListeners(oldState, this.state, stateUpdate);\n        });\n    }\n    /**\n     * Register listeners that are called once the state has changed\n     *\n     * @param listener\n     * @param subscribed\n     */\n    onStateChanged(listener, ...subscribed) {\n        if (subscribed.length > 0) {\n            subscribed.forEach((key) => {\n                this.onStateChangedListeners.set(key, listener);\n            });\n        }\n        else {\n            this.onStateChangedListeners.set('all', listener);\n        }\n    }\n    /**\n     * A promise that resolves once the client is ready\n     */\n    waitReady() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.waitReadyPromise;\n        });\n    }\n    /**\n     * Read state from storage\n     */\n    initFromStorage() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const preserved = yield this.storage.get(StorageKey.MATRIX_PRESERVED_STATE);\n            this.setState(preserved);\n        });\n    }\n    /**\n     * Prepare data before persisting it in storage\n     *\n     * @param toStore\n     */\n    prepareData(toStore) {\n        const requiresPreparation = ['rooms'];\n        const toStoreCopy = requiresPreparation.some((key) => toStore[key] !== undefined)\n            ? JSON.parse(JSON.stringify(toStore))\n            : toStore;\n        // there is no need for saving messages in a persistent storage\n        Object.values(toStoreCopy.rooms || {}).forEach((room) => {\n            room.messages = [];\n        });\n        return toStoreCopy;\n    }\n    /**\n     * Persist state in storage\n     *\n     * @param stateUpdate\n     */\n    updateStorage(stateUpdate) {\n        const updatedCachedFields = Object.entries(stateUpdate).filter(([key, value]) => PRESERVED_FIELDS.includes(key) && Boolean(value));\n        if (updatedCachedFields.length > 0) {\n            const filteredState = {};\n            PRESERVED_FIELDS.forEach((key) => {\n                filteredState[key] = this.state[key];\n            });\n            this.storage.set(StorageKey.MATRIX_PRESERVED_STATE, this.prepareData(filteredState));\n        }\n    }\n    /**\n     * Set the state\n     *\n     * @param partialState\n     */\n    setState(partialState) {\n        this.state = {\n            isRunning: partialState.isRunning || this.state.isRunning,\n            userId: partialState.userId || this.state.userId,\n            deviceId: partialState.deviceId || this.state.deviceId,\n            txnNo: partialState.txnNo || this.state.txnNo,\n            accessToken: partialState.accessToken || this.state.accessToken,\n            syncToken: partialState.syncToken || this.state.syncToken,\n            pollingTimeout: partialState.pollingTimeout || this.state.pollingTimeout,\n            pollingRetries: partialState.pollingRetries || this.state.pollingRetries,\n            rooms: this.mergeRooms(this.state.rooms, partialState.rooms)\n        };\n    }\n    /**\n     * Merge room records and eliminate duplicates\n     *\n     * @param oldRooms\n     * @param _newRooms\n     */\n    mergeRooms(oldRooms, _newRooms) {\n        if (!_newRooms) {\n            return oldRooms;\n        }\n        const newRooms = Array.isArray(_newRooms) ? _newRooms : Object.values(_newRooms);\n        const merged = Object.assign({}, oldRooms);\n        newRooms.forEach((newRoom) => {\n            merged[newRoom.id] = MatrixRoom.merge(newRoom, oldRooms[newRoom.id]);\n        });\n        return merged;\n    }\n    /**\n     * Notify listeners of state changes\n     *\n     * @param oldState\n     * @param newState\n     * @param stateChange\n     */\n    notifyListeners(oldState, newState, stateChange) {\n        const listenForAll = this.onStateChangedListeners.get('all');\n        if (listenForAll) {\n            listenForAll(oldState, newState, stateChange);\n        }\n        keys(stateChange)\n            .filter((key) => stateChange[key] !== undefined)\n            .forEach((key) => {\n            const listener = this.onStateChangedListeners.get(key);\n            if (listener) {\n                listener(oldState, newState, stateChange);\n            }\n        });\n    }\n}\n//# sourceMappingURL=MatrixClientStore.js.map"]},"metadata":{},"sourceType":"module"}