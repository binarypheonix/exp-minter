{"ast":null,"code":"/* eslint-disable no-redeclare */\nimport { createAsyncThunk } from '@reduxjs/toolkit';\nimport { createAssetContract, mintToken, mintTokens, transferToken, listTokenForSale, cancelTokenSale, cancelTokenSaleLegacy, buyToken, buyTokenLegacy } from '../../lib/nfts/actions';\nimport { ErrorKind } from './errors';\nimport { getContractNftsQuery, getWalletAssetContractsQuery } from './queries';\nimport { validateCreateNftForm } from '../validators/createNft';\nimport { uploadIPFSFile, uploadIPFSImageWithThumbnail } from '../../lib/util/ipfs';\nimport { connectWallet } from './wallet';\nimport { NftMetadata } from '../../lib/nfts/decoders';\nimport { notifyPending, notifyFulfilled } from '../slices/notificationsActions';\nimport parse from 'csv-parse/lib/sync';\nimport * as t from 'io-ts';\nexport const readFileAsDataUrlAction = createAsyncThunk('action/readFileAsDataUrl', async ({\n  ns,\n  file\n}, {\n  rejectWithValue\n}) => {\n  const readFile = new Promise((resolve, reject) => {\n    let {\n      name,\n      type,\n      size\n    } = file;\n    const reader = new FileReader();\n\n    if (!type) {\n      if (name.substr(-4) === '.glb') {\n        type = 'model/gltf-binary';\n      }\n\n      if (name.substr(-5) === '.gltf') {\n        type = 'model/gltf+json';\n      }\n    }\n\n    reader.onload = e => {\n      var _e$target;\n\n      const buffer = (_e$target = e.target) === null || _e$target === void 0 ? void 0 : _e$target.result;\n\n      if (!buffer || !(buffer instanceof ArrayBuffer)) {\n        return reject();\n      }\n\n      const blob = new Blob([new Uint8Array(buffer)], {\n        type\n      });\n      const objectUrl = window.URL.createObjectURL(blob);\n      return resolve({\n        ns,\n        result: {\n          objectUrl,\n          name,\n          type,\n          size\n        }\n      });\n    };\n\n    reader.readAsArrayBuffer(file);\n  });\n\n  try {\n    return await readFile;\n  } catch (e) {\n    return rejectWithValue({\n      kind: ErrorKind.UnknownError,\n      message: 'Could not read file'\n    });\n  }\n});\nexport const createAssetContractAction = createAsyncThunk('action/createAssetContract', async (name, {\n  getState,\n  rejectWithValue,\n  dispatch,\n  requestId\n}) => {\n  const {\n    system\n  } = getState();\n\n  if (system.status !== 'WalletConnected') {\n    return rejectWithValue({\n      kind: ErrorKind.WalletNotConnected,\n      message: 'Cannot create collection: Wallet not connected'\n    });\n  }\n\n  try {\n    const op = await createAssetContract(system, {\n      name\n    });\n    const pendingMessage = `Creating new collection ${name}`;\n    dispatch(notifyPending(requestId, pendingMessage));\n    await op.confirmation();\n    const {\n      address\n    } = await op.contract();\n    const fulfilledMessage = `Created new collection ${name} (${address})`;\n    dispatch(notifyFulfilled(requestId, fulfilledMessage)); // TODO: Poll for contract availability on indexer\n\n    dispatch(getWalletAssetContractsQuery());\n    return {\n      name,\n      address\n    };\n  } catch (e) {\n    return rejectWithValue({\n      kind: ErrorKind.CreateAssetContractFailed,\n      message: 'Collection creation failed'\n    });\n  }\n});\n\nfunction appendAttributes(metadata, attributes) {\n  return attributes.reduce((acc, row) => {\n    var _acc$attributes;\n\n    const keys = Object.keys(NftMetadata.props);\n    const key = keys.find(k => k === row.name);\n\n    if (key && NftMetadata.props[key].decode(row.value)._tag === 'Right') {\n      return { ...acc,\n        [key]: row.value\n      };\n    }\n\n    const attribute = {\n      name: row.name,\n      value: row.value\n    };\n    return { ...acc,\n      attributes: [...((_acc$attributes = acc.attributes) !== null && _acc$attributes !== void 0 ? _acc$attributes : []), attribute]\n    };\n  }, metadata);\n}\n\nfunction appendStateMetadata(state, metadata, system) {\n  const appendedMetadata = { ...metadata,\n    name: state.fields.name,\n    minter: system.tzPublicKey || undefined,\n    description: state.fields.description || undefined,\n    attributes: []\n  };\n  return appendAttributes(appendedMetadata, state.attributes);\n}\n\nexport const mintTokenAction = createAsyncThunk('action/mintToken', async (_, {\n  getState,\n  rejectWithValue,\n  dispatch,\n  requestId\n}) => {\n  const {\n    system,\n    createNft: state\n  } = getState();\n\n  if (state.selectedFile === null) {\n    return rejectWithValue({\n      kind: ErrorKind.UnknownError,\n      message: 'Could not mint token: no file selected'\n    });\n  } else if (system.status !== 'WalletConnected') {\n    return rejectWithValue({\n      kind: ErrorKind.WalletNotConnected,\n      message: 'Could not mint token: no wallet connected'\n    });\n  } else if (!validateCreateNftForm(state)) {\n    return rejectWithValue({\n      kind: ErrorKind.CreateNftFormInvalid,\n      message: 'Could not mint token: form validation failed'\n    });\n  }\n\n  let file;\n\n  try {\n    const {\n      objectUrl,\n      name,\n      type\n    } = state.selectedFile;\n    const fetched = await fetch(objectUrl);\n    const blob = await fetched.blob();\n    file = new File([blob], name, {\n      type\n    });\n  } catch (e) {\n    return rejectWithValue({\n      kind: ErrorKind.UnknownError,\n      message: 'Could not mint token: selected file not found'\n    });\n  }\n\n  let ipfsMetadata = {};\n\n  try {\n    if (/^image\\/.*/.test(file.type)) {\n      const imageResponse = await uploadIPFSImageWithThumbnail(system.config.ipfsApi, file);\n      ipfsMetadata.artifactUri = imageResponse.data.ipfsUri;\n      ipfsMetadata.displayUri = imageResponse.data.ipfsUri;\n      ipfsMetadata.thumbnailUri = imageResponse.data.thumbnail.ipfsUri;\n      ipfsMetadata.formats = [{\n        fileSize: imageResponse.headers['content-length'],\n        mimeType: imageResponse.headers['content-type']\n      }];\n    } else if (/^video\\/.*/.test(file.type)) {\n      if (state.displayImageFile === null) {\n        return rejectWithValue({\n          kind: ErrorKind.IPFSUploadFailed,\n          message: 'Ipfs upload failed: Video display file not found'\n        });\n      }\n\n      let displayFile;\n\n      try {\n        const {\n          objectUrl,\n          name,\n          type\n        } = state.displayImageFile;\n        const fetched = await fetch(objectUrl);\n        const blob = await fetched.blob();\n        displayFile = new File([blob], name, {\n          type\n        });\n      } catch (e) {\n        return rejectWithValue({\n          kind: ErrorKind.UnknownError,\n          message: 'Could not mint token: video display file not found'\n        });\n      }\n\n      const fileResponse = await uploadIPFSFile(system.config.ipfsApi, file);\n      const imageResponse = await uploadIPFSImageWithThumbnail(system.config.ipfsApi, displayFile);\n      ipfsMetadata.artifactUri = fileResponse.data.ipfsUri;\n      ipfsMetadata.displayUri = imageResponse.data.ipfsUri;\n      ipfsMetadata.thumbnailUri = imageResponse.data.thumbnail.ipfsUri;\n      ipfsMetadata.formats = [{\n        fileSize: fileResponse.headers['content-length'],\n        mimeType: fileResponse.headers['content-type']\n      }];\n    } else {\n      const fileResponse = await uploadIPFSFile(system.config.ipfsApi, file);\n      ipfsMetadata.artifactUri = fileResponse.data.ipfsUri;\n      ipfsMetadata.formats = [{\n        fileSize: fileResponse.data.size,\n        mimeType: file.type\n      }];\n    }\n  } catch (e) {\n    return rejectWithValue({\n      kind: ErrorKind.IPFSUploadFailed,\n      message: 'IPFS upload failed'\n    });\n  }\n\n  const address = state.collectionAddress;\n  const metadata = appendStateMetadata(state, ipfsMetadata, system);\n\n  try {\n    const op = await mintToken(system, address, metadata);\n    const pendingMessage = `Minting new token: ${metadata.name}`;\n    dispatch(notifyPending(requestId, pendingMessage));\n    await op.confirmation(2);\n    const fulfilledMessage = `Created new token: ${metadata.name} in ${address}`;\n    dispatch(notifyFulfilled(requestId, fulfilledMessage));\n    dispatch(getContractNftsQuery(address));\n    return {\n      contract: address,\n      metadata\n    };\n  } catch (e) {\n    return rejectWithValue({\n      kind: ErrorKind.MintTokenFailed,\n      message: 'Mint token failed'\n    });\n  }\n});\nconst ParsedCsvRow = t.intersection([t.type({\n  name: t.string,\n  description: t.string,\n  artifactUri: t.string,\n  collection: t.string\n}), t.partial({\n  displayUri: t.string\n}), t.record(t.string, t.string)]);\nconst ParsedCsv = t.brand(t.array(ParsedCsvRow), n => n.length > 0, 'NonEmptyArray');\nexport const mintCsvTokensAction = createAsyncThunk('action/mintCsvTokens', async (_, {\n  getState,\n  rejectWithValue,\n  dispatch,\n  requestId\n}) => {\n  const {\n    system,\n    createNftCsvImport: state\n  } = getState();\n\n  if (system.status !== 'WalletConnected') {\n    return rejectWithValue({\n      kind: ErrorKind.WalletNotConnected,\n      message: 'Wallet not connected'\n    });\n  }\n\n  if (state.selectedCsvFile === null) {\n    return rejectWithValue({\n      kind: ErrorKind.UnknownError,\n      message: 'No CSV file selected'\n    });\n  }\n\n  let text;\n\n  try {\n    text = await fetch(state.selectedCsvFile.objectUrl).then(r => r.text());\n  } catch (e) {\n    return rejectWithValue({\n      kind: ErrorKind.UnknownError,\n      message: 'Could not mint tokens: selected CSV file not found'\n    });\n  }\n\n  const parsed = parse(text, {\n    columns: true,\n    skipEmptyLines: true\n  });\n\n  if (!ParsedCsv.is(parsed)) {\n    console.log('ERROR:', parsed);\n    return rejectWithValue({\n      kind: ErrorKind.UnknownError,\n      message: ''\n    });\n  }\n\n  const attrRegex = /^attribute\\./;\n  const attrRegexTest = new RegExp(attrRegex.source + '.+');\n  const metadataArray = parsed.map(p => {\n    const attributes = Object.keys(p).filter(k => attrRegexTest.test(k)).map(k => ({\n      name: k.split(attrRegex)[1],\n      value: p[k]\n    }));\n    const metadata = {\n      name: p.name,\n      minter: system.tzPublicKey,\n      description: p.description,\n      artifactUri: p.artifactUri,\n      displayUri: p.displayUri,\n      attributes: []\n    };\n    return appendAttributes(metadata, attributes);\n  });\n\n  try {\n    const address = parsed[0].collection;\n    const op = await mintTokens(system, address, metadataArray);\n    const pendingMessage = `Minting new tokens from CSV`;\n    dispatch(notifyPending(requestId, pendingMessage));\n    await op.confirmation(2);\n    const fulfilledMessage = `Created new tokens from CSV in ${address}`;\n    dispatch(notifyFulfilled(requestId, fulfilledMessage));\n    dispatch(getContractNftsQuery(address));\n  } catch (e) {\n    return rejectWithValue({\n      kind: ErrorKind.MintTokenFailed,\n      message: 'Mint tokens from CSV failed'\n    });\n  }\n\n  return null;\n});\nexport const transferTokenAction = createAsyncThunk('action/transferToken', async (args, api) => {\n  const {\n    getState,\n    rejectWithValue,\n    dispatch,\n    requestId\n  } = api;\n  const {\n    contract,\n    tokenId,\n    to\n  } = args;\n  const {\n    system\n  } = getState();\n\n  if (system.status !== 'WalletConnected') {\n    return rejectWithValue({\n      kind: ErrorKind.WalletNotConnected,\n      message: 'Could not transfer token: no wallet connected'\n    });\n  }\n\n  try {\n    const op = await transferToken(system, contract, tokenId, to);\n    dispatch(notifyPending(requestId, `Transferring token to ${to}`));\n    await op.confirmation(2);\n    dispatch(notifyFulfilled(requestId, `Transferred token to ${to}`));\n    dispatch(getContractNftsQuery(contract));\n    return args;\n  } catch (e) {\n    return rejectWithValue({\n      kind: ErrorKind.TransferTokenFailed,\n      message: 'Transfer token failed'\n    });\n  }\n});\nexport const listTokenAction = createAsyncThunk('action/listToken', async (args, api) => {\n  const {\n    getState,\n    rejectWithValue,\n    dispatch,\n    requestId\n  } = api;\n  const {\n    contract,\n    tokenId,\n    salePrice\n  } = args;\n  const {\n    system\n  } = getState();\n  const marketplaceContract = system.config.contracts.marketplace.fixedPrice.tez;\n\n  if (system.status !== 'WalletConnected') {\n    return rejectWithValue({\n      kind: ErrorKind.WalletNotConnected,\n      message: 'Could not list token: no wallet connected'\n    });\n  }\n\n  try {\n    const op = await listTokenForSale(system, marketplaceContract, contract, tokenId, salePrice, 1);\n    const pendingMessage = `Listing token for sale for ${salePrice / 1000000}ꜩ`;\n    dispatch(notifyPending(requestId, pendingMessage));\n    await op.confirmation(2);\n    const fulfilledMessage = `Token listed for sale for ${salePrice / 1000000}ꜩ`;\n    dispatch(notifyFulfilled(requestId, fulfilledMessage));\n    dispatch(getContractNftsQuery(contract));\n    return args;\n  } catch (e) {\n    console.log(e);\n    return rejectWithValue({\n      kind: ErrorKind.ListTokenFailed,\n      message: 'List token failed'\n    });\n  }\n});\nexport const cancelTokenSaleAction = createAsyncThunk('action/cancelTokenSale', async (args, api) => {\n  const {\n    getState,\n    rejectWithValue,\n    dispatch,\n    requestId\n  } = api;\n  const {\n    contract,\n    tokenId,\n    saleId,\n    saleType\n  } = args;\n  const {\n    system\n  } = getState();\n  const marketplaceContract = system.config.contracts.marketplace.fixedPrice.tez;\n\n  if (system.status !== 'WalletConnected') {\n    return rejectWithValue({\n      kind: ErrorKind.WalletNotConnected,\n      message: 'Could not list token: no wallet connected'\n    });\n  }\n\n  try {\n    let op;\n\n    if (saleType === \"fixedPriceLegacy\") {\n      op = await cancelTokenSaleLegacy(system, marketplaceContract, contract, tokenId);\n    } else {\n      op = await cancelTokenSale(system, marketplaceContract, contract, tokenId, saleId);\n    }\n\n    dispatch(notifyPending(requestId, `Canceling token sale`));\n    await op.confirmation(2);\n    dispatch(notifyFulfilled(requestId, `Token sale canceled`));\n    dispatch(getContractNftsQuery(contract));\n    return {\n      contract: contract,\n      tokenId: tokenId,\n      saleId: saleId,\n      saleType: saleType\n    };\n  } catch (e) {\n    return rejectWithValue({\n      kind: ErrorKind.CancelTokenSaleFailed,\n      message: 'Cancel token sale failed'\n    });\n  }\n});\nexport const buyTokenAction = createAsyncThunk('action/buyToken', async (args, api) => {\n  const {\n    getState,\n    rejectWithValue,\n    dispatch,\n    requestId\n  } = api;\n  const {\n    contract,\n    tokenId,\n    tokenSeller,\n    salePrice,\n    saleId,\n    saleType\n  } = args;\n  let {\n    system\n  } = getState();\n  const marketplaceContract = system.config.contracts.marketplace.fixedPrice.tez;\n\n  if (system.status !== 'WalletConnected') {\n    const res = await dispatch(connectWallet());\n\n    if (!res.payload || !('wallet' in res.payload)) {\n      return rejectWithValue({\n        kind: ErrorKind.WalletNotConnected,\n        message: 'Could not list token: no wallet connected'\n      });\n    }\n\n    system = res.payload;\n  }\n\n  try {\n    let op;\n\n    if (saleType === \"fixedPriceLegacy\") {\n      op = await buyTokenLegacy(system, marketplaceContract, contract, tokenId, tokenSeller, salePrice);\n    } else {\n      op = await buyToken(system, marketplaceContract, saleId, salePrice);\n    }\n\n    const pendingMessage = `Buying token from ${tokenSeller} for ${salePrice}`;\n    dispatch(notifyPending(requestId, pendingMessage));\n    await op.confirmation(2);\n    const fulfilledMessage = `Bought token from ${tokenSeller} for ${salePrice}`;\n    dispatch(notifyFulfilled(requestId, fulfilledMessage));\n    dispatch(getContractNftsQuery(contract));\n    return {\n      contract: contract,\n      tokenId: tokenId,\n      saleId: saleId,\n      saleType: saleType\n    };\n  } catch (e) {\n    return rejectWithValue({\n      kind: ErrorKind.BuyTokenFailed,\n      message: 'Purchase token failed'\n    });\n  }\n});","map":{"version":3,"sources":["/Users/frankenstein/projects/minter/src/reducer/async/actions.ts"],"names":["createAsyncThunk","createAssetContract","mintToken","mintTokens","transferToken","listTokenForSale","cancelTokenSale","cancelTokenSaleLegacy","buyToken","buyTokenLegacy","ErrorKind","getContractNftsQuery","getWalletAssetContractsQuery","validateCreateNftForm","uploadIPFSFile","uploadIPFSImageWithThumbnail","connectWallet","NftMetadata","notifyPending","notifyFulfilled","parse","t","readFileAsDataUrlAction","ns","file","rejectWithValue","readFile","Promise","resolve","reject","name","type","size","reader","FileReader","substr","onload","e","buffer","target","result","ArrayBuffer","blob","Blob","Uint8Array","objectUrl","window","URL","createObjectURL","readAsArrayBuffer","kind","UnknownError","message","createAssetContractAction","getState","dispatch","requestId","system","status","WalletNotConnected","op","pendingMessage","confirmation","address","contract","fulfilledMessage","CreateAssetContractFailed","appendAttributes","metadata","attributes","reduce","acc","row","keys","Object","props","key","find","k","decode","value","_tag","attribute","appendStateMetadata","state","appendedMetadata","fields","minter","tzPublicKey","undefined","description","mintTokenAction","_","createNft","selectedFile","CreateNftFormInvalid","fetched","fetch","File","ipfsMetadata","test","imageResponse","config","ipfsApi","artifactUri","data","ipfsUri","displayUri","thumbnailUri","thumbnail","formats","fileSize","headers","mimeType","displayImageFile","IPFSUploadFailed","displayFile","fileResponse","collectionAddress","MintTokenFailed","ParsedCsvRow","intersection","string","collection","partial","record","ParsedCsv","brand","array","n","length","mintCsvTokensAction","createNftCsvImport","selectedCsvFile","text","then","r","parsed","columns","skipEmptyLines","is","console","log","attrRegex","attrRegexTest","RegExp","source","metadataArray","map","p","filter","split","transferTokenAction","args","api","tokenId","to","TransferTokenFailed","listTokenAction","salePrice","marketplaceContract","contracts","marketplace","fixedPrice","tez","ListTokenFailed","cancelTokenSaleAction","saleId","saleType","CancelTokenSaleFailed","buyTokenAction","tokenSeller","res","payload","BuyTokenFailed"],"mappings":"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","sourcesContent":["/* eslint-disable no-redeclare */\nimport { createAsyncThunk } from '@reduxjs/toolkit';\nimport { State } from '..';\nimport {\n  createAssetContract,\n  mintToken,\n  mintTokens,\n  transferToken,\n  listTokenForSale,\n  cancelTokenSale,\n  cancelTokenSaleLegacy,\n  buyToken,\n  buyTokenLegacy\n} from '../../lib/nfts/actions';\nimport { ErrorKind, RejectValue } from './errors';\nimport { getContractNftsQuery, getWalletAssetContractsQuery } from './queries';\nimport { validateCreateNftForm } from '../validators/createNft';\nimport {\n  uploadIPFSFile,\n  uploadIPFSImageWithThumbnail\n} from '../../lib/util/ipfs';\nimport { SelectedFile } from '../slices/createNft';\nimport { connectWallet } from './wallet';\nimport { NftMetadata } from '../../lib/nfts/decoders';\nimport { SystemWithToolkit, SystemWithWallet } from '../../lib/system';\nimport { notifyPending, notifyFulfilled } from '../slices/notificationsActions';\nimport parse from 'csv-parse/lib/sync';\nimport * as t from 'io-ts';\n\ntype Options = {\n  state: State;\n  rejectValue: RejectValue;\n};\n\nexport const readFileAsDataUrlAction = createAsyncThunk<\n  { ns: string; result: SelectedFile },\n  { ns: string; file: File },\n  Options\n>('action/readFileAsDataUrl', async ({ ns, file }, { rejectWithValue }) => {\n  const readFile = new Promise<{ ns: string; result: SelectedFile }>(\n    (resolve, reject) => {\n      let { name, type, size } = file;\n      const reader = new FileReader();\n\n      if (!type) {\n        if (name.substr(-4) === '.glb') {\n          type = 'model/gltf-binary';\n        }\n        if (name.substr(-5) === '.gltf') {\n          type = 'model/gltf+json';\n        }\n      }\n\n      reader.onload = e => {\n        const buffer = e.target?.result;\n        if (!buffer || !(buffer instanceof ArrayBuffer)) {\n          return reject();\n        }\n        const blob = new Blob([new Uint8Array(buffer)], { type });\n        const objectUrl = window.URL.createObjectURL(blob);\n        return resolve({ ns, result: { objectUrl, name, type, size } });\n      };\n      reader.readAsArrayBuffer(file);\n    }\n  );\n  try {\n    return await readFile;\n  } catch (e) {\n    return rejectWithValue({\n      kind: ErrorKind.UnknownError,\n      message: 'Could not read file'\n    });\n  }\n});\n\nexport const createAssetContractAction = createAsyncThunk<\n  { name: string; address: string },\n  string,\n  Options\n>(\n  'action/createAssetContract',\n  async (name, { getState, rejectWithValue, dispatch, requestId }) => {\n    const { system } = getState();\n    if (system.status !== 'WalletConnected') {\n      return rejectWithValue({\n        kind: ErrorKind.WalletNotConnected,\n        message: 'Cannot create collection: Wallet not connected'\n      });\n    }\n    try {\n      const op = await createAssetContract(system, { name });\n      const pendingMessage = `Creating new collection ${name}`;\n      dispatch(notifyPending(requestId, pendingMessage));\n      await op.confirmation();\n\n      const { address } = await op.contract();\n      const fulfilledMessage = `Created new collection ${name} (${address})`;\n      dispatch(notifyFulfilled(requestId, fulfilledMessage));\n      // TODO: Poll for contract availability on indexer\n      dispatch(getWalletAssetContractsQuery());\n      return { name, address };\n    } catch (e) {\n      return rejectWithValue({\n        kind: ErrorKind.CreateAssetContractFailed,\n        message: 'Collection creation failed'\n      });\n    }\n  }\n);\n\ntype Attributes = { name: string; value: string }[];\n\nfunction appendAttributes(metadata: NftMetadata, attributes: Attributes) {\n  return attributes.reduce(\n    (acc, row) => {\n      const keys = Object.keys(NftMetadata.props);\n      const key = keys.find(k => k === row.name) as keyof NftMetadata;\n      if (key && NftMetadata.props[key].decode(row.value)._tag === 'Right') {\n        return { ...acc, [key]: row.value };\n      }\n      const attribute = { name: row.name, value: row.value };\n      return { ...acc, attributes: [...acc.attributes ?? [], attribute] };\n    }, \n    metadata\n  );\n}\n\nfunction appendStateMetadata(\n  state: State['createNft'],\n  metadata: NftMetadata,\n  system: SystemWithToolkit | SystemWithWallet\n) {\n  const appendedMetadata: NftMetadata = {\n    ...metadata,\n    name: state.fields.name as string,\n    minter: system.tzPublicKey || undefined,\n    description: state.fields.description || undefined,\n    attributes: []\n  };\n  return appendAttributes(appendedMetadata, state.attributes);\n}\n\nexport const mintTokenAction = createAsyncThunk<\n  { contract: string; metadata: ReturnType<typeof appendStateMetadata> },\n  undefined,\n  Options\n>(\n  'action/mintToken',\n  async (_, { getState, rejectWithValue, dispatch, requestId }) => {\n    const { system, createNft: state } = getState();\n    if (state.selectedFile === null) {\n      return rejectWithValue({\n        kind: ErrorKind.UnknownError,\n        message: 'Could not mint token: no file selected'\n      });\n    } else if (system.status !== 'WalletConnected') {\n      return rejectWithValue({\n        kind: ErrorKind.WalletNotConnected,\n        message: 'Could not mint token: no wallet connected'\n      });\n    } else if (!validateCreateNftForm(state)) {\n      return rejectWithValue({\n        kind: ErrorKind.CreateNftFormInvalid,\n        message: 'Could not mint token: form validation failed'\n      });\n    }\n\n    let file: File;\n    try {\n      const { objectUrl, name, type } = state.selectedFile;\n      const fetched = await fetch(objectUrl);\n      const blob = await fetched.blob();\n      file = new File([blob], name, { type });\n    } catch (e) {\n      return rejectWithValue({\n        kind: ErrorKind.UnknownError,\n        message: 'Could not mint token: selected file not found'\n      });\n    }\n\n    let ipfsMetadata: NftMetadata = {};\n    try {\n      if (/^image\\/.*/.test(file.type)) {\n        const imageResponse = await uploadIPFSImageWithThumbnail(\n          system.config.ipfsApi,\n          file\n        );\n        ipfsMetadata.artifactUri = imageResponse.data.ipfsUri;\n        ipfsMetadata.displayUri = imageResponse.data.ipfsUri;\n        ipfsMetadata.thumbnailUri = imageResponse.data.thumbnail.ipfsUri;\n        ipfsMetadata.formats = [\n          {\n            fileSize: imageResponse.headers['content-length'],\n            mimeType: imageResponse.headers['content-type']\n          }\n        ];\n      } else if (/^video\\/.*/.test(file.type)) {\n        if (state.displayImageFile === null) {\n          return rejectWithValue({\n            kind: ErrorKind.IPFSUploadFailed,\n            message: 'Ipfs upload failed: Video display file not found'\n          });\n        }\n        let displayFile: File;\n        try {\n          const { objectUrl, name, type } = state.displayImageFile;\n          const fetched = await fetch(objectUrl);\n          const blob = await fetched.blob();\n          displayFile = new File([blob], name, { type });\n        } catch (e) {\n          return rejectWithValue({\n            kind: ErrorKind.UnknownError,\n            message: 'Could not mint token: video display file not found'\n          });\n        }\n        const fileResponse = await uploadIPFSFile(system.config.ipfsApi, file);\n        const imageResponse = await uploadIPFSImageWithThumbnail(\n          system.config.ipfsApi,\n          displayFile\n        );\n        ipfsMetadata.artifactUri = fileResponse.data.ipfsUri;\n        ipfsMetadata.displayUri = imageResponse.data.ipfsUri;\n        ipfsMetadata.thumbnailUri = imageResponse.data.thumbnail.ipfsUri;\n        ipfsMetadata.formats = [\n          {\n            fileSize: fileResponse.headers['content-length'],\n            mimeType: fileResponse.headers['content-type']\n          }\n        ];\n      } else {\n        const fileResponse = await uploadIPFSFile(system.config.ipfsApi, file);\n        ipfsMetadata.artifactUri = fileResponse.data.ipfsUri;\n        ipfsMetadata.formats = [\n          {\n            fileSize: fileResponse.data.size,\n            mimeType: file.type\n          }\n        ];\n      }\n    } catch (e) {\n      return rejectWithValue({\n        kind: ErrorKind.IPFSUploadFailed,\n        message: 'IPFS upload failed'\n      });\n    }\n\n    const address = state.collectionAddress as string;\n    const metadata = appendStateMetadata(state, ipfsMetadata, system);\n\n    try {\n      const op = await mintToken(system, address, metadata);\n      const pendingMessage = `Minting new token: ${metadata.name}`;\n      dispatch(notifyPending(requestId, pendingMessage));\n      await op.confirmation(2);\n\n      const fulfilledMessage = `Created new token: ${metadata.name} in ${address}`;\n      dispatch(notifyFulfilled(requestId, fulfilledMessage));\n      dispatch(getContractNftsQuery(address));\n      return { contract: address, metadata };\n    } catch (e) {\n      return rejectWithValue({\n        kind: ErrorKind.MintTokenFailed,\n        message: 'Mint token failed'\n      });\n    }\n  }\n);\n\ninterface NonEmptyArrayBrand {\n  readonly NonEmptyArray: unique symbol;\n}\n\ntype ParsedCsvRow = t.TypeOf<typeof ParsedCsvRow>;\nconst ParsedCsvRow = t.intersection([\n  t.type({\n    name: t.string,\n    description: t.string,\n    artifactUri: t.string,\n    collection: t.string\n  }),\n  t.partial({\n    displayUri: t.string\n  }),\n  t.record(t.string, t.string)\n]);\n\nconst ParsedCsv = t.brand(\n  t.array(ParsedCsvRow),\n  (n): n is t.Branded<Array<ParsedCsvRow>, NonEmptyArrayBrand> => n.length > 0,\n  'NonEmptyArray'\n);\n\nexport const mintCsvTokensAction = createAsyncThunk<null, undefined, Options>(\n  'action/mintCsvTokens',\n  async (_, { getState, rejectWithValue, dispatch, requestId }) => {\n    const { system, createNftCsvImport: state } = getState();\n    if (system.status !== 'WalletConnected') {\n      return rejectWithValue({\n        kind: ErrorKind.WalletNotConnected,\n        message: 'Wallet not connected'\n      });\n    }\n    if (state.selectedCsvFile === null) {\n      return rejectWithValue({\n        kind: ErrorKind.UnknownError,\n        message: 'No CSV file selected'\n      });\n    }\n\n    let text: string;\n    try {\n      text = await fetch(state.selectedCsvFile.objectUrl).then(r => r.text());\n    } catch (e) {\n      return rejectWithValue({\n        kind: ErrorKind.UnknownError,\n        message: 'Could not mint tokens: selected CSV file not found'\n      });\n    }\n    const parsed = parse(text, { columns: true, skipEmptyLines: true });\n    if (!ParsedCsv.is(parsed)) {\n      console.log('ERROR:', parsed);\n      return rejectWithValue({\n        kind: ErrorKind.UnknownError,\n        message: ''\n      });\n    }\n    const attrRegex = /^attribute\\./;\n    const attrRegexTest = new RegExp(attrRegex.source + '.+');\n    const metadataArray = parsed.map(p => {\n      const attributes = Object.keys(p)\n        .filter(k => attrRegexTest.test(k))\n        .map(k => ({\n          name: k.split(attrRegex)[1],\n          value: p[k]\n        }));\n      const metadata: NftMetadata = {\n        name: p.name,\n        minter: system.tzPublicKey,\n        description: p.description,\n        artifactUri: p.artifactUri,\n        displayUri: p.displayUri,\n        attributes: [],\n      };\n      return appendAttributes(metadata, attributes);\n    });\n\n    try {\n      const address = parsed[0].collection;\n      const op = await mintTokens(system, address, metadataArray);\n      const pendingMessage = `Minting new tokens from CSV`;\n      dispatch(notifyPending(requestId, pendingMessage));\n      await op.confirmation(2);\n\n      const fulfilledMessage = `Created new tokens from CSV in ${address}`;\n      dispatch(notifyFulfilled(requestId, fulfilledMessage));\n      dispatch(getContractNftsQuery(address));\n    } catch (e) {\n      return rejectWithValue({\n        kind: ErrorKind.MintTokenFailed,\n        message: 'Mint tokens from CSV failed'\n      });\n    }\n\n    return null;\n  }\n);\n\nexport const transferTokenAction = createAsyncThunk<\n  { contract: string; tokenId: number; to: string },\n  { contract: string; tokenId: number; to: string },\n  Options\n>('action/transferToken', async (args, api) => {\n  const { getState, rejectWithValue, dispatch, requestId } = api;\n  const { contract, tokenId, to } = args;\n  const { system } = getState();\n  if (system.status !== 'WalletConnected') {\n    return rejectWithValue({\n      kind: ErrorKind.WalletNotConnected,\n      message: 'Could not transfer token: no wallet connected'\n    });\n  }\n  try {\n    const op = await transferToken(system, contract, tokenId, to);\n    dispatch(notifyPending(requestId, `Transferring token to ${to}`));\n    await op.confirmation(2);\n\n    dispatch(notifyFulfilled(requestId, `Transferred token to ${to}`));\n    dispatch(getContractNftsQuery(contract));\n    return args;\n  } catch (e) {\n    return rejectWithValue({\n      kind: ErrorKind.TransferTokenFailed,\n      message: 'Transfer token failed'\n    });\n  }\n});\n\nexport const listTokenAction = createAsyncThunk<\n  { contract: string; tokenId: number; salePrice: number },\n  { contract: string; tokenId: number; salePrice: number },\n  Options\n>('action/listToken', async (args, api) => {\n  const { getState, rejectWithValue, dispatch, requestId } = api;\n  const { contract, tokenId, salePrice } = args;\n  const { system } = getState();\n  const marketplaceContract =\n    system.config.contracts.marketplace.fixedPrice.tez;\n  if (system.status !== 'WalletConnected') {\n    return rejectWithValue({\n      kind: ErrorKind.WalletNotConnected,\n      message: 'Could not list token: no wallet connected'\n    });\n  }\n  try {\n    const op = await listTokenForSale(\n      system,\n      marketplaceContract,\n      contract,\n      tokenId,\n      salePrice,\n      1\n    );\n    const pendingMessage = `Listing token for sale for ${salePrice / 1000000}ꜩ`;\n    dispatch(notifyPending(requestId, pendingMessage));\n    await op.confirmation(2);\n\n    const fulfilledMessage = `Token listed for sale for ${\n      salePrice / 1000000\n    }ꜩ`;\n    dispatch(notifyFulfilled(requestId, fulfilledMessage));\n    dispatch(getContractNftsQuery(contract));\n    return args;\n  } catch (e) {\n      console.log(e);\n    return rejectWithValue({\n      kind: ErrorKind.ListTokenFailed,\n      message: 'List token failed'\n    });\n  }\n});\n\nexport const cancelTokenSaleAction = createAsyncThunk<\n  { contract: string; tokenId: number; saleId: number; saleType: string },\n  { contract: string; tokenId: number; saleId: number; saleType: string },\n  Options\n>('action/cancelTokenSale', async (args, api) => {\n  const { getState, rejectWithValue, dispatch, requestId } = api;\n  const { contract, tokenId, saleId, saleType } = args;\n  const { system } = getState();\n  const marketplaceContract =\n    system.config.contracts.marketplace.fixedPrice.tez;\n  if (system.status !== 'WalletConnected') {\n    return rejectWithValue({\n      kind: ErrorKind.WalletNotConnected,\n      message: 'Could not list token: no wallet connected'\n    });\n  }\n  try {\n    let op;\n    if (saleType === \"fixedPriceLegacy\") {\n      op = await cancelTokenSaleLegacy(\n        system,\n        marketplaceContract,\n        contract,\n        tokenId\n      );\n    } else {\n      op = await cancelTokenSale(\n        system,\n        marketplaceContract,\n        contract,\n        tokenId,\n        saleId\n      );\n    }\n\n    dispatch(notifyPending(requestId, `Canceling token sale`));\n    await op.confirmation(2);\n\n    dispatch(notifyFulfilled(requestId, `Token sale canceled`));\n    dispatch(getContractNftsQuery(contract));\n    return { contract: contract, tokenId: tokenId, saleId: saleId, saleType: saleType };\n  } catch (e) {\n    return rejectWithValue({\n      kind: ErrorKind.CancelTokenSaleFailed,\n      message: 'Cancel token sale failed'\n    });\n  }\n});\n\nexport const buyTokenAction = createAsyncThunk<\n  { contract: string; tokenId: number; saleId: number; saleType: string },\n  { contract: string; tokenId: number; tokenSeller: string; salePrice: number; saleId: number; saleType: string },\n  Options\n>('action/buyToken', async (args, api) => {\n  const { getState, rejectWithValue, dispatch, requestId } = api;\n  const { contract, tokenId, tokenSeller, salePrice, saleId, saleType } = args;\n  let { system } = getState();\n  const marketplaceContract =\n    system.config.contracts.marketplace.fixedPrice.tez;\n  if (system.status !== 'WalletConnected') {\n    const res = await dispatch(connectWallet());\n    if (!res.payload || !('wallet' in res.payload)) {\n      return rejectWithValue({\n        kind: ErrorKind.WalletNotConnected,\n        message: 'Could not list token: no wallet connected'\n      });\n    }\n    system = res.payload;\n  }\n  try {\n    let op;\n    if (saleType === \"fixedPriceLegacy\") {\n      op = await buyTokenLegacy(\n        system,\n        marketplaceContract,\n        contract,\n        tokenId,\n        tokenSeller,\n        salePrice\n      );\n    } else {\n      op = await buyToken(\n        system,\n        marketplaceContract,\n        saleId,\n        salePrice\n      );\n    }\n    const pendingMessage = `Buying token from ${tokenSeller} for ${salePrice}`;\n    dispatch(notifyPending(requestId, pendingMessage));\n    await op.confirmation(2);\n\n    const fulfilledMessage = `Bought token from ${tokenSeller} for ${salePrice}`;\n    dispatch(notifyFulfilled(requestId, fulfilledMessage));\n    dispatch(getContractNftsQuery(contract));\n    return { contract: contract, tokenId: tokenId, saleId: saleId, saleType: saleType };\n  } catch (e) {\n    return rejectWithValue({\n      kind: ErrorKind.BuyTokenFailed,\n      message: 'Purchase token failed'\n    });\n  }\n});\n"]},"metadata":{},"sourceType":"module"}