{"ast":null,"code":"/* eslint-disable no-redeclare */\nimport { Buffer } from 'buffer';\nimport * as t from 'io-ts';\nimport _ from 'lodash';\nimport { isLeft } from 'fp-ts/lib/Either';\nimport { compact } from 'fp-ts/lib/Array';\nimport { getRight } from 'fp-ts/lib/Option';\nimport * as D from './decoders';\n\nfunction fromHexString(input) {\n  if (/^([A-Fa-f0-9]{2})*$/.test(input)) {\n    return Buffer.from(input, 'hex').toString();\n  }\n\n  return input;\n} //// Data retrieval and decoding functions\n\n\nasync function getAssetMetadataBigMap(tzkt, address) {\n  const path = 'metadata';\n  const data = await tzkt.getContractBigMapKeys(address, path);\n  const decoded = D.LedgerBigMap.decode(data);\n\n  if (isLeft(decoded)) {\n    throw Error('Failed to decode `getAssetMetadata` response');\n  }\n\n  return decoded.right;\n}\n\nasync function getLedgerBigMap(tzkt, address) {\n  const path = 'assets.ledger';\n  const data = await tzkt.getContractBigMapKeys(address, path);\n  const decoded = D.LedgerBigMap.decode(data);\n\n  if (isLeft(decoded)) {\n    throw Error('Failed to decode `getLedger` response');\n  }\n\n  return decoded.right;\n}\n\nasync function getTokenMetadataBigMap(tzkt, address) {\n  const path = 'assets.token_metadata';\n  const data = await tzkt.getContractBigMapKeys(address, path);\n  const decoded = D.TokenMetadataBigMap.decode(data);\n\n  if (isLeft(decoded)) {\n    throw Error('Failed to decode `getTokenMetadata` response');\n  }\n\n  return decoded.right;\n}\n\nasync function getFixedPriceSalesBigMap(tzkt, address) {\n  const fixedPriceStorage = D.FixedPriceSaleStorage.decode(await tzkt.getContractStorage(address));\n\n  if (isLeft(fixedPriceStorage)) {\n    throw Error('Failed to decode `getFixedPriceSales` bigMap ID');\n  }\n\n  const fixedPriceBigMapId = fixedPriceStorage.right.sales;\n  const fixedPriceSales = await tzkt.getBigMapKeys(fixedPriceBigMapId);\n  const decoded = D.FixedPriceSaleBigMap.decode(fixedPriceSales);\n\n  if (isLeft(decoded)) {\n    throw Error('Failed to decode `getFixedPriceSales` response');\n  }\n\n  return decoded.right;\n}\n\nasync function getBigMapUpdates(tzkt, params, content) {\n  const bigMapUpdates = await tzkt.getBigMapUpdates(params);\n  const decoder = t.array(D.BigMapUpdateRow(content));\n  const decoded = decoder.decode(bigMapUpdates);\n\n  if (isLeft(decoded)) {\n    throw Error('Failed to decode `getBigMapUpdates` response');\n  }\n\n  return decoded.right;\n}\n\nasync function getContracts(tzkt, params, storage) {\n  const contracts = await tzkt.getContracts(params);\n  const contractsArray = t.array(t.unknown).decode(contracts);\n\n  if (isLeft(contractsArray)) {\n    throw Error('Failed to decode `getContracts` response');\n  }\n\n  const decodedArray = contractsArray.right.map(D.ContractRow(storage).decode);\n  return compact(decodedArray.map(getRight));\n}\n\nasync function getContract(tzkt, address, params, storage) {\n  const contract = await tzkt.getContract(address, params);\n  const decoded = D.ContractRow(storage).decode(contract);\n\n  if (isLeft(decoded)) {\n    throw Error('Failed to decode `getContracts` response');\n  }\n\n  return decoded.right;\n} //// Main query functions\n\n\nexport async function getContractNfts(system, address) {\n  const ledger = await getLedgerBigMap(system.tzkt, address);\n  const tokens = await getTokenMetadataBigMap(system.tzkt, address);\n  const mktAddress = system.config.contracts.marketplace.fixedPrice.tez;\n  const tokenSales = await getFixedPriceSalesBigMap(system.tzkt, mktAddress);\n  const activeSales = tokenSales.filter(sale => sale.active); // Sort by token id - descending\n\n  const tokensSorted = [...tokens].sort((a, b) => -(Number.parseInt(a.value.token_id, 10) - Number.parseInt(b.value.token_id, 10)));\n  return Promise.all(tokensSorted.map(async token => {\n    var _ledger$find;\n\n    const {\n      token_id: tokenId,\n      token_info: tokenInfo\n    } = token.value; // TODO: Write decoder function for data retrieval\n\n    const decodedInfo = _.mapValues(tokenInfo, fromHexString);\n\n    const resolvedInfo = await system.resolveMetadata(decodedInfo[''], address);\n    const metadata = { ...decodedInfo,\n      ...resolvedInfo.metadata\n    };\n    const saleData = activeSales.find(v => v.value.sale_data.sale_token.fa2_address === address && v.value.sale_data.sale_token.token_id === tokenId);\n    const sale = saleData && {\n      id: saleData.id,\n      seller: saleData.value.seller,\n      price: Number.parseInt(saleData.value.sale_data.price, 10) / 1000000,\n      mutez: Number.parseInt(saleData.value.sale_data.price, 10),\n      saleToken: {\n        address: saleData.value.sale_data.sale_token.fa2_address,\n        tokenId: Number.parseInt(saleData.value.sale_data.sale_token.token_id)\n      },\n      saleId: saleData.value.isLegacy ? 0 : Number.parseInt(saleData.key),\n      type: saleData.value.isLegacy ? 'fixedPriceLegacy' : 'fixedPrice'\n    };\n    return {\n      id: parseInt(tokenId, 10),\n      owner: (_ledger$find = ledger.find(e => e.key === tokenId)) === null || _ledger$find === void 0 ? void 0 : _ledger$find.value,\n      title: metadata.name,\n      description: metadata.description,\n      artifactUri: metadata.artifactUri,\n      metadata: metadata,\n      sale\n    };\n  }));\n}\nexport async function getNftAssetContract(system, address) {\n  var _metaBigMap$find;\n\n  const contract = await getContract(system.tzkt, address, {}, t.unknown);\n  const metaBigMap = await getAssetMetadataBigMap(system.tzkt, address);\n  const metaUri = (_metaBigMap$find = metaBigMap.find(v => v.key === '')) === null || _metaBigMap$find === void 0 ? void 0 : _metaBigMap$find.value;\n\n  if (!metaUri) {\n    throw Error(`Could not extract metadata URI from ${address} storage`);\n  }\n\n  const {\n    metadata\n  } = await system.resolveMetadata(fromHexString(metaUri), address);\n  const decoded = D.AssetContractMetadata.decode(metadata);\n\n  if (isLeft(decoded)) {\n    throw Error('Metadata validation failed');\n  }\n\n  return { ...contract,\n    metadata: decoded.right\n  };\n}\nexport async function getWalletNftAssetContracts(system) {\n  return await getNftAssetContracts(system, system.tzPublicKey);\n}\n;\nexport async function getNftAssetContracts(system, tzPublicKey) {\n  const contracts = await getContracts(system.tzkt, {\n    creator: tzPublicKey,\n    includeStorage: 'true'\n  }, t.unknown);\n\n  const addresses = _.uniq(contracts.filter(c => {\n    var _c$tzips;\n\n    return c.kind === 'asset' && ((_c$tzips = c.tzips) === null || _c$tzips === void 0 ? void 0 : _c$tzips.includes('fa2'));\n  }).map(c => c.address));\n\n  const results = [];\n\n  if (addresses.length === 0) {\n    return results;\n  }\n\n  const assetBigMapRows = (await getBigMapUpdates(system.tzkt, {\n    path: 'metadata',\n    action: 'add_key',\n    'contract.in': addresses.join(','),\n    limit: '10000'\n  }, {\n    key: t.string,\n    value: t.string\n  })).filter(v => v.content.key === '');\n\n  for (const row of assetBigMapRows) {\n    const contract = contracts.find(c => c.address === row.contract.address);\n\n    if (!contract) {\n      continue;\n    }\n\n    try {\n      const metaUri = row.content.value;\n      const {\n        metadata\n      } = await system.resolveMetadata(fromHexString(metaUri), contract.address);\n      const decoded = D.AssetContractMetadata.decode(metadata);\n\n      if (!isLeft(decoded)) {\n        results.push({ ...contract,\n          metadata: decoded.right\n        });\n      }\n    } catch (e) {\n      console.log(e);\n    }\n  }\n\n  return results;\n}\nexport async function getMarketplaceNfts(system, address) {\n  const tokenSales = await getFixedPriceSalesBigMap(system.tzkt, address);\n  const activeSales = tokenSales.filter(v => v.active);\n\n  const addresses = _.uniq(activeSales.map(s => s.value.sale_data.sale_token.fa2_address));\n\n  const uniqueAddresses = Array.from(new Set(addresses));\n\n  if (uniqueAddresses.length === 0) {\n    return [];\n  }\n\n  const tokenBigMapRows = await getBigMapUpdates(system.tzkt, {\n    path: 'assets.token_metadata',\n    action: 'add_key',\n    'contract.in': addresses.join(','),\n    limit: '10000'\n  }, {\n    key: t.string,\n    value: t.type({\n      token_id: t.string,\n      token_info: t.record(t.string, t.string)\n    })\n  }); // Sort descending (newest first)\n\n  const salesToView = [...activeSales].reverse();\n  const salesWithTokenMetadata = salesToView.map(x => ({\n    tokenSale: x,\n    tokenItem: tokenBigMapRows.find(item => x.value.sale_data.sale_token.fa2_address === item.contract.address && x.value.sale_data.sale_token.token_id === item.content.value.token_id + '')\n  })).map(x => {\n    var _x$tokenItem, _x$tokenItem$content, _x$tokenItem$content$;\n\n    return {\n      loaded: false,\n      token: null,\n      tokenSale: x.tokenSale,\n      tokenMetadata: (_x$tokenItem = x.tokenItem) === null || _x$tokenItem === void 0 ? void 0 : (_x$tokenItem$content = _x$tokenItem.content) === null || _x$tokenItem$content === void 0 ? void 0 : (_x$tokenItem$content$ = _x$tokenItem$content.value) === null || _x$tokenItem$content$ === void 0 ? void 0 : _x$tokenItem$content$.token_info['']\n    };\n  });\n  return salesWithTokenMetadata;\n}\nexport const loadMarketplaceNft = async (system, tokenLoadData) => {\n  const {\n    token,\n    loaded,\n    tokenSale,\n    tokenMetadata\n  } = tokenLoadData;\n  const result = { ...tokenLoadData\n  };\n\n  if (token || loaded) {\n    return result;\n  }\n\n  result.loaded = true;\n\n  try {\n    const {\n      fa2_address: saleAddress,\n      token_id: tokenIdStr\n    } = tokenSale.value.sale_data.sale_token;\n    const tokenId = parseInt(tokenIdStr, 10);\n    const mutez = Number.parseInt(tokenSale.value.sale_data.price, 10);\n    const sale = {\n      id: tokenSale.id,\n      seller: tokenSale.value.seller,\n      price: mutez / 1000000,\n      mutez: mutez,\n      saleToken: {\n        address: tokenSale.value.sale_data.sale_token.fa2_address,\n        tokenId: Number.parseInt(tokenSale.value.sale_data.sale_token.token_id)\n      },\n      saleId: tokenSale.value.isLegacy ? 0 : Number.parseInt(tokenSale.key),\n      type: tokenSale.value.isLegacy ? 'fixedPriceLegacy' : 'fixedPrice'\n    };\n\n    if (!tokenMetadata) {\n      result.error = \"Couldn't retrieve tokenMetadata\";\n      console.error(\"Couldn't retrieve tokenMetadata\", {\n        tokenSale\n      });\n      return result;\n    }\n\n    const {\n      metadata\n    } = await system.resolveMetadata(fromHexString(tokenMetadata), saleAddress);\n    result.token = {\n      address: saleAddress,\n      id: tokenId,\n      title: metadata.name || '',\n      owner: sale.seller,\n      description: metadata.description || '',\n      artifactUri: metadata.artifactUri || '',\n      metadata: metadata,\n      sale: sale\n    };\n    return result;\n  } catch (err) {\n    result.error = \"Couldn't load token\";\n    console.error(\"Couldn't load token\", {\n      tokenSale,\n      err\n    });\n    return result;\n  }\n};","map":{"version":3,"sources":["/Users/frankenstein/projects/minter/src/lib/nfts/queries.ts"],"names":["Buffer","t","_","isLeft","compact","getRight","D","fromHexString","input","test","from","toString","getAssetMetadataBigMap","tzkt","address","path","data","getContractBigMapKeys","decoded","LedgerBigMap","decode","Error","right","getLedgerBigMap","getTokenMetadataBigMap","TokenMetadataBigMap","getFixedPriceSalesBigMap","fixedPriceStorage","FixedPriceSaleStorage","getContractStorage","fixedPriceBigMapId","sales","fixedPriceSales","getBigMapKeys","FixedPriceSaleBigMap","getBigMapUpdates","params","content","bigMapUpdates","decoder","array","BigMapUpdateRow","getContracts","storage","contracts","contractsArray","unknown","decodedArray","map","ContractRow","getContract","contract","getContractNfts","system","ledger","tokens","mktAddress","config","marketplace","fixedPrice","tez","tokenSales","activeSales","filter","sale","active","tokensSorted","sort","a","b","Number","parseInt","value","token_id","Promise","all","token","tokenId","token_info","tokenInfo","decodedInfo","mapValues","resolvedInfo","resolveMetadata","metadata","saleData","find","v","sale_data","sale_token","fa2_address","id","seller","price","mutez","saleToken","saleId","isLegacy","key","type","owner","e","title","name","description","artifactUri","getNftAssetContract","metaBigMap","metaUri","AssetContractMetadata","getWalletNftAssetContracts","getNftAssetContracts","tzPublicKey","creator","includeStorage","addresses","uniq","c","kind","tzips","includes","results","length","assetBigMapRows","action","join","limit","string","row","push","console","log","getMarketplaceNfts","s","uniqueAddresses","Array","Set","tokenBigMapRows","record","salesToView","reverse","salesWithTokenMetadata","x","tokenSale","tokenItem","item","loaded","tokenMetadata","loadMarketplaceNft","tokenLoadData","result","saleAddress","tokenIdStr","error","err"],"mappings":"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","sourcesContent":["/* eslint-disable no-redeclare */\nimport { Buffer } from 'buffer';\nimport * as t from 'io-ts';\nimport _ from 'lodash';\nimport { SystemWithToolkit, SystemWithWallet } from '../system';\nimport { TzKt, Params } from '../service/tzkt';\nimport { isLeft } from 'fp-ts/lib/Either';\nimport { compact } from 'fp-ts/lib/Array';\nimport { getRight } from 'fp-ts/lib/Option';\nimport * as D from './decoders';\n\nfunction fromHexString(input: string) {\n  if (/^([A-Fa-f0-9]{2})*$/.test(input)) {\n    return Buffer.from(input, 'hex').toString();\n  }\n  return input;\n}\n\n//// Data retrieval and decoding functions\n\nasync function getAssetMetadataBigMap(\n  tzkt: TzKt,\n  address: string\n): Promise<D.AssetMetadataBigMap> {\n  const path = 'metadata';\n  const data = await tzkt.getContractBigMapKeys(address, path);\n  const decoded = D.LedgerBigMap.decode(data);\n  if (isLeft(decoded)) {\n    throw Error('Failed to decode `getAssetMetadata` response');\n  }\n  return decoded.right;\n}\n\nasync function getLedgerBigMap(\n  tzkt: TzKt,\n  address: string\n): Promise<D.LedgerBigMap> {\n  const path = 'assets.ledger';\n  const data = await tzkt.getContractBigMapKeys(address, path);\n  const decoded = D.LedgerBigMap.decode(data);\n  if (isLeft(decoded)) {\n    throw Error('Failed to decode `getLedger` response');\n  }\n  return decoded.right;\n}\n\nasync function getTokenMetadataBigMap(\n  tzkt: TzKt,\n  address: string\n): Promise<D.TokenMetadataBigMap> {\n  const path = 'assets.token_metadata';\n  const data = await tzkt.getContractBigMapKeys(address, path);\n  const decoded = D.TokenMetadataBigMap.decode(data);\n  if (isLeft(decoded)) {\n    throw Error('Failed to decode `getTokenMetadata` response');\n  }\n  return decoded.right;\n}\n\nasync function getFixedPriceSalesBigMap(\n  tzkt: TzKt,\n  address: string\n): Promise<D.FixedPriceSaleBigMap> {\n  const fixedPriceStorage = D.FixedPriceSaleStorage.decode(\n    await tzkt.getContractStorage(address)\n  );\n  if (isLeft(fixedPriceStorage)) {\n    throw Error('Failed to decode `getFixedPriceSales` bigMap ID');\n  }\n  const fixedPriceBigMapId = fixedPriceStorage.right.sales;\n  const fixedPriceSales = await tzkt.getBigMapKeys(fixedPriceBigMapId);\n  const decoded = D.FixedPriceSaleBigMap.decode(fixedPriceSales);\n  if (isLeft(decoded)) {\n    throw Error('Failed to decode `getFixedPriceSales` response');\n  }\n  return decoded.right;\n}\n\nasync function getBigMapUpdates<K extends t.Mixed, V extends t.Mixed>(\n  tzkt: TzKt,\n  params: Params,\n  content: { key: K; value: V }\n) {\n  const bigMapUpdates = await tzkt.getBigMapUpdates(params);\n  const decoder = t.array(D.BigMapUpdateRow(content));\n  const decoded = decoder.decode(bigMapUpdates);\n  if (isLeft(decoded)) {\n    throw Error('Failed to decode `getBigMapUpdates` response');\n  }\n  return decoded.right;\n}\n\nasync function getContracts<S extends t.Mixed>(\n  tzkt: TzKt,\n  params: Params,\n  storage: S\n) {\n  const contracts = await tzkt.getContracts(params);\n  const contractsArray = t.array(t.unknown).decode(contracts);\n  if (isLeft(contractsArray)) {\n    throw Error('Failed to decode `getContracts` response');\n  }\n  const decodedArray = contractsArray.right.map(D.ContractRow(storage).decode);\n  return compact(decodedArray.map(getRight));\n}\n\nasync function getContract<S extends t.Mixed>(\n  tzkt: TzKt,\n  address: string,\n  params: Params,\n  storage: S\n) {\n  const contract = await tzkt.getContract(address, params);\n  const decoded = D.ContractRow(storage).decode(contract);\n  if (isLeft(decoded)) {\n    throw Error('Failed to decode `getContracts` response');\n  }\n  return decoded.right;\n}\n\n//// Main query functions\n\nexport async function getContractNfts(\n  system: SystemWithToolkit | SystemWithWallet,\n  address: string\n): Promise<D.Nft[]> {\n  const ledger = await getLedgerBigMap(system.tzkt, address);\n  const tokens = await getTokenMetadataBigMap(system.tzkt, address);\n  const mktAddress = system.config.contracts.marketplace.fixedPrice.tez;\n  const tokenSales = await getFixedPriceSalesBigMap(system.tzkt, mktAddress);\n  const activeSales = tokenSales.filter(sale => sale.active);\n\n  // Sort by token id - descending\n  const tokensSorted = [...tokens].sort((a,b)=>- (Number.parseInt(a.value.token_id, 10) - Number.parseInt(b.value.token_id, 10)));\n\n  return Promise.all(\n    tokensSorted.map(\n      async (token): Promise<D.Nft> => {\n        const { token_id: tokenId, token_info: tokenInfo } = token.value;\n\n        // TODO: Write decoder function for data retrieval\n        const decodedInfo = _.mapValues(tokenInfo, fromHexString) as any;\n        const resolvedInfo = await system.resolveMetadata(\n          decodedInfo[''],\n          address\n        );\n        const metadata = { ...decodedInfo, ...resolvedInfo.metadata };\n\n        const saleData = activeSales.find(\n          v =>\n            v.value.sale_data.sale_token.fa2_address === address &&\n            v.value.sale_data.sale_token.token_id === tokenId\n        );\n\n        const sale = saleData && {\n          id: saleData.id,\n          seller: saleData.value.seller,\n          price: Number.parseInt(saleData.value.sale_data.price, 10) / 1000000,\n          mutez: Number.parseInt(saleData.value.sale_data.price, 10),\n          saleToken: {\n            address: saleData.value.sale_data.sale_token.fa2_address,\n            tokenId: Number.parseInt(saleData.value.sale_data.sale_token.token_id)\n          },\n          saleId: saleData.value.isLegacy ? 0 : Number.parseInt(saleData.key),\n          type: saleData.value.isLegacy ? 'fixedPriceLegacy' : 'fixedPrice'\n        };\n\n        return {\n          id: parseInt(tokenId, 10),\n          owner: ledger.find(e => e.key === tokenId)?.value!,\n          title: metadata.name,\n          description: metadata.description,\n          artifactUri: metadata.artifactUri,\n          metadata: metadata,\n          sale\n        };\n      }\n    )\n  );\n}\n\nexport async function getNftAssetContract(\n  system: SystemWithToolkit | SystemWithWallet,\n  address: string\n): Promise<D.AssetContract> {\n  const contract = await getContract(system.tzkt, address, {}, t.unknown);\n  const metaBigMap = await getAssetMetadataBigMap(system.tzkt, address);\n  const metaUri = metaBigMap.find(v => v.key === '')?.value;\n  if (!metaUri) {\n    throw Error(`Could not extract metadata URI from ${address} storage`);\n  }\n\n  const { metadata } = await system.resolveMetadata(\n    fromHexString(metaUri),\n    address\n  );\n  const decoded = D.AssetContractMetadata.decode(metadata);\n\n  if (isLeft(decoded)) {\n    throw Error('Metadata validation failed');\n  }\n  return { ...contract, metadata: decoded.right };\n}\n\nexport async function getWalletNftAssetContracts(\n  system: SystemWithWallet\n): Promise<D.AssetContract[]> {\n  return await getNftAssetContracts(system, system.tzPublicKey);\n};\n\nexport async function getNftAssetContracts(\n  system: SystemWithWallet,\n  tzPublicKey: string\n): Promise<D.AssetContract[]> {\n  const contracts = await getContracts(\n    system.tzkt,\n    {\n      creator: tzPublicKey,\n      includeStorage: 'true'\n    },\n    t.unknown\n  );\n\n  const addresses = _.uniq(\n    contracts\n      .filter(c => c.kind === 'asset' && c.tzips?.includes('fa2'))\n      .map(c => c.address)\n  );\n\n  const results: D.AssetContract[] = [];\n\n  if (addresses.length === 0) {\n    return results;\n  }\n\n  const assetBigMapRows = (\n    await getBigMapUpdates(\n      system.tzkt,\n      {\n        path: 'metadata',\n        action: 'add_key',\n        'contract.in': addresses.join(','),\n        limit: '10000'\n      },\n      {\n        key: t.string,\n        value: t.string\n      }\n    )\n  ).filter(v => v.content.key === '');\n\n  for (const row of assetBigMapRows) {\n    const contract = contracts.find(c => c.address === row.contract.address);\n    if (!contract) {\n      continue;\n    }\n    try {\n      const metaUri = row.content.value;\n      const { metadata } = await system.resolveMetadata(\n        fromHexString(metaUri),\n        contract.address\n      );\n      const decoded = D.AssetContractMetadata.decode(metadata);\n      if (!isLeft(decoded)) {\n        results.push({ ...contract, metadata: decoded.right });\n      }\n    } catch (e) {\n      console.log(e);\n    }\n  }\n\n  return results;\n}\n\nexport type MarketplaceNftLoadingData = {\n  loaded: boolean;\n  error?: string;\n  token: null | D.Nft;\n  tokenSale: D.FixedPriceSaleBigMap[number];\n  tokenMetadata: undefined | string;\n};\n\nexport async function getMarketplaceNfts(\n  system: SystemWithToolkit | SystemWithWallet,\n  address: string\n): Promise<MarketplaceNftLoadingData[]> {\n  const tokenSales = await getFixedPriceSalesBigMap(system.tzkt, address);\n  const activeSales = tokenSales.filter(v => v.active);\n  const addresses = _.uniq(\n    activeSales.map(s => s.value.sale_data.sale_token.fa2_address)\n  );\n\n  const uniqueAddresses = Array.from(new Set(addresses));\n\n  if (uniqueAddresses.length === 0) {\n    return [];\n  }\n\n  const tokenBigMapRows = await getBigMapUpdates(\n    system.tzkt,\n    {\n      path: 'assets.token_metadata',\n      action: 'add_key',\n      'contract.in': addresses.join(','),\n      limit: '10000'\n    },\n    {\n      key: t.string,\n      value: t.type({\n        token_id: t.string,\n        token_info: t.record(t.string, t.string)\n      })\n    }\n  );\n\n  // Sort descending (newest first)\n  const salesToView = [...activeSales].reverse();\n  const salesWithTokenMetadata = salesToView\n    .map(x => ({\n      tokenSale: x,\n      tokenItem: tokenBigMapRows.find(\n        item =>\n          x.value.sale_data.sale_token.fa2_address === item.contract.address &&\n          x.value.sale_data.sale_token.token_id ===\n            item.content.value.token_id + ''\n      )\n    }))\n    .map(x => ({\n      loaded: false,\n      token: null,\n      tokenSale: x.tokenSale,\n      tokenMetadata: x.tokenItem?.content?.value?.token_info['']\n    }));\n\n  return salesWithTokenMetadata;\n}\n\nexport const loadMarketplaceNft = async (\n  system: SystemWithToolkit | SystemWithWallet,\n  tokenLoadData: MarketplaceNftLoadingData\n): Promise<MarketplaceNftLoadingData> => {\n  const { token, loaded, tokenSale, tokenMetadata } = tokenLoadData;\n  const result = { ...tokenLoadData };\n\n  if (token || loaded) {\n    return result;\n  }\n  result.loaded = true;\n\n  try {\n    const {\n      fa2_address: saleAddress,\n      token_id: tokenIdStr\n    } = tokenSale.value.sale_data.sale_token;\n\n    const tokenId = parseInt(tokenIdStr, 10);\n    const mutez = Number.parseInt(tokenSale.value.sale_data.price, 10);\n    const sale = {\n      id: tokenSale.id,\n      seller: tokenSale.value.seller,\n      price: mutez / 1000000,\n      mutez: mutez,\n      saleToken: {\n        address: tokenSale.value.sale_data.sale_token.fa2_address,\n        tokenId: Number.parseInt(tokenSale.value.sale_data.sale_token.token_id)\n      },\n      saleId: tokenSale.value.isLegacy ? 0 : Number.parseInt(tokenSale.key),\n      type: tokenSale.value.isLegacy ? 'fixedPriceLegacy' : 'fixedPrice'\n    };\n\n    if (!tokenMetadata) {\n      result.error = \"Couldn't retrieve tokenMetadata\";\n      console.error(\"Couldn't retrieve tokenMetadata\", { tokenSale });\n      return result;\n    }\n\n    const { metadata } = (await system.resolveMetadata(\n      fromHexString(tokenMetadata),\n      saleAddress\n    )) as any;\n\n    result.token = {\n      address: saleAddress,\n      id: tokenId,\n      title: metadata.name || '',\n      owner: sale.seller,\n      description: metadata.description || '',\n      artifactUri: metadata.artifactUri || '',\n      metadata: metadata,\n      sale: sale\n    };\n\n    return result;\n  } catch (err) {\n    result.error = \"Couldn't load token\";\n    console.error(\"Couldn't load token\", { tokenSale, err });\n    return result;\n  }\n};\n"]},"metadata":{},"sourceType":"module"}