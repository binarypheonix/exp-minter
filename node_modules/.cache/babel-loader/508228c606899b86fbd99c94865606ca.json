{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getFunctorComposition = exports.bindTo = exports.flap = exports.map = void 0;\n/**\n * A `Functor` is a type constructor which supports a mapping operation `map`.\n *\n * `map` can be used to turn functions `a -> b` into functions `f a -> f b` whose argument and return types use the type\n * constructor `f` to represent some computational context.\n *\n * Instances must satisfy the following laws:\n *\n * 1. Identity: `F.map(fa, a => a) <-> fa`\n * 2. Composition: `F.map(fa, a => bc(ab(a))) <-> F.map(F.map(fa, ab), bc)`\n *\n * @since 2.0.0\n */\n\nvar function_1 = require(\"./function\");\n\nfunction map(F, G) {\n  return function (f) {\n    return function (fa) {\n      return F.map(fa, function (ga) {\n        return G.map(ga, f);\n      });\n    };\n  };\n}\n\nexports.map = map;\n\nfunction flap(F) {\n  return function (a) {\n    return function (fab) {\n      return F.map(fab, function (f) {\n        return f(a);\n      });\n    };\n  };\n}\n\nexports.flap = flap;\n\nfunction bindTo(F) {\n  return function (name) {\n    return function (fa) {\n      return F.map(fa, function (a) {\n        var _a;\n\n        return _a = {}, _a[name] = a, _a;\n      });\n    };\n  };\n}\n\nexports.bindTo = bindTo;\n/** @deprecated */\n\nfunction getFunctorComposition(F, G) {\n  var _map = map(F, G);\n\n  return {\n    map: function (fga, f) {\n      return function_1.pipe(fga, _map(f));\n    }\n  };\n}\n\nexports.getFunctorComposition = getFunctorComposition;","map":{"version":3,"sources":["/Users/frankenstein/projects/minter/node_modules/fp-ts/lib/Functor.js"],"names":["Object","defineProperty","exports","value","getFunctorComposition","bindTo","flap","map","function_1","require","F","G","f","fa","ga","a","fab","name","_a","_map","fga","pipe"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,qBAAR,GAAgCF,OAAO,CAACG,MAAR,GAAiBH,OAAO,CAACI,IAAR,GAAeJ,OAAO,CAACK,GAAR,GAAc,KAAK,CAAnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIC,UAAU,GAAGC,OAAO,CAAC,YAAD,CAAxB;;AACA,SAASF,GAAT,CAAaG,CAAb,EAAgBC,CAAhB,EAAmB;AACf,SAAO,UAAUC,CAAV,EAAa;AAAE,WAAO,UAAUC,EAAV,EAAc;AAAE,aAAOH,CAAC,CAACH,GAAF,CAAMM,EAAN,EAAU,UAAUC,EAAV,EAAc;AAAE,eAAOH,CAAC,CAACJ,GAAF,CAAMO,EAAN,EAAUF,CAAV,CAAP;AAAsB,OAAhD,CAAP;AAA2D,KAAlF;AAAqF,GAA3G;AACH;;AACDV,OAAO,CAACK,GAAR,GAAcA,GAAd;;AACA,SAASD,IAAT,CAAcI,CAAd,EAAiB;AACb,SAAO,UAAUK,CAAV,EAAa;AAAE,WAAO,UAAUC,GAAV,EAAe;AAAE,aAAON,CAAC,CAACH,GAAF,CAAMS,GAAN,EAAW,UAAUJ,CAAV,EAAa;AAAE,eAAOA,CAAC,CAACG,CAAD,CAAR;AAAc,OAAxC,CAAP;AAAmD,KAA3E;AAA8E,GAApG;AACH;;AACDb,OAAO,CAACI,IAAR,GAAeA,IAAf;;AACA,SAASD,MAAT,CAAgBK,CAAhB,EAAmB;AACf,SAAO,UAAUO,IAAV,EAAgB;AAAE,WAAO,UAAUJ,EAAV,EAAc;AAAE,aAAOH,CAAC,CAACH,GAAF,CAAMM,EAAN,EAAU,UAAUE,CAAV,EAAa;AAC1E,YAAIG,EAAJ;;AACA,eAAQA,EAAE,GAAG,EAAL,EAASA,EAAE,CAACD,IAAD,CAAF,GAAWF,CAApB,EAAuBG,EAA/B;AACH,OAHsD,CAAP;AAG3C,KAHoB;AAGjB,GAHR;AAIH;;AACDhB,OAAO,CAACG,MAAR,GAAiBA,MAAjB;AACA;;AACA,SAASD,qBAAT,CAA+BM,CAA/B,EAAkCC,CAAlC,EAAqC;AACjC,MAAIQ,IAAI,GAAGZ,GAAG,CAACG,CAAD,EAAIC,CAAJ,CAAd;;AACA,SAAO;AACHJ,IAAAA,GAAG,EAAE,UAAUa,GAAV,EAAeR,CAAf,EAAkB;AAAE,aAAOJ,UAAU,CAACa,IAAX,CAAgBD,GAAhB,EAAqBD,IAAI,CAACP,CAAD,CAAzB,CAAP;AAAuC;AAD7D,GAAP;AAGH;;AACDV,OAAO,CAACE,qBAAR,GAAgCA,qBAAhC","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getFunctorComposition = exports.bindTo = exports.flap = exports.map = void 0;\n/**\n * A `Functor` is a type constructor which supports a mapping operation `map`.\n *\n * `map` can be used to turn functions `a -> b` into functions `f a -> f b` whose argument and return types use the type\n * constructor `f` to represent some computational context.\n *\n * Instances must satisfy the following laws:\n *\n * 1. Identity: `F.map(fa, a => a) <-> fa`\n * 2. Composition: `F.map(fa, a => bc(ab(a))) <-> F.map(F.map(fa, ab), bc)`\n *\n * @since 2.0.0\n */\nvar function_1 = require(\"./function\");\nfunction map(F, G) {\n    return function (f) { return function (fa) { return F.map(fa, function (ga) { return G.map(ga, f); }); }; };\n}\nexports.map = map;\nfunction flap(F) {\n    return function (a) { return function (fab) { return F.map(fab, function (f) { return f(a); }); }; };\n}\nexports.flap = flap;\nfunction bindTo(F) {\n    return function (name) { return function (fa) { return F.map(fa, function (a) {\n        var _a;\n        return (_a = {}, _a[name] = a, _a);\n    }); }; };\n}\nexports.bindTo = bindTo;\n/** @deprecated */\nfunction getFunctorComposition(F, G) {\n    var _map = map(F, G);\n    return {\n        map: function (fga, f) { return function_1.pipe(fga, _map(f)); }\n    };\n}\nexports.getFunctorComposition = getFunctorComposition;\n"]},"metadata":{},"sourceType":"script"}