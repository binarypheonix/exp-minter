{"ast":null,"code":"import { createSlice } from '@reduxjs/toolkit';\nimport { getAssetContractsQuery, getContractNftsQuery, getNftAssetContractQuery, getWalletAssetContractsQuery } from '../async/queries';\nimport config from '../../config.json'; //// State\n// Types\n\n// Data\nexport const initialState = {\n  selectedCollection: null,\n  globalCollection: config.contracts.nftFaucet,\n  collections: {}\n}; //// Reducers & Slice\n\nconst populateCollectionR = (state, {\n  payload\n}) => {\n  if (state.collections[payload.address]) {\n    state.collections[payload.address].tokens = payload.tokens;\n    state.collections[payload.address].loaded = true;\n  }\n};\n\nconst updateCollectionsR = (state, action) => {\n  for (let coll of action.payload) {\n    state.collections[coll.address] = { ...coll,\n      tokens: null,\n      loaded: false\n    };\n  }\n};\n\nconst updateCollectionR = (state, {\n  payload\n}) => {\n  if (!state.collections[payload.address]) {\n    state.collections[payload.address] = { ...payload,\n      tokens: null,\n      loaded: false\n    };\n  }\n};\n\nconst selectCollectionR = (state, action) => {\n  state.selectedCollection = action.payload;\n};\n\nconst slice = createSlice({\n  name: 'collections',\n  initialState,\n  reducers: {\n    updateCollections: updateCollectionsR,\n    updateCollection: updateCollectionR,\n    selectCollection: selectCollectionR,\n    populateCollection: populateCollectionR\n  },\n  extraReducers: ({\n    addCase\n  }) => {\n    addCase(getContractNftsQuery.fulfilled, populateCollectionR);\n    addCase(getNftAssetContractQuery.fulfilled, updateCollectionR);\n    addCase(getWalletAssetContractsQuery.fulfilled, updateCollectionsR);\n    addCase(getAssetContractsQuery.fulfilled, updateCollectionsR);\n  }\n});\nexport const {\n  updateCollections,\n  updateCollection,\n  selectCollection,\n  populateCollection\n} = slice.actions;\nexport default slice;","map":{"version":3,"sources":["/Users/frankenstein/projects/minter/src/reducer/slices/collections.ts"],"names":["createSlice","getAssetContractsQuery","getContractNftsQuery","getNftAssetContractQuery","getWalletAssetContractsQuery","config","initialState","selectedCollection","globalCollection","contracts","nftFaucet","collections","populateCollectionR","state","payload","address","tokens","loaded","updateCollectionsR","action","coll","updateCollectionR","selectCollectionR","slice","name","reducers","updateCollections","updateCollection","selectCollection","populateCollection","extraReducers","addCase","fulfilled","actions"],"mappings":"AAAA,SAASA,WAAT,QAAwD,kBAAxD;AACA,SACEC,sBADF,EAEEC,oBAFF,EAGEC,wBAHF,EAIEC,4BAJF,QAKO,kBALP;AAOA,OAAOC,MAAP,MAAmB,mBAAnB,C,CAEA;AAEA;;AAiBA;AAEA,OAAO,MAAMC,YAA8B,GAAG;AAC5CC,EAAAA,kBAAkB,EAAE,IADwB;AAE5CC,EAAAA,gBAAgB,EAAEH,MAAM,CAACI,SAAP,CAAiBC,SAFS;AAG5CC,EAAAA,WAAW,EAAE;AAH+B,CAAvC,C,CAMP;;AAIA,MAAMC,mBAAuC,GAAG,CAACC,KAAD,EAAQ;AAAEC,EAAAA;AAAF,CAAR,KAAwB;AACtE,MAAID,KAAK,CAACF,WAAN,CAAkBG,OAAO,CAACC,OAA1B,CAAJ,EAAwC;AACtCF,IAAAA,KAAK,CAACF,WAAN,CAAkBG,OAAO,CAACC,OAA1B,EAAmCC,MAAnC,GAA4CF,OAAO,CAACE,MAApD;AACAH,IAAAA,KAAK,CAACF,WAAN,CAAkBG,OAAO,CAACC,OAA1B,EAAmCE,MAAnC,GAA4C,IAA5C;AACD;AACF,CALD;;AAOA,MAAMC,kBAA4C,GAAG,CAACL,KAAD,EAAQM,MAAR,KAAmB;AACtE,OAAK,IAAIC,IAAT,IAAiBD,MAAM,CAACL,OAAxB,EAAiC;AAC/BD,IAAAA,KAAK,CAACF,WAAN,CAAkBS,IAAI,CAACL,OAAvB,IAAkC,EAChC,GAAGK,IAD6B;AAEhCJ,MAAAA,MAAM,EAAE,IAFwB;AAGhCC,MAAAA,MAAM,EAAE;AAHwB,KAAlC;AAKD;AACF,CARD;;AAUA,MAAMI,iBAAyC,GAAG,CAACR,KAAD,EAAQ;AAAEC,EAAAA;AAAF,CAAR,KAAwB;AACxE,MAAI,CAACD,KAAK,CAACF,WAAN,CAAkBG,OAAO,CAACC,OAA1B,CAAL,EAAyC;AACvCF,IAAAA,KAAK,CAACF,WAAN,CAAkBG,OAAO,CAACC,OAA1B,IAAqC,EACnC,GAAGD,OADgC;AAEnCE,MAAAA,MAAM,EAAE,IAF2B;AAGnCC,MAAAA,MAAM,EAAE;AAH2B,KAArC;AAKD;AACF,CARD;;AAUA,MAAMK,iBAAkC,GAAG,CAACT,KAAD,EAAQM,MAAR,KAAmB;AAC5DN,EAAAA,KAAK,CAACN,kBAAN,GAA2BY,MAAM,CAACL,OAAlC;AACD,CAFD;;AAIA,MAAMS,KAAK,GAAGvB,WAAW,CAAC;AACxBwB,EAAAA,IAAI,EAAE,aADkB;AAExBlB,EAAAA,YAFwB;AAGxBmB,EAAAA,QAAQ,EAAE;AACRC,IAAAA,iBAAiB,EAAER,kBADX;AAERS,IAAAA,gBAAgB,EAAEN,iBAFV;AAGRO,IAAAA,gBAAgB,EAAEN,iBAHV;AAIRO,IAAAA,kBAAkB,EAAEjB;AAJZ,GAHc;AASxBkB,EAAAA,aAAa,EAAE,CAAC;AAAEC,IAAAA;AAAF,GAAD,KAAiB;AAC9BA,IAAAA,OAAO,CAAC7B,oBAAoB,CAAC8B,SAAtB,EAAiCpB,mBAAjC,CAAP;AACAmB,IAAAA,OAAO,CAAC5B,wBAAwB,CAAC6B,SAA1B,EAAqCX,iBAArC,CAAP;AACAU,IAAAA,OAAO,CAAC3B,4BAA4B,CAAC4B,SAA9B,EAAyCd,kBAAzC,CAAP;AACAa,IAAAA,OAAO,CAAC9B,sBAAsB,CAAC+B,SAAxB,EAAmCd,kBAAnC,CAAP;AACD;AAduB,CAAD,CAAzB;AAiBA,OAAO,MAAM;AACXQ,EAAAA,iBADW;AAEXC,EAAAA,gBAFW;AAGXC,EAAAA,gBAHW;AAIXC,EAAAA;AAJW,IAKTN,KAAK,CAACU,OALH;AAOP,eAAeV,KAAf","sourcesContent":["import { createSlice, PayloadAction, CaseReducer } from '@reduxjs/toolkit';\nimport {\n  getAssetContractsQuery,\n  getContractNftsQuery,\n  getNftAssetContractQuery,\n  getWalletAssetContractsQuery\n} from '../async/queries';\nimport { Nft, AssetContract } from '../../lib/nfts/decoders';\nimport config from '../../config.json';\n\n//// State\n\n// Types\n\nexport type Token = Nft;\n\nexport interface Collection extends AssetContract {\n  tokens: Token[] | null;\n  loaded: boolean;\n}\n\nexport interface CollectionsState {\n  selectedCollection: string | null;\n  globalCollection: string;\n  collections: Record<string, Collection>;\n}\n\ntype Reducer<A> = CaseReducer<CollectionsState, PayloadAction<A>>;\n\n// Data\n\nexport const initialState: CollectionsState = {\n  selectedCollection: null,\n  globalCollection: config.contracts.nftFaucet,\n  collections: {}\n};\n\n//// Reducers & Slice\n\ntype PopulateCollection = Reducer<{ address: string; tokens: Token[] }>;\n\nconst populateCollectionR: PopulateCollection = (state, { payload }) => {\n  if (state.collections[payload.address]) {\n    state.collections[payload.address].tokens = payload.tokens;\n    state.collections[payload.address].loaded = true;\n  }\n};\n\nconst updateCollectionsR: Reducer<AssetContract[]> = (state, action) => {\n  for (let coll of action.payload) {\n    state.collections[coll.address] = {\n      ...coll,\n      tokens: null,\n      loaded: false\n    };\n  }\n};\n\nconst updateCollectionR: Reducer<AssetContract> = (state, { payload }) => {\n  if (!state.collections[payload.address]) {\n    state.collections[payload.address] = {\n      ...payload,\n      tokens: null,\n      loaded: false\n    };\n  }\n};\n\nconst selectCollectionR: Reducer<string> = (state, action) => {\n  state.selectedCollection = action.payload;\n};\n\nconst slice = createSlice({\n  name: 'collections',\n  initialState,\n  reducers: {\n    updateCollections: updateCollectionsR,\n    updateCollection: updateCollectionR,\n    selectCollection: selectCollectionR,\n    populateCollection: populateCollectionR\n  },\n  extraReducers: ({ addCase }) => {\n    addCase(getContractNftsQuery.fulfilled, populateCollectionR);\n    addCase(getNftAssetContractQuery.fulfilled, updateCollectionR);\n    addCase(getWalletAssetContractsQuery.fulfilled, updateCollectionsR);\n    addCase(getAssetContractsQuery.fulfilled, updateCollectionsR);\n  }\n});\n\nexport const {\n  updateCollections,\n  updateCollection,\n  selectCollection,\n  populateCollection\n} = slice.actions;\n\nexport default slice;\n"]},"metadata":{},"sourceType":"module"}