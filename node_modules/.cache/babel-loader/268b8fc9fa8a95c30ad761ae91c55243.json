{"ast":null,"code":"import{createSlice}from'@reduxjs/toolkit';import{createAssetContractAction,mintTokenAction,transferTokenAction,listTokenAction,cancelTokenSaleAction,buyTokenAction,mintCsvTokensAction}from'../async/actions';import{getContractNftsQuery,getNftAssetContractQuery,getWalletAssetContractsQuery}from'../async/queries';import{ErrorKind}from'../async/errors';var defaultStatus={status:'ready',error:null};var initialState={createAssetContract:defaultStatus,mintToken:defaultStatus,mintCsvTokens:defaultStatus,transferToken:defaultStatus,listToken:defaultStatus,cancelTokenSale:defaultStatus,buyToken:defaultStatus,getContractNfts:defaultStatus,getNftAssetContract:defaultStatus,getWalletAssetContracts:defaultStatus};function methodMap(method,action){return{method:method,action:action};}var slice=createSlice({name:'status',initialState:initialState,reducers:{setStatus:function setStatus(state,_ref){var payload=_ref.payload;state[payload.method].status=payload.status;},clearError:function clearError(state,_ref2){var payload=_ref2.payload;state[payload.method].error=null;}},extraReducers:function extraReducers(_ref3){var addCase=_ref3.addCase;[methodMap('createAssetContract',createAssetContractAction),methodMap('mintToken',mintTokenAction),methodMap('mintCsvTokens',mintCsvTokensAction),methodMap('transferToken',transferTokenAction),methodMap('listToken',listTokenAction),methodMap('cancelTokenSale',cancelTokenSaleAction),methodMap('buyToken',buyTokenAction),methodMap('getContractNfts',getContractNftsQuery),methodMap('getNftAssetContract',getNftAssetContractQuery),methodMap('getWalletAssetContracts',getWalletAssetContractsQuery)].forEach(function(_ref4){var method=_ref4.method,action=_ref4.action;addCase(action.pending,function(state){state[method].status='in_transit';});addCase(action.fulfilled,function(state){state[method].status='complete';});addCase(action.rejected,function(state,action){var rejectValue=action.payload?action.payload:{kind:ErrorKind.UnknownError,message:'Unknown error'};state[method].error={rejectValue:rejectValue,serialized:action.error};});});}});var _slice$actions=slice.actions,setStatus=_slice$actions.setStatus,clearError=_slice$actions.clearError;export{setStatus,clearError};export default slice;","map":{"version":3,"sources":["/Users/frankenstein/projects/minter/src/reducer/slices/status.ts"],"names":["createSlice","createAssetContractAction","mintTokenAction","transferTokenAction","listTokenAction","cancelTokenSaleAction","buyTokenAction","mintCsvTokensAction","getContractNftsQuery","getNftAssetContractQuery","getWalletAssetContractsQuery","ErrorKind","defaultStatus","status","error","initialState","createAssetContract","mintToken","mintCsvTokens","transferToken","listToken","cancelTokenSale","buyToken","getContractNfts","getNftAssetContract","getWalletAssetContracts","methodMap","method","action","slice","name","reducers","setStatus","state","payload","clearError","extraReducers","addCase","forEach","pending","fulfilled","rejected","rejectValue","kind","UnknownError","message","serialized","actions"],"mappings":"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","sourcesContent":["import { createSlice, PayloadAction, SerializedError } from '@reduxjs/toolkit';\nimport {\n  createAssetContractAction,\n  mintTokenAction,\n  transferTokenAction,\n  listTokenAction,\n  cancelTokenSaleAction,\n  buyTokenAction,\n  mintCsvTokensAction\n} from '../async/actions';\nimport {\n  getContractNftsQuery,\n  getNftAssetContractQuery,\n  getWalletAssetContractsQuery\n} from '../async/queries';\nimport { ErrorKind, RejectValue } from '../async/errors';\n\nexport type StatusKey = 'ready' | 'in_transit' | 'complete';\n\nexport interface Status {\n  status: StatusKey;\n  error: {\n    rejectValue: RejectValue;\n    serialized: SerializedError;\n  } | null;\n}\n\nexport interface StatusState {\n  createAssetContract: Status;\n  mintToken: Status;\n  mintCsvTokens: Status;\n  transferToken: Status;\n  listToken: Status;\n  cancelTokenSale: Status;\n  buyToken: Status;\n  getContractNfts: Status;\n  getNftAssetContract: Status;\n  getWalletAssetContracts: Status;\n}\n\nexport type Method = keyof StatusState;\n\nconst defaultStatus: Status = { status: 'ready', error: null };\n\nconst initialState: StatusState = {\n  createAssetContract: defaultStatus,\n  mintToken: defaultStatus,\n  mintCsvTokens: defaultStatus,\n  transferToken: defaultStatus,\n  listToken: defaultStatus,\n  cancelTokenSale: defaultStatus,\n  buyToken: defaultStatus,\n  getContractNfts: defaultStatus,\n  getNftAssetContract: defaultStatus,\n  getWalletAssetContracts: defaultStatus\n};\n\ntype SetStatusAction = PayloadAction<{ method: Method; status: StatusKey }>;\ntype ClearErrorAction = PayloadAction<{ method: Method }>;\n\nfunction methodMap<A>(method: keyof StatusState, action: A) {\n  return { method, action };\n}\n\nconst slice = createSlice({\n  name: 'status',\n  initialState,\n  reducers: {\n    setStatus(state, { payload }: SetStatusAction) {\n      state[payload.method].status = payload.status;\n    },\n    clearError(state, { payload }: ClearErrorAction) {\n      state[payload.method].error = null;\n    }\n  },\n  extraReducers: ({ addCase }) => {\n    [\n      methodMap('createAssetContract', createAssetContractAction),\n      methodMap('mintToken', mintTokenAction),\n      methodMap('mintCsvTokens', mintCsvTokensAction),\n      methodMap('transferToken', transferTokenAction),\n      methodMap('listToken', listTokenAction),\n      methodMap('cancelTokenSale', cancelTokenSaleAction),\n      methodMap('buyToken', buyTokenAction),\n      methodMap('getContractNfts', getContractNftsQuery),\n      methodMap('getNftAssetContract', getNftAssetContractQuery),\n      methodMap('getWalletAssetContracts', getWalletAssetContractsQuery)\n    ].forEach(({ method, action }) => {\n      addCase(action.pending, state => {\n        state[method].status = 'in_transit';\n      });\n      addCase(action.fulfilled, state => {\n        state[method].status = 'complete';\n      });\n      addCase(action.rejected, (state, action) => {\n        const rejectValue = action.payload\n          ? action.payload\n          : {\n              kind: ErrorKind.UnknownError,\n              message: 'Unknown error'\n            };\n        state[method].error = {\n          rejectValue,\n          serialized: action.error\n        };\n      });\n    });\n  }\n});\n\nexport const { setStatus, clearError } = slice.actions;\n\nexport default slice;\n"]},"metadata":{},"sourceType":"module"}