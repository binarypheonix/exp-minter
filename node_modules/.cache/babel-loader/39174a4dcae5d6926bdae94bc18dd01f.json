{"ast":null,"code":"import _toConsumableArray from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _regeneratorRuntime from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _classCallCheck from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _get from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { ExposedPromise } from '../../utils/exposed-promise';\nimport { Logger } from '../../utils/Logger';\nimport { generateGUID } from '../../utils/generate-uuid';\nimport { BeaconEvent } from '../../events';\nimport { BEACON_VERSION } from '../../constants';\nimport { getAddressFromPublicKey } from '../../utils/crypto';\nimport { Client, TransportType, StorageKey, BeaconMessageType, PermissionScope, NetworkType, Serializer, LocalStorage, BeaconError, Origin, PostMessageTransport, DappP2PTransport, DappPostMessageTransport, PeerManager, AppMetadataManager } from '../..';\nimport { messageEvents } from '../../beacon-message-events';\nimport { getAccountIdentifier } from '../../utils/get-account-identifier';\nimport { TezblockBlockExplorer } from '../../utils/tezblock-blockexplorer';\nimport { BeaconErrorType } from '../../types/BeaconErrorType';\nimport { getSenderId } from '../../utils/get-sender-id';\nimport { SigningType } from '../../types/beacon/SigningType';\nimport { ColorMode } from '../../types/ColorMode';\nimport { getColorMode as _getColorMode, setColorMode as _setColorMode } from '../../colorMode';\nimport { desktopList, extensionList, iOSList, webList } from '../../ui/alert/wallet-lists';\nvar logger = new Logger('DAppClient');\n/**\n * @publicapi\n *\n * The DAppClient has to be used in decentralized applications. It handles all the logic related to connecting to beacon-compatible\n * wallets and sending requests.\n *\n * @category DApp\n */\n\nexport var DAppClient = /*#__PURE__*/function (_Client) {\n  _inherits(DAppClient, _Client);\n\n  var _super2 = _createSuper(DAppClient);\n\n  function DAppClient(config) {\n    var _this;\n\n    _classCallCheck(this, DAppClient);\n\n    var _a, _b, _c;\n\n    _this = _super2.call(this, Object.assign({\n      storage: config && config.storage ? config.storage : new LocalStorage()\n    }, config));\n    /**\n     * A map of requests that are currently \"open\", meaning we have sent them to a wallet and are still awaiting a response.\n     */\n\n    _this.openRequests = new Map();\n    /**\n     * The currently active account. For all requests that are associated to a specific request (operation request, signing request),\n     * the active account is used to determine the network and destination wallet\n     */\n\n    _this._activeAccount = new ExposedPromise();\n    /**\n     * The currently active peer. This is used to address a peer in case the active account is not set. (Eg. for permission requests)\n     */\n\n    _this._activePeer = new ExposedPromise();\n    _this.blockExplorer = (_a = config.blockExplorer) !== null && _a !== void 0 ? _a : new TezblockBlockExplorer();\n    _this.preferredNetwork = (_b = config.preferredNetwork) !== null && _b !== void 0 ? _b : NetworkType.MAINNET;\n\n    _setColorMode((_c = config.colorMode) !== null && _c !== void 0 ? _c : ColorMode.LIGHT);\n\n    _this.appMetadataManager = new AppMetadataManager(_this.storage);\n    _this.activeAccountLoaded = _this.storage.get(StorageKey.ACTIVE_ACCOUNT).then(function (activeAccountIdentifier) {\n      return __awaiter(_assertThisInitialized(_this), void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!activeAccountIdentifier) {\n                  _context.next = 9;\n                  break;\n                }\n\n                _context.t0 = this;\n                _context.next = 4;\n                return this.accountManager.getAccount(activeAccountIdentifier);\n\n              case 4:\n                _context.t1 = _context.sent;\n                _context.next = 7;\n                return _context.t0.setActiveAccount.call(_context.t0, _context.t1);\n\n              case 7:\n                _context.next = 11;\n                break;\n\n              case 9:\n                _context.next = 11;\n                return this.setActiveAccount(undefined);\n\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }).catch(function (storageError) {\n      return __awaiter(_assertThisInitialized(_this), void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.setActiveAccount(undefined);\n\n              case 2:\n                console.error(storageError);\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    });\n    _this.activePeerLoaded = _this.storage.get(StorageKey.ACTIVE_PEER).then(function (activePeerPublicKey) {\n      return __awaiter(_assertThisInitialized(_this), void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var _d, p2pPeerManager, postmessagePeerManager, peer;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!activePeerPublicKey) {\n                  _context3.next = 21;\n                  break;\n                }\n\n                p2pPeerManager = new PeerManager(this.storage, StorageKey.TRANSPORT_P2P_PEERS_DAPP);\n                postmessagePeerManager = new PeerManager(this.storage, StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP);\n                _context3.next = 5;\n                return p2pPeerManager.getPeer(activePeerPublicKey);\n\n              case 5:\n                _context3.t1 = _d = _context3.sent;\n                _context3.t0 = _context3.t1 !== null;\n\n                if (!_context3.t0) {\n                  _context3.next = 9;\n                  break;\n                }\n\n                _context3.t0 = _d !== void 0;\n\n              case 9:\n                if (!_context3.t0) {\n                  _context3.next = 13;\n                  break;\n                }\n\n                _context3.t2 = _d;\n                _context3.next = 16;\n                break;\n\n              case 13:\n                _context3.next = 15;\n                return postmessagePeerManager.getPeer(activePeerPublicKey);\n\n              case 15:\n                _context3.t2 = _context3.sent;\n\n              case 16:\n                peer = _context3.t2;\n                _context3.next = 19;\n                return this.setActivePeer(peer);\n\n              case 19:\n                _context3.next = 23;\n                break;\n\n              case 21:\n                _context3.next = 23;\n                return this.setActivePeer(undefined);\n\n              case 23:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }).catch(function (storageError) {\n      return __awaiter(_assertThisInitialized(_this), void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.setActiveAccount(undefined);\n\n              case 2:\n                logger.error(storageError);\n\n              case 3:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    });\n\n    _this.handleResponse = function (message, connectionInfo) {\n      return __awaiter(_assertThisInitialized(_this), void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        var _e, openRequest, relevantTransport, peers, peer;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                openRequest = this.openRequests.get(message.id);\n                logger.log('handleResponse', 'Received message', message, connectionInfo);\n\n                if (!(openRequest && message.type === BeaconMessageType.Acknowledge)) {\n                  _context5.next = 16;\n                  break;\n                }\n\n                logger.log(\"acknowledge message received for \".concat(message.id));\n                console.timeLog(message.id, 'acknowledge');\n                _context5.t0 = this.events;\n                _context5.t1 = BeaconEvent.ACKNOWLEDGE_RECEIVED;\n                _context5.t2 = message;\n                _context5.t3 = {};\n                _context5.next = 11;\n                return this.getWalletInfo();\n\n              case 11:\n                _context5.t4 = _context5.sent;\n                _context5.t5 = {\n                  message: _context5.t2,\n                  extraInfo: _context5.t3,\n                  walletInfo: _context5.t4\n                };\n\n                _context5.t0.emit.call(_context5.t0, _context5.t1, _context5.t5).catch(console.error);\n\n                _context5.next = 58;\n                break;\n\n              case 16:\n                if (!openRequest) {\n                  _context5.next = 26;\n                  break;\n                }\n\n                if (!(message.type === BeaconMessageType.PermissionResponse && message.appMetadata)) {\n                  _context5.next = 20;\n                  break;\n                }\n\n                _context5.next = 20;\n                return this.appMetadataManager.addAppMetadata(message.appMetadata);\n\n              case 20:\n                console.timeLog(message.id, 'response');\n                console.timeEnd(message.id);\n\n                if (message.type === BeaconMessageType.Error || message.errorType) {\n                  // TODO: Remove \"any\" once we remove support for v1 wallets\n                  openRequest.reject(message);\n                } else {\n                  openRequest.resolve({\n                    message: message,\n                    connectionInfo: connectionInfo\n                  });\n                }\n\n                this.openRequests.delete(message.id);\n                _context5.next = 58;\n                break;\n\n              case 26:\n                if (!(message.type === BeaconMessageType.Disconnect)) {\n                  _context5.next = 57;\n                  break;\n                }\n\n                if (!(connectionInfo.origin === Origin.P2P)) {\n                  _context5.next = 31;\n                  break;\n                }\n\n                _context5.t6 = this.p2pTransport;\n                _context5.next = 39;\n                break;\n\n              case 31:\n                if (!((_e = this.postMessageTransport) !== null && _e !== void 0)) {\n                  _context5.next = 35;\n                  break;\n                }\n\n                _context5.t7 = _e;\n                _context5.next = 38;\n                break;\n\n              case 35:\n                _context5.next = 37;\n                return this.transport;\n\n              case 37:\n                _context5.t7 = _context5.sent;\n\n              case 38:\n                _context5.t6 = _context5.t7;\n\n              case 39:\n                relevantTransport = _context5.t6;\n\n                if (!relevantTransport) {\n                  _context5.next = 55;\n                  break;\n                }\n\n                _context5.next = 43;\n                return relevantTransport.getPeers();\n\n              case 43:\n                peers = _context5.sent;\n                peer = peers.find(function (peerEl) {\n                  return peerEl.senderId === message.senderId;\n                });\n\n                if (!peer) {\n                  _context5.next = 54;\n                  break;\n                }\n\n                _context5.next = 48;\n                return relevantTransport.removePeer(peer);\n\n              case 48:\n                _context5.next = 50;\n                return this.removeAccountsForPeers([peer]);\n\n              case 50:\n                _context5.next = 52;\n                return this.events.emit(BeaconEvent.CHANNEL_CLOSED);\n\n              case 52:\n                _context5.next = 55;\n                break;\n\n              case 54:\n                logger.error('handleDisconnect', 'cannot find peer for sender ID', message.senderId);\n\n              case 55:\n                _context5.next = 58;\n                break;\n\n              case 57:\n                logger.error('handleResponse', 'no request found for id ', message.id);\n\n              case 58:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n    };\n\n    return _this;\n  }\n\n  _createClass(DAppClient, [{\n    key: \"initInternalTransports\",\n    value: function initInternalTransports() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        var keyPair;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this.keyPair;\n\n              case 2:\n                keyPair = _context6.sent;\n\n                if (!(this.postMessageTransport || this.p2pTransport)) {\n                  _context6.next = 5;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\");\n\n              case 5:\n                this.postMessageTransport = new DappPostMessageTransport(this.name, keyPair, this.storage);\n                _context6.next = 8;\n                return this.addListener(this.postMessageTransport);\n\n              case 8:\n                this.p2pTransport = new DappP2PTransport(this.name, keyPair, this.storage, this.matrixNodes, this.iconUrl, this.appUrl);\n                _context6.next = 11;\n                return this.addListener(this.p2pTransport);\n\n              case 11:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n    }\n  }, {\n    key: \"init\",\n    value: function init(transport) {\n      var _this2 = this;\n\n      var _super = Object.create(null, {\n        init: {\n          get: function get() {\n            return _get(_getPrototypeOf(DAppClient.prototype), \"init\", _this2);\n          }\n        }\n      });\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        var _this3 = this;\n\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                if (!this._initPromise) {\n                  _context9.next = 2;\n                  break;\n                }\n\n                return _context9.abrupt(\"return\", this._initPromise);\n\n              case 2:\n                _context9.prev = 2;\n                _context9.next = 5;\n                return this.activeAccountLoaded;\n\n              case 5:\n                _context9.next = 9;\n                break;\n\n              case 7:\n                _context9.prev = 7;\n                _context9.t0 = _context9[\"catch\"](2);\n\n              case 9:\n                _context9.prev = 9;\n                _context9.next = 12;\n                return this.activePeerLoaded;\n\n              case 12:\n                _context9.next = 16;\n                break;\n\n              case 14:\n                _context9.prev = 14;\n                _context9.t1 = _context9[\"catch\"](9);\n\n              case 16:\n                this._initPromise = new Promise(function (resolve) {\n                  return __awaiter(_this3, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n                    var _this4 = this;\n\n                    var activeAccount, stopListening, origin, p2pTransport, postMessageTransport;\n                    return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n                      while (1) {\n                        switch (_context8.prev = _context8.next) {\n                          case 0:\n                            if (!transport) {\n                              _context8.next = 10;\n                              break;\n                            }\n\n                            _context8.next = 3;\n                            return this.addListener(transport);\n\n                          case 3:\n                            _context8.t0 = resolve;\n                            _context8.next = 6;\n                            return _super.init.call(this, transport);\n\n                          case 6:\n                            _context8.t1 = _context8.sent;\n                            (0, _context8.t0)(_context8.t1);\n                            _context8.next = 60;\n                            break;\n\n                          case 10:\n                            if (!this._transport.isSettled()) {\n                              _context8.next = 27;\n                              break;\n                            }\n\n                            _context8.next = 13;\n                            return this.transport;\n\n                          case 13:\n                            _context8.next = 15;\n                            return _context8.sent.connect();\n\n                          case 15:\n                            _context8.t2 = resolve;\n                            _context8.t3 = _super.init;\n                            _context8.t4 = this;\n                            _context8.next = 20;\n                            return this.transport;\n\n                          case 20:\n                            _context8.t5 = _context8.sent;\n                            _context8.next = 23;\n                            return _context8.t3.call.call(_context8.t3, _context8.t4, _context8.t5);\n\n                          case 23:\n                            _context8.t6 = _context8.sent;\n                            (0, _context8.t2)(_context8.t6);\n                            _context8.next = 60;\n                            break;\n\n                          case 27:\n                            _context8.next = 29;\n                            return this.getActiveAccount();\n\n                          case 29:\n                            activeAccount = _context8.sent;\n\n                            stopListening = function stopListening() {\n                              if (_this4.postMessageTransport) {\n                                _this4.postMessageTransport.stopListeningForNewPeers().catch(console.error);\n                              }\n\n                              if (_this4.p2pTransport) {\n                                _this4.p2pTransport.stopListeningForNewPeers().catch(console.error);\n                              }\n                            };\n\n                            _context8.next = 33;\n                            return this.initInternalTransports();\n\n                          case 33:\n                            if (!(!this.postMessageTransport || !this.p2pTransport)) {\n                              _context8.next = 35;\n                              break;\n                            }\n\n                            return _context8.abrupt(\"return\");\n\n                          case 35:\n                            this.postMessageTransport.connect().then().catch(console.error);\n                            this.p2pTransport.connect().then().catch(console.error);\n\n                            if (!(activeAccount && activeAccount.origin)) {\n                              _context8.next = 55;\n                              break;\n                            }\n\n                            origin = activeAccount.origin.type; // Select the transport that matches the active account\n\n                            if (!(origin === Origin.EXTENSION)) {\n                              _context8.next = 47;\n                              break;\n                            }\n\n                            _context8.t7 = resolve;\n                            _context8.next = 43;\n                            return _super.init.call(this, this.postMessageTransport);\n\n                          case 43:\n                            _context8.t8 = _context8.sent;\n                            (0, _context8.t7)(_context8.t8);\n                            _context8.next = 53;\n                            break;\n\n                          case 47:\n                            if (!(origin === Origin.P2P)) {\n                              _context8.next = 53;\n                              break;\n                            }\n\n                            _context8.t9 = resolve;\n                            _context8.next = 51;\n                            return _super.init.call(this, this.p2pTransport);\n\n                          case 51:\n                            _context8.t10 = _context8.sent;\n                            (0, _context8.t9)(_context8.t10);\n\n                          case 53:\n                            _context8.next = 60;\n                            break;\n\n                          case 55:\n                            p2pTransport = this.p2pTransport;\n                            postMessageTransport = this.postMessageTransport;\n                            postMessageTransport.listenForNewPeer(function (peer) {\n                              logger.log('init', 'postmessage transport peer connected', peer);\n\n                              _this4.events.emit(BeaconEvent.PAIR_SUCCESS, peer).catch(function (emitError) {\n                                return console.warn(emitError);\n                              });\n\n                              _this4.setActivePeer(peer).catch(console.error);\n\n                              _this4.setTransport(_this4.postMessageTransport).catch(console.error);\n\n                              stopListening();\n                              resolve(TransportType.POST_MESSAGE);\n                            }).catch(console.error);\n                            p2pTransport.listenForNewPeer(function (peer) {\n                              logger.log('init', 'p2p transport peer connected', peer);\n\n                              _this4.events.emit(BeaconEvent.PAIR_SUCCESS, peer).catch(function (emitError) {\n                                return console.warn(emitError);\n                              });\n\n                              _this4.setActivePeer(peer).catch(console.error);\n\n                              _this4.setTransport(_this4.p2pTransport).catch(console.error);\n\n                              stopListening();\n                              resolve(TransportType.P2P);\n                            }).catch(console.error);\n                            PostMessageTransport.getAvailableExtensions().then(function () {\n                              return __awaiter(_this4, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n                                var _this5 = this;\n\n                                return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n                                  while (1) {\n                                    switch (_context7.prev = _context7.next) {\n                                      case 0:\n                                        _context7.t0 = this.events;\n                                        _context7.t1 = BeaconEvent.PAIR_INIT;\n                                        _context7.next = 4;\n                                        return p2pTransport.getPairingRequestInfo();\n\n                                      case 4:\n                                        _context7.t2 = _context7.sent;\n                                        _context7.next = 7;\n                                        return postMessageTransport.getPairingRequestInfo();\n\n                                      case 7:\n                                        _context7.t3 = _context7.sent;\n                                        _context7.t4 = this.preferredNetwork;\n\n                                        _context7.t5 = function abortedHandler() {\n                                          _this5._initPromise = undefined;\n                                        };\n\n                                        _context7.t6 = {\n                                          p2pPeerInfo: _context7.t2,\n                                          postmessagePeerInfo: _context7.t3,\n                                          preferredNetwork: _context7.t4,\n                                          abortedHandler: _context7.t5\n                                        };\n\n                                        _context7.t0.emit.call(_context7.t0, _context7.t1, _context7.t6).catch(function (emitError) {\n                                          return console.warn(emitError);\n                                        });\n\n                                      case 12:\n                                      case \"end\":\n                                        return _context7.stop();\n                                    }\n                                  }\n                                }, _callee7, this);\n                              }));\n                            }).catch(function (error) {\n                              _this4._initPromise = undefined;\n                              console.error(error);\n                            });\n\n                          case 60:\n                          case \"end\":\n                            return _context8.stop();\n                        }\n                      }\n                    }, _callee8, this);\n                  }));\n                });\n                return _context9.abrupt(\"return\", this._initPromise);\n\n              case 18:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this, [[2, 7], [9, 14]]);\n      }));\n    }\n    /**\n     * Returns the active account\n     */\n\n  }, {\n    key: \"getActiveAccount\",\n    value: function getActiveAccount() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                return _context10.abrupt(\"return\", this._activeAccount.promise);\n\n              case 1:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n    }\n    /**\n     * Sets the active account\n     *\n     * @param account The account that will be set as the active account\n     */\n\n  }, {\n    key: \"setActiveAccount\",\n    value: function setActiveAccount(account) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee11() {\n        var origin, peer;\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                if (this._activeAccount.isSettled()) {\n                  // If the promise has already been resolved we need to create a new one.\n                  this._activeAccount = ExposedPromise.resolve(account);\n                } else {\n                  this._activeAccount.resolve(account);\n                }\n\n                if (!account) {\n                  _context11.next = 20;\n                  break;\n                }\n\n                origin = account.origin.type;\n                _context11.next = 5;\n                return this.initInternalTransports();\n\n              case 5:\n                if (!(origin === Origin.EXTENSION)) {\n                  _context11.next = 10;\n                  break;\n                }\n\n                _context11.next = 8;\n                return this.setTransport(this.postMessageTransport);\n\n              case 8:\n                _context11.next = 13;\n                break;\n\n              case 10:\n                if (!(origin === Origin.P2P)) {\n                  _context11.next = 13;\n                  break;\n                }\n\n                _context11.next = 13;\n                return this.setTransport(this.p2pTransport);\n\n              case 13:\n                _context11.next = 15;\n                return this.getPeer(account);\n\n              case 15:\n                peer = _context11.sent;\n                _context11.next = 18;\n                return this.setActivePeer(peer);\n\n              case 18:\n                _context11.next = 24;\n                break;\n\n              case 20:\n                _context11.next = 22;\n                return this.setActivePeer(undefined);\n\n              case 22:\n                _context11.next = 24;\n                return this.setTransport(undefined);\n\n              case 24:\n                _context11.next = 26;\n                return this.storage.set(StorageKey.ACTIVE_ACCOUNT, account ? account.accountIdentifier : undefined);\n\n              case 26:\n                _context11.next = 28;\n                return this.events.emit(BeaconEvent.ACTIVE_ACCOUNT_SET, account);\n\n              case 28:\n                return _context11.abrupt(\"return\");\n\n              case 29:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n    }\n    /**\n     * Clear the active account\n     */\n\n  }, {\n    key: \"clearActiveAccount\",\n    value: function clearActiveAccount() {\n      return this.setActiveAccount();\n    }\n  }, {\n    key: \"setColorMode\",\n    value: function setColorMode(colorMode) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee12() {\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                return _context12.abrupt(\"return\", _setColorMode(colorMode));\n\n              case 1:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12);\n      }));\n    }\n  }, {\n    key: \"getColorMode\",\n    value: function getColorMode() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee13() {\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                return _context13.abrupt(\"return\", _getColorMode());\n\n              case 1:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13);\n      }));\n    }\n    /**\n     * @deprecated\n     *\n     * Use getOwnAppMetadata instead\n     */\n\n  }, {\n    key: \"getAppMetadata\",\n    value: function getAppMetadata() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee14() {\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                return _context14.abrupt(\"return\", this.getOwnAppMetadata());\n\n              case 1:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n    }\n    /**\n     * Will remove the account from the local storage and set a new active account if necessary.\n     *\n     * @param accountIdentifier ID of the account\n     */\n\n  }, {\n    key: \"removeAccount\",\n    value: function removeAccount(accountIdentifier) {\n      var _this6 = this;\n\n      var _super = Object.create(null, {\n        removeAccount: {\n          get: function get() {\n            return _get(_getPrototypeOf(DAppClient.prototype), \"removeAccount\", _this6);\n          }\n        }\n      });\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee15() {\n        var removeAccountResult, activeAccount;\n        return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                removeAccountResult = _super.removeAccount.call(this, accountIdentifier);\n                _context15.next = 3;\n                return this.getActiveAccount();\n\n              case 3:\n                activeAccount = _context15.sent;\n\n                if (!(activeAccount && activeAccount.accountIdentifier === accountIdentifier)) {\n                  _context15.next = 7;\n                  break;\n                }\n\n                _context15.next = 7;\n                return this.setActiveAccount(undefined);\n\n              case 7:\n                return _context15.abrupt(\"return\", removeAccountResult);\n\n              case 8:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n    }\n    /**\n     * Remove all accounts and set active account to undefined\n     */\n\n  }, {\n    key: \"removeAllAccounts\",\n    value: function removeAllAccounts() {\n      var _this7 = this;\n\n      var _super = Object.create(null, {\n        removeAllAccounts: {\n          get: function get() {\n            return _get(_getPrototypeOf(DAppClient.prototype), \"removeAllAccounts\", _this7);\n          }\n        }\n      });\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee16() {\n        return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                _context16.next = 2;\n                return _super.removeAllAccounts.call(this);\n\n              case 2:\n                _context16.next = 4;\n                return this.setActiveAccount(undefined);\n\n              case 4:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n    }\n    /**\n     * Removes a peer and all the accounts that have been connected through that peer\n     *\n     * @param peer Peer to be removed\n     */\n\n  }, {\n    key: \"removePeer\",\n    value: function removePeer(peer) {\n      var sendDisconnectToPeer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee17() {\n        var transport, removePeerResult;\n        return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                _context17.next = 2;\n                return this.transport;\n\n              case 2:\n                transport = _context17.sent;\n                removePeerResult = transport.removePeer(peer);\n                _context17.next = 6;\n                return this.removeAccountsForPeers([peer]);\n\n              case 6:\n                if (!sendDisconnectToPeer) {\n                  _context17.next = 9;\n                  break;\n                }\n\n                _context17.next = 9;\n                return this.sendDisconnectToPeer(peer, transport);\n\n              case 9:\n                return _context17.abrupt(\"return\", removePeerResult);\n\n              case 10:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n    }\n    /**\n     * Remove all peers and all accounts that have been connected through those peers\n     */\n\n  }, {\n    key: \"removeAllPeers\",\n    value: function removeAllPeers() {\n      var sendDisconnectToPeers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee18() {\n        var _this8 = this;\n\n        var transport, peers, removePeerResult, disconnectPromises;\n        return _regeneratorRuntime.wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                _context18.next = 2;\n                return this.transport;\n\n              case 2:\n                transport = _context18.sent;\n                _context18.next = 5;\n                return transport.getPeers();\n\n              case 5:\n                peers = _context18.sent;\n                removePeerResult = transport.removeAllPeers();\n                _context18.next = 9;\n                return this.removeAccountsForPeers(peers);\n\n              case 9:\n                if (!sendDisconnectToPeers) {\n                  _context18.next = 13;\n                  break;\n                }\n\n                disconnectPromises = peers.map(function (peer) {\n                  return _this8.sendDisconnectToPeer(peer, transport);\n                });\n                _context18.next = 13;\n                return Promise.all(disconnectPromises);\n\n              case 13:\n                return _context18.abrupt(\"return\", removePeerResult);\n\n              case 14:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this);\n      }));\n    }\n    /**\n     * Allows the user to subscribe to specific events that are fired in the SDK\n     *\n     * @param internalEvent The event to subscribe to\n     * @param eventCallback The callback that will be called when the event occurs\n     */\n\n  }, {\n    key: \"subscribeToEvent\",\n    value: function subscribeToEvent(internalEvent, eventCallback) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee19() {\n        return _regeneratorRuntime.wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                _context19.next = 2;\n                return this.events.on(internalEvent, eventCallback);\n\n              case 2:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, this);\n      }));\n    }\n    /**\n     * Check if we have permissions to send the specific message type to the active account.\n     * If no active account is set, only permission requests are allowed.\n     *\n     * @param type The type of the message\n     */\n\n  }, {\n    key: \"checkPermissions\",\n    value: function checkPermissions(type) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee20() {\n        var activeAccount, permissions;\n        return _regeneratorRuntime.wrap(function _callee20$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                if (!(type === BeaconMessageType.PermissionRequest)) {\n                  _context20.next = 2;\n                  break;\n                }\n\n                return _context20.abrupt(\"return\", true);\n\n              case 2:\n                _context20.next = 4;\n                return this.getActiveAccount();\n\n              case 4:\n                activeAccount = _context20.sent;\n\n                if (activeAccount) {\n                  _context20.next = 9;\n                  break;\n                }\n\n                _context20.next = 8;\n                return this.sendInternalError('No active account set!');\n\n              case 8:\n                throw _context20.sent;\n\n              case 9:\n                permissions = activeAccount.scopes;\n                _context20.t0 = type;\n                _context20.next = _context20.t0 === BeaconMessageType.OperationRequest ? 13 : _context20.t0 === BeaconMessageType.SignPayloadRequest ? 14 : _context20.t0 === BeaconMessageType.BroadcastRequest ? 15 : 16;\n                break;\n\n              case 13:\n                return _context20.abrupt(\"return\", permissions.includes(PermissionScope.OPERATION_REQUEST));\n\n              case 14:\n                return _context20.abrupt(\"return\", permissions.includes(PermissionScope.SIGN));\n\n              case 15:\n                return _context20.abrupt(\"return\", true);\n\n              case 16:\n                return _context20.abrupt(\"return\", false);\n\n              case 17:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n        }, _callee20, this);\n      }));\n    }\n    /**\n     * Send a permission request to the DApp. This should be done as the first step. The wallet will respond\n     * with an publicKey and permissions that were given. The account returned will be set as the \"activeAccount\"\n     * and will be used for the following requests.\n     *\n     * @param input The message details we need to prepare the PermissionRequest message.\n     */\n\n  }, {\n    key: \"requestPermissions\",\n    value: function requestPermissions(input) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee22() {\n        var _this9 = this;\n\n        var request, _yield$this$makeReque, message, connectionInfo, publicKey, address, accountInfo, output;\n\n        return _regeneratorRuntime.wrap(function _callee22$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                _context22.next = 2;\n                return this.getOwnAppMetadata();\n\n              case 2:\n                _context22.t0 = _context22.sent;\n                _context22.t1 = BeaconMessageType.PermissionRequest;\n                _context22.t2 = input && input.network ? input.network : {\n                  type: NetworkType.MAINNET\n                };\n                _context22.t3 = input && input.scopes ? input.scopes : [PermissionScope.OPERATION_REQUEST, PermissionScope.SIGN];\n                request = {\n                  appMetadata: _context22.t0,\n                  type: _context22.t1,\n                  network: _context22.t2,\n                  scopes: _context22.t3\n                };\n                _context22.next = 9;\n                return this.makeRequest(request).catch(function (requestError) {\n                  return __awaiter(_this9, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee21() {\n                    return _regeneratorRuntime.wrap(function _callee21$(_context21) {\n                      while (1) {\n                        switch (_context21.prev = _context21.next) {\n                          case 0:\n                            _context21.next = 2;\n                            return this.handleRequestError(request, requestError);\n\n                          case 2:\n                            throw _context21.sent;\n\n                          case 3:\n                          case \"end\":\n                            return _context21.stop();\n                        }\n                      }\n                    }, _callee21, this);\n                  }));\n                });\n\n              case 9:\n                _yield$this$makeReque = _context22.sent;\n                message = _yield$this$makeReque.message;\n                connectionInfo = _yield$this$makeReque.connectionInfo;\n                // TODO: Migration code. Remove sometime after 1.0.0 release.\n                publicKey = message.publicKey || message.pubkey || message.pubKey;\n                _context22.next = 15;\n                return getAddressFromPublicKey(publicKey);\n\n              case 15:\n                address = _context22.sent;\n                _context22.next = 18;\n                return getAccountIdentifier(address, message.network);\n\n              case 18:\n                _context22.t4 = _context22.sent;\n                _context22.t5 = message.senderId;\n                _context22.t6 = {\n                  type: connectionInfo.origin,\n                  id: connectionInfo.id\n                };\n                _context22.t7 = address;\n                _context22.t8 = publicKey;\n                _context22.t9 = message.network;\n                _context22.t10 = message.scopes;\n                _context22.t11 = message.threshold;\n                _context22.t12 = new Date().getTime();\n                accountInfo = {\n                  accountIdentifier: _context22.t4,\n                  senderId: _context22.t5,\n                  origin: _context22.t6,\n                  address: _context22.t7,\n                  publicKey: _context22.t8,\n                  network: _context22.t9,\n                  scopes: _context22.t10,\n                  threshold: _context22.t11,\n                  connectedAt: _context22.t12\n                };\n                _context22.next = 30;\n                return this.accountManager.addAccount(accountInfo);\n\n              case 30:\n                _context22.next = 32;\n                return this.setActiveAccount(accountInfo);\n\n              case 32:\n                output = Object.assign(Object.assign({}, message), {\n                  address: address,\n                  accountInfo: accountInfo\n                });\n                _context22.t13 = this;\n                _context22.t14 = request;\n                _context22.t15 = accountInfo;\n                _context22.t16 = output;\n                _context22.t17 = this.blockExplorer;\n                _context22.t18 = connectionInfo;\n                _context22.next = 41;\n                return this.getWalletInfo();\n\n              case 41:\n                _context22.t19 = _context22.sent;\n                _context22.t20 = {\n                  account: _context22.t15,\n                  output: _context22.t16,\n                  blockExplorer: _context22.t17,\n                  connectionContext: _context22.t18,\n                  walletInfo: _context22.t19\n                };\n                _context22.next = 45;\n                return _context22.t13.notifySuccess.call(_context22.t13, _context22.t14, _context22.t20);\n\n              case 45:\n                return _context22.abrupt(\"return\", output);\n\n              case 46:\n              case \"end\":\n                return _context22.stop();\n            }\n          }\n        }, _callee22, this);\n      }));\n    }\n    /**\n     * This method will send a \"SignPayloadRequest\" to the wallet. This method is meant to be used to sign\n     * arbitrary data (eg. a string). It will return the signature in the format of \"edsig...\"\n     *\n     * @param input The message details we need to prepare the SignPayloadRequest message.\n     */\n\n  }, {\n    key: \"requestSignPayload\",\n    value: function requestSignPayload(input) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee24() {\n        var _this10 = this;\n\n        var activeAccount, payload, signingType, request, _yield$this$makeReque2, message, connectionInfo;\n\n        return _regeneratorRuntime.wrap(function _callee24$(_context24) {\n          while (1) {\n            switch (_context24.prev = _context24.next) {\n              case 0:\n                if (input.payload) {\n                  _context24.next = 4;\n                  break;\n                }\n\n                _context24.next = 3;\n                return this.sendInternalError('Payload must be provided');\n\n              case 3:\n                throw _context24.sent;\n\n              case 4:\n                _context24.next = 6;\n                return this.getActiveAccount();\n\n              case 6:\n                activeAccount = _context24.sent;\n\n                if (activeAccount) {\n                  _context24.next = 11;\n                  break;\n                }\n\n                _context24.next = 10;\n                return this.sendInternalError('No active account!');\n\n              case 10:\n                throw _context24.sent;\n\n              case 11:\n                payload = input.payload;\n\n                if (!(typeof payload !== 'string')) {\n                  _context24.next = 14;\n                  break;\n                }\n\n                throw new Error('Payload must be a string');\n\n              case 14:\n                signingType = function () {\n                  switch (input.signingType) {\n                    case SigningType.OPERATION:\n                      if (!payload.startsWith('03')) {\n                        throw new Error('When using signing type \"OPERATION\", the payload must start with prefix \"03\"');\n                      }\n\n                      return SigningType.OPERATION;\n\n                    case SigningType.MICHELINE:\n                      if (!payload.startsWith('05')) {\n                        throw new Error('When using signing type \"MICHELINE\", the payload must start with prefix \"05\"');\n                      }\n\n                      return SigningType.MICHELINE;\n\n                    case SigningType.RAW:\n                    default:\n                      return SigningType.RAW;\n                  }\n                }();\n\n                request = {\n                  type: BeaconMessageType.SignPayloadRequest,\n                  signingType: signingType,\n                  payload: payload,\n                  sourceAddress: input.sourceAddress || activeAccount.address\n                };\n                _context24.next = 18;\n                return this.makeRequest(request).catch(function (requestError) {\n                  return __awaiter(_this10, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee23() {\n                    return _regeneratorRuntime.wrap(function _callee23$(_context23) {\n                      while (1) {\n                        switch (_context23.prev = _context23.next) {\n                          case 0:\n                            _context23.next = 2;\n                            return this.handleRequestError(request, requestError);\n\n                          case 2:\n                            throw _context23.sent;\n\n                          case 3:\n                          case \"end\":\n                            return _context23.stop();\n                        }\n                      }\n                    }, _callee23, this);\n                  }));\n                });\n\n              case 18:\n                _yield$this$makeReque2 = _context24.sent;\n                message = _yield$this$makeReque2.message;\n                connectionInfo = _yield$this$makeReque2.connectionInfo;\n                _context24.t0 = this;\n                _context24.t1 = request;\n                _context24.t2 = activeAccount;\n                _context24.t3 = message;\n                _context24.t4 = connectionInfo;\n                _context24.next = 28;\n                return this.getWalletInfo();\n\n              case 28:\n                _context24.t5 = _context24.sent;\n                _context24.t6 = {\n                  account: _context24.t2,\n                  output: _context24.t3,\n                  connectionContext: _context24.t4,\n                  walletInfo: _context24.t5\n                };\n                _context24.next = 32;\n                return _context24.t0.notifySuccess.call(_context24.t0, _context24.t1, _context24.t6);\n\n              case 32:\n                return _context24.abrupt(\"return\", message);\n\n              case 33:\n              case \"end\":\n                return _context24.stop();\n            }\n          }\n        }, _callee24, this);\n      }));\n    }\n    /**\n     * This method sends an OperationRequest to the wallet. This method should be used for all kinds of operations,\n     * eg. transaction or delegation. Not all properties have to be provided. Data like \"counter\" and fees will be\n     * fetched and calculated by the wallet (but they can still be provided if required).\n     *\n     * @param input The message details we need to prepare the OperationRequest message.\n     */\n\n  }, {\n    key: \"requestOperation\",\n    value: function requestOperation(input) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee26() {\n        var _this11 = this;\n\n        var activeAccount, request, _yield$this$makeReque3, message, connectionInfo;\n\n        return _regeneratorRuntime.wrap(function _callee26$(_context26) {\n          while (1) {\n            switch (_context26.prev = _context26.next) {\n              case 0:\n                if (input.operationDetails) {\n                  _context26.next = 4;\n                  break;\n                }\n\n                _context26.next = 3;\n                return this.sendInternalError('Operation details must be provided');\n\n              case 3:\n                throw _context26.sent;\n\n              case 4:\n                _context26.next = 6;\n                return this.getActiveAccount();\n\n              case 6:\n                activeAccount = _context26.sent;\n\n                if (activeAccount) {\n                  _context26.next = 11;\n                  break;\n                }\n\n                _context26.next = 10;\n                return this.sendInternalError('No active account!');\n\n              case 10:\n                throw _context26.sent;\n\n              case 11:\n                request = {\n                  type: BeaconMessageType.OperationRequest,\n                  network: activeAccount.network || {\n                    type: NetworkType.MAINNET\n                  },\n                  operationDetails: input.operationDetails,\n                  sourceAddress: activeAccount.address || ''\n                };\n                _context26.next = 14;\n                return this.makeRequest(request).catch(function (requestError) {\n                  return __awaiter(_this11, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee25() {\n                    return _regeneratorRuntime.wrap(function _callee25$(_context25) {\n                      while (1) {\n                        switch (_context25.prev = _context25.next) {\n                          case 0:\n                            _context25.next = 2;\n                            return this.handleRequestError(request, requestError);\n\n                          case 2:\n                            throw _context25.sent;\n\n                          case 3:\n                          case \"end\":\n                            return _context25.stop();\n                        }\n                      }\n                    }, _callee25, this);\n                  }));\n                });\n\n              case 14:\n                _yield$this$makeReque3 = _context26.sent;\n                message = _yield$this$makeReque3.message;\n                connectionInfo = _yield$this$makeReque3.connectionInfo;\n                _context26.t0 = this;\n                _context26.t1 = request;\n                _context26.t2 = activeAccount;\n                _context26.t3 = message;\n                _context26.t4 = this.blockExplorer;\n                _context26.t5 = connectionInfo;\n                _context26.next = 25;\n                return this.getWalletInfo();\n\n              case 25:\n                _context26.t6 = _context26.sent;\n                _context26.t7 = {\n                  account: _context26.t2,\n                  output: _context26.t3,\n                  blockExplorer: _context26.t4,\n                  connectionContext: _context26.t5,\n                  walletInfo: _context26.t6\n                };\n                _context26.next = 29;\n                return _context26.t0.notifySuccess.call(_context26.t0, _context26.t1, _context26.t7);\n\n              case 29:\n                return _context26.abrupt(\"return\", message);\n\n              case 30:\n              case \"end\":\n                return _context26.stop();\n            }\n          }\n        }, _callee26, this);\n      }));\n    }\n    /**\n     * Sends a \"BroadcastRequest\" to the wallet. This method can be used to inject an already signed transaction\n     * to the network.\n     *\n     * @param input The message details we need to prepare the BroadcastRequest message.\n     */\n\n  }, {\n    key: \"requestBroadcast\",\n    value: function requestBroadcast(input) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee28() {\n        var _this12 = this;\n\n        var network, request, _yield$this$makeReque4, message, connectionInfo;\n\n        return _regeneratorRuntime.wrap(function _callee28$(_context28) {\n          while (1) {\n            switch (_context28.prev = _context28.next) {\n              case 0:\n                if (input.signedTransaction) {\n                  _context28.next = 4;\n                  break;\n                }\n\n                _context28.next = 3;\n                return this.sendInternalError('Signed transaction must be provided');\n\n              case 3:\n                throw _context28.sent;\n\n              case 4:\n                network = input.network || {\n                  type: NetworkType.MAINNET\n                };\n                request = {\n                  type: BeaconMessageType.BroadcastRequest,\n                  network: network,\n                  signedTransaction: input.signedTransaction\n                };\n                _context28.next = 8;\n                return this.makeRequest(request).catch(function (requestError) {\n                  return __awaiter(_this12, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee27() {\n                    return _regeneratorRuntime.wrap(function _callee27$(_context27) {\n                      while (1) {\n                        switch (_context27.prev = _context27.next) {\n                          case 0:\n                            _context27.next = 2;\n                            return this.handleRequestError(request, requestError);\n\n                          case 2:\n                            throw _context27.sent;\n\n                          case 3:\n                          case \"end\":\n                            return _context27.stop();\n                        }\n                      }\n                    }, _callee27, this);\n                  }));\n                });\n\n              case 8:\n                _yield$this$makeReque4 = _context28.sent;\n                message = _yield$this$makeReque4.message;\n                connectionInfo = _yield$this$makeReque4.connectionInfo;\n                _context28.t0 = this;\n                _context28.t1 = request;\n                _context28.t2 = network;\n                _context28.t3 = message;\n                _context28.t4 = this.blockExplorer;\n                _context28.t5 = connectionInfo;\n                _context28.next = 19;\n                return this.getWalletInfo();\n\n              case 19:\n                _context28.t6 = _context28.sent;\n                _context28.t7 = {\n                  network: _context28.t2,\n                  output: _context28.t3,\n                  blockExplorer: _context28.t4,\n                  connectionContext: _context28.t5,\n                  walletInfo: _context28.t6\n                };\n                _context28.next = 23;\n                return _context28.t0.notifySuccess.call(_context28.t0, _context28.t1, _context28.t7);\n\n              case 23:\n                return _context28.abrupt(\"return\", message);\n\n              case 24:\n              case \"end\":\n                return _context28.stop();\n            }\n          }\n        }, _callee28, this);\n      }));\n    }\n  }, {\n    key: \"setActivePeer\",\n    value: function setActivePeer(peer) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee29() {\n        return _regeneratorRuntime.wrap(function _callee29$(_context29) {\n          while (1) {\n            switch (_context29.prev = _context29.next) {\n              case 0:\n                if (this._activePeer.isSettled()) {\n                  // If the promise has already been resolved we need to create a new one.\n                  this._activePeer = ExposedPromise.resolve(peer);\n                } else {\n                  this._activePeer.resolve(peer);\n                }\n\n                if (!peer) {\n                  _context29.next = 12;\n                  break;\n                }\n\n                _context29.next = 4;\n                return this.initInternalTransports();\n\n              case 4:\n                if (!(peer.type === 'postmessage-pairing-response')) {\n                  _context29.next = 9;\n                  break;\n                }\n\n                _context29.next = 7;\n                return this.setTransport(this.postMessageTransport);\n\n              case 7:\n                _context29.next = 12;\n                break;\n\n              case 9:\n                if (!(peer.type === 'p2p-pairing-response')) {\n                  _context29.next = 12;\n                  break;\n                }\n\n                _context29.next = 12;\n                return this.setTransport(this.p2pTransport);\n\n              case 12:\n                _context29.next = 14;\n                return this.storage.set(StorageKey.ACTIVE_PEER, peer ? peer.publicKey : undefined);\n\n              case 14:\n                return _context29.abrupt(\"return\");\n\n              case 15:\n              case \"end\":\n                return _context29.stop();\n            }\n          }\n        }, _callee29, this);\n      }));\n    }\n    /**\n     * A \"setter\" for when the transport needs to be changed.\n     */\n\n  }, {\n    key: \"setTransport\",\n    value: function setTransport(transport) {\n      var _this13 = this;\n\n      var _super = Object.create(null, {\n        setTransport: {\n          get: function get() {\n            return _get(_getPrototypeOf(DAppClient.prototype), \"setTransport\", _this13);\n          }\n        }\n      });\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee30() {\n        return _regeneratorRuntime.wrap(function _callee30$(_context30) {\n          while (1) {\n            switch (_context30.prev = _context30.next) {\n              case 0:\n                if (!transport) {\n                  this._initPromise = undefined;\n                }\n\n                return _context30.abrupt(\"return\", _super.setTransport.call(this, transport));\n\n              case 2:\n              case \"end\":\n                return _context30.stop();\n            }\n          }\n        }, _callee30, this);\n      }));\n    }\n    /**\n     * This method will emit an internal error message.\n     *\n     * @param errorMessage The error message to send.\n     */\n\n  }, {\n    key: \"sendInternalError\",\n    value: function sendInternalError(errorMessage) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee31() {\n        return _regeneratorRuntime.wrap(function _callee31$(_context31) {\n          while (1) {\n            switch (_context31.prev = _context31.next) {\n              case 0:\n                _context31.next = 2;\n                return this.events.emit(BeaconEvent.INTERNAL_ERROR, errorMessage);\n\n              case 2:\n                throw new Error(errorMessage);\n\n              case 3:\n              case \"end\":\n                return _context31.stop();\n            }\n          }\n        }, _callee31, this);\n      }));\n    }\n    /**\n     * This method will remove all accounts associated with a specific peer.\n     *\n     * @param peersToRemove An array of peers for which accounts should be removed\n     */\n\n  }, {\n    key: \"removeAccountsForPeers\",\n    value: function removeAccountsForPeers(peersToRemove) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee32() {\n        var accounts, peerIdsToRemove, accountsToRemove, accountIdentifiersToRemove, activeAccount;\n        return _regeneratorRuntime.wrap(function _callee32$(_context32) {\n          while (1) {\n            switch (_context32.prev = _context32.next) {\n              case 0:\n                _context32.next = 2;\n                return this.accountManager.getAccounts();\n\n              case 2:\n                accounts = _context32.sent;\n                peerIdsToRemove = peersToRemove.map(function (peer) {\n                  return peer.senderId;\n                }); // Remove all accounts with origin of the specified peer\n\n                accountsToRemove = accounts.filter(function (account) {\n                  return peerIdsToRemove.includes(account.senderId);\n                });\n                accountIdentifiersToRemove = accountsToRemove.map(function (accountInfo) {\n                  return accountInfo.accountIdentifier;\n                });\n                _context32.next = 8;\n                return this.accountManager.removeAccounts(accountIdentifiersToRemove);\n\n              case 8:\n                _context32.next = 10;\n                return this.getActiveAccount();\n\n              case 10:\n                activeAccount = _context32.sent;\n\n                if (!activeAccount) {\n                  _context32.next = 15;\n                  break;\n                }\n\n                if (!accountIdentifiersToRemove.includes(activeAccount.accountIdentifier)) {\n                  _context32.next = 15;\n                  break;\n                }\n\n                _context32.next = 15;\n                return this.setActiveAccount(undefined);\n\n              case 15:\n              case \"end\":\n                return _context32.stop();\n            }\n          }\n        }, _callee32, this);\n      }));\n    }\n    /**\n     * This message handles errors that we receive from the wallet.\n     *\n     * @param request The request we sent\n     * @param beaconError The error we received\n     */\n\n  }, {\n    key: \"handleRequestError\",\n    value: function handleRequestError(request, beaconError) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee34() {\n        var _this14 = this;\n\n        var buttons, actionCallback, peer, activeAccount;\n        return _regeneratorRuntime.wrap(function _callee34$(_context34) {\n          while (1) {\n            switch (_context34.prev = _context34.next) {\n              case 0:\n                logger.error('handleRequestError', 'error response', beaconError);\n\n                if (!beaconError.errorType) {\n                  _context34.next = 20;\n                  break;\n                }\n\n                buttons = [];\n\n                if (beaconError.errorType === BeaconErrorType.NO_PRIVATE_KEY_FOUND_ERROR) {\n                  actionCallback = function actionCallback() {\n                    return __awaiter(_this14, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee33() {\n                      var operationRequest, accountInfo, accountIdentifier;\n                      return _regeneratorRuntime.wrap(function _callee33$(_context33) {\n                        while (1) {\n                          switch (_context33.prev = _context33.next) {\n                            case 0:\n                              operationRequest = request; // if the account we requested is not available, we remove it locally\n\n                              if (!(operationRequest.sourceAddress && operationRequest.network)) {\n                                _context33.next = 11;\n                                break;\n                              }\n\n                              _context33.next = 4;\n                              return getAccountIdentifier(operationRequest.sourceAddress, operationRequest.network);\n\n                            case 4:\n                              accountIdentifier = _context33.sent;\n                              _context33.next = 7;\n                              return this.getAccount(accountIdentifier);\n\n                            case 7:\n                              accountInfo = _context33.sent;\n\n                              if (!accountInfo) {\n                                _context33.next = 11;\n                                break;\n                              }\n\n                              _context33.next = 11;\n                              return this.removeAccount(accountInfo.accountIdentifier);\n\n                            case 11:\n                            case \"end\":\n                              return _context33.stop();\n                          }\n                        }\n                      }, _callee33, this);\n                    }));\n                  };\n\n                  buttons.push({\n                    text: 'Remove account',\n                    actionCallback: actionCallback\n                  });\n                }\n\n                _context34.next = 6;\n                return this.getPeer();\n\n              case 6:\n                peer = _context34.sent;\n                _context34.next = 9;\n                return this.getActiveAccount();\n\n              case 9:\n                activeAccount = _context34.sent;\n                _context34.t0 = this.events;\n                _context34.t1 = messageEvents[request.type].error;\n                _context34.t2 = beaconError;\n                _context34.next = 15;\n                return this.getWalletInfo(peer, activeAccount);\n\n              case 15:\n                _context34.t3 = _context34.sent;\n                _context34.t4 = {\n                  errorResponse: _context34.t2,\n                  walletInfo: _context34.t3\n                };\n                _context34.t5 = buttons;\n\n                _context34.t0.emit.call(_context34.t0, _context34.t1, _context34.t4, _context34.t5).catch(function (emitError) {\n                  return logger.error('handleRequestError', emitError);\n                });\n\n                throw BeaconError.getError(beaconError.errorType, beaconError.errorData);\n\n              case 20:\n                throw beaconError;\n\n              case 21:\n              case \"end\":\n                return _context34.stop();\n            }\n          }\n        }, _callee34, this);\n      }));\n    }\n    /**\n     * This message will send an event when we receive a successful response to one of the requests we sent.\n     *\n     * @param request The request we sent\n     * @param response The response we received\n     */\n\n  }, {\n    key: \"notifySuccess\",\n    value: function notifySuccess(request, response) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee35() {\n        return _regeneratorRuntime.wrap(function _callee35$(_context35) {\n          while (1) {\n            switch (_context35.prev = _context35.next) {\n              case 0:\n                this.events.emit(messageEvents[request.type].success, response).catch(function (emitError) {\n                  return console.warn(emitError);\n                });\n\n              case 1:\n              case \"end\":\n                return _context35.stop();\n            }\n          }\n        }, _callee35, this);\n      }));\n    }\n  }, {\n    key: \"getWalletInfo\",\n    value: function getWalletInfo(peer, account) {\n      var _a, _b, _c, _d;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee36() {\n        var selectedAccount, selectedPeer, walletInfo, typedPeer, selectedApp;\n        return _regeneratorRuntime.wrap(function _callee36$(_context36) {\n          while (1) {\n            switch (_context36.prev = _context36.next) {\n              case 0:\n                if (!account) {\n                  _context36.next = 4;\n                  break;\n                }\n\n                _context36.t0 = account;\n                _context36.next = 7;\n                break;\n\n              case 4:\n                _context36.next = 6;\n                return this.getActiveAccount();\n\n              case 6:\n                _context36.t0 = _context36.sent;\n\n              case 7:\n                selectedAccount = _context36.t0;\n\n                if (!peer) {\n                  _context36.next = 12;\n                  break;\n                }\n\n                _context36.t1 = peer;\n                _context36.next = 15;\n                break;\n\n              case 12:\n                _context36.next = 14;\n                return this.getPeer(selectedAccount);\n\n              case 14:\n                _context36.t1 = _context36.sent;\n\n              case 15:\n                selectedPeer = _context36.t1;\n\n                if (!selectedAccount) {\n                  _context36.next = 20;\n                  break;\n                }\n\n                _context36.next = 19;\n                return this.appMetadataManager.getAppMetadata(selectedAccount.senderId);\n\n              case 19:\n                walletInfo = _context36.sent;\n\n              case 20:\n                typedPeer = selectedPeer;\n\n                if (!walletInfo) {\n                  walletInfo = {\n                    name: typedPeer.name,\n                    icon: typedPeer.icon\n                  };\n                } // TODO: Remove once all wallets send the icon?\n\n\n                selectedApp = (_c = (_b = (_a = iOSList.find(function (app) {\n                  return app.name === (walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name);\n                })) !== null && _a !== void 0 ? _a : webList.find(function (app) {\n                  return app.name === (walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name);\n                })) !== null && _b !== void 0 ? _b : desktopList.find(function (app) {\n                  return app.name === (walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name);\n                })) !== null && _c !== void 0 ? _c : extensionList.find(function (app) {\n                  return app.name === (walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name);\n                });\n\n                if (!selectedApp) {\n                  _context36.next = 25;\n                  break;\n                }\n\n                return _context36.abrupt(\"return\", {\n                  name: walletInfo.name,\n                  icon: (_d = walletInfo.icon) !== null && _d !== void 0 ? _d : selectedApp.logo\n                });\n\n              case 25:\n                return _context36.abrupt(\"return\", walletInfo);\n\n              case 26:\n              case \"end\":\n                return _context36.stop();\n            }\n          }\n        }, _callee36, this);\n      }));\n    }\n  }, {\n    key: \"getPeer\",\n    value: function getPeer(account) {\n      var _a, _b, _c, _d;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee37() {\n        var peer, postMessagePeers, p2pPeers, peers;\n        return _regeneratorRuntime.wrap(function _callee37$(_context37) {\n          while (1) {\n            switch (_context37.prev = _context37.next) {\n              case 0:\n                if (!account) {\n                  _context37.next = 32;\n                  break;\n                }\n\n                logger.log('', 'We have an account', account);\n                _context37.next = 4;\n                return (_a = this.postMessageTransport) === null || _a === void 0 ? void 0 : _a.getPeers();\n\n              case 4:\n                _context37.t1 = _b = _context37.sent;\n                _context37.t0 = _context37.t1 !== null;\n\n                if (!_context37.t0) {\n                  _context37.next = 8;\n                  break;\n                }\n\n                _context37.t0 = _b !== void 0;\n\n              case 8:\n                if (!_context37.t0) {\n                  _context37.next = 12;\n                  break;\n                }\n\n                _context37.t2 = _b;\n                _context37.next = 13;\n                break;\n\n              case 12:\n                _context37.t2 = [];\n\n              case 13:\n                postMessagePeers = _context37.t2;\n                _context37.next = 16;\n                return (_c = this.p2pTransport) === null || _c === void 0 ? void 0 : _c.getPeers();\n\n              case 16:\n                _context37.t4 = _d = _context37.sent;\n                _context37.t3 = _context37.t4 !== null;\n\n                if (!_context37.t3) {\n                  _context37.next = 20;\n                  break;\n                }\n\n                _context37.t3 = _d !== void 0;\n\n              case 20:\n                if (!_context37.t3) {\n                  _context37.next = 24;\n                  break;\n                }\n\n                _context37.t5 = _d;\n                _context37.next = 25;\n                break;\n\n              case 24:\n                _context37.t5 = [];\n\n              case 25:\n                p2pPeers = _context37.t5;\n                peers = [].concat(_toConsumableArray(postMessagePeers), _toConsumableArray(p2pPeers));\n                logger.log('', 'Found peers', peers, account);\n                peer = peers.find(function (peerEl) {\n                  return peerEl.senderId === account.senderId;\n                });\n\n                if (!peer) {\n                  // We could not find an exact match for a sender, so we most likely received it over a relay\n                  peer = peers.find(function (peerEl) {\n                    return peerEl.extensionId === account.origin.id;\n                  });\n                }\n\n                _context37.next = 36;\n                break;\n\n              case 32:\n                _context37.next = 34;\n                return this._activePeer.promise;\n\n              case 34:\n                peer = _context37.sent;\n                logger.log('', 'Active peer', peer);\n\n              case 36:\n                if (peer) {\n                  _context37.next = 38;\n                  break;\n                }\n\n                throw new Error('No matching peer found.');\n\n              case 38:\n                return _context37.abrupt(\"return\", peer);\n\n              case 39:\n              case \"end\":\n                return _context37.stop();\n            }\n          }\n        }, _callee37, this);\n      }));\n    }\n    /**\n     * This method handles sending of requests to the DApp. It makes sure that the DAppClient is initialized and connected\n     * to the transport. After that rate limits and permissions will be checked, an ID is attached and the request is sent\n     * to the DApp over the transport.\n     *\n     * @param requestInput The BeaconMessage to be sent to the wallet\n     * @param account The account that the message will be sent to\n     */\n\n  }, {\n    key: \"makeRequest\",\n    value: function makeRequest(requestInput) {\n      var _a;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee39() {\n        var _this15 = this;\n\n        var messageId, request, exposed, payload, account, peer, walletInfo;\n        return _regeneratorRuntime.wrap(function _callee39$(_context39) {\n          while (1) {\n            switch (_context39.prev = _context39.next) {\n              case 0:\n                _context39.next = 2;\n                return generateGUID();\n\n              case 2:\n                messageId = _context39.sent;\n                console.time(messageId);\n                logger.log('makeRequest', 'starting');\n                _context39.next = 7;\n                return this.init();\n\n              case 7:\n                console.timeLog(messageId, 'init done');\n                logger.log('makeRequest', 'after init');\n                _context39.next = 11;\n                return this.addRequestAndCheckIfRateLimited();\n\n              case 11:\n                if (!_context39.sent) {\n                  _context39.next = 14;\n                  break;\n                }\n\n                this.events.emit(BeaconEvent.LOCAL_RATE_LIMIT_REACHED).catch(function (emitError) {\n                  return console.warn(emitError);\n                });\n                throw new Error('rate limit reached');\n\n              case 14:\n                _context39.next = 16;\n                return this.checkPermissions(requestInput.type);\n\n              case 16:\n                if (_context39.sent) {\n                  _context39.next = 19;\n                  break;\n                }\n\n                this.events.emit(BeaconEvent.NO_PERMISSIONS).catch(function (emitError) {\n                  return console.warn(emitError);\n                });\n                throw new Error('No permissions to send this request to wallet!');\n\n              case 19:\n                if (this.beaconId) {\n                  _context39.next = 23;\n                  break;\n                }\n\n                _context39.next = 22;\n                return this.sendInternalError('BeaconID not defined');\n\n              case 22:\n                throw _context39.sent;\n\n              case 23:\n                _context39.t0 = Object;\n                _context39.t1 = messageId;\n                _context39.t2 = BEACON_VERSION;\n                _context39.t3 = getSenderId;\n                _context39.next = 29;\n                return this.beaconId;\n\n              case 29:\n                _context39.t4 = _context39.sent;\n                _context39.next = 32;\n                return (0, _context39.t3)(_context39.t4);\n\n              case 32:\n                _context39.t5 = _context39.sent;\n                _context39.t6 = {\n                  id: _context39.t1,\n                  version: _context39.t2,\n                  senderId: _context39.t5\n                };\n                _context39.t7 = requestInput;\n                request = _context39.t0.assign.call(_context39.t0, _context39.t6, _context39.t7);\n                exposed = new ExposedPromise();\n                this.addOpenRequest(request.id, exposed);\n                _context39.next = 40;\n                return new Serializer().serialize(request);\n\n              case 40:\n                payload = _context39.sent;\n                _context39.next = 43;\n                return this.getActiveAccount();\n\n              case 43:\n                account = _context39.sent;\n                _context39.next = 46;\n                return this.getPeer(account);\n\n              case 46:\n                peer = _context39.sent;\n                _context39.next = 49;\n                return this.getWalletInfo(peer, account);\n\n              case 49:\n                walletInfo = _context39.sent;\n                logger.log('makeRequest', 'sending message', request);\n                console.timeLog(messageId, 'sending');\n                _context39.next = 54;\n                return this.transport;\n\n              case 54:\n                _context39.next = 56;\n                return _context39.sent.send(payload, peer);\n\n              case 56:\n                console.timeLog(messageId, 'sent');\n                this.events.emit(messageEvents[requestInput.type].sent, {\n                  walletInfo: {\n                    name: (_a = walletInfo.name) !== null && _a !== void 0 ? _a : 'Wallet',\n                    icon: walletInfo.icon\n                  },\n                  extraInfo: {\n                    resetCallback: function resetCallback() {\n                      return __awaiter(_this15, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee38() {\n                        return _regeneratorRuntime.wrap(function _callee38$(_context38) {\n                          while (1) {\n                            switch (_context38.prev = _context38.next) {\n                              case 0:\n                                _context38.t0 = Promise;\n                                _context38.t1 = this.clearActiveAccount();\n                                _context38.next = 4;\n                                return this.transport;\n\n                              case 4:\n                                _context38.t2 = _context38.sent.disconnect();\n                                _context38.t3 = [_context38.t1, _context38.t2];\n                                _context38.next = 8;\n                                return _context38.t0.all.call(_context38.t0, _context38.t3);\n\n                              case 8:\n                              case \"end\":\n                                return _context38.stop();\n                            }\n                          }\n                        }, _callee38, this);\n                      }));\n                    }\n                  }\n                }).catch(function (emitError) {\n                  return console.warn(emitError);\n                }); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n                return _context39.abrupt(\"return\", exposed.promise);\n\n              case 59:\n              case \"end\":\n                return _context39.stop();\n            }\n          }\n        }, _callee39, this);\n      }));\n    }\n    /**\n     * Adds a requests to the \"openRequests\" set so we know what messages have already been answered/handled.\n     *\n     * @param id The ID of the message\n     * @param promise A promise that resolves once the response for that specific message is received\n     */\n\n  }, {\n    key: \"addOpenRequest\",\n    value: function addOpenRequest(id, promise) {\n      logger.log('addOpenRequest', this.name, \"adding request \".concat(id, \" and waiting for answer\"));\n      this.openRequests.set(id, promise);\n    }\n  }]);\n\n  return DAppClient;\n}(Client);","map":{"version":3,"sources":["../../../../src/clients/dapp-client/DAppClient.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAAS,cAAT,QAA+B,6BAA/B;AAEA,SAAS,MAAT,QAAuB,oBAAvB;AACA,SAAS,YAAT,QAA6B,2BAA7B;AACA,SAAS,WAAT,QAAqF,cAArF;AACA,SAAS,cAAT,QAA+B,iBAA/B;AACA,SAAS,uBAAT,QAAwC,oBAAxC;AAEA,SAEE,MAFF,EAGE,aAHF,EAIE,UAJF,EAKE,iBALF,EAME,eANF,EAQE,WARF,EAsBE,UAtBF,EAuBE,YAvBF,EAkCE,WAlCF,EAmCE,MAnCF,EAoCE,oBApCF,EAuCE,gBAvCF,EAwCE,wBAxCF,EAyCE,WAzCF,EA0CE,kBA1CF,QA4CO,OA5CP;AA6CA,SAAS,aAAT,QAA8B,6BAA9B;AAEA,SAAS,oBAAT,QAAqC,oCAArC;AAEA,SAAS,qBAAT,QAAsC,oCAAtC;AACA,SAAS,eAAT,QAAgC,6BAAhC;AAOA,SAAS,WAAT,QAA4B,2BAA5B;AACA,SAAS,WAAT,QAA4B,gCAA5B;AAEA,SAAS,SAAT,QAA0B,uBAA1B;AACA,SAAS,YAAY,IAAZ,aAAT,EAAuB,YAAY,IAAZ,aAAvB,QAA2C,iBAA3C;AACA,SAAS,WAAT,EAAsB,aAAtB,EAAqC,OAArC,EAA8C,OAA9C,QAA6D,6BAA7D;AAIA,IAAM,MAAM,GAAG,IAAI,MAAJ,CAAW,YAAX,CAAf;AAEA;;;;;;;AAOG;;AACH,WAAa,UAAb;AAAA;;AAAA;;AAuCE,sBAAY,MAAZ,EAAqC;AAAA;;AAAA;;;;AACnC,+BAAK,MAAA,CAAA,MAAA,CAAA;AACH,MAAA,OAAO,EAAE,MAAM,IAAI,MAAM,CAAC,OAAjB,GAA2B,MAAM,CAAC,OAAlC,GAA4C,IAAI,YAAJ;AADlD,KAAA,EAEA,MAFA,CAAL;AA7BF;;AAEG;;AACc,UAAA,YAAA,GAAe,IAAI,GAAJ,EAAf;AAKjB;;;AAGG;;AACK,UAAA,cAAA,GAA0D,IAAI,cAAJ,EAA1D;AAER;;AAEG;;AACK,UAAA,WAAA,GAEJ,IAAI,cAAJ,EAFI;AAgBN,UAAK,aAAL,GAAkB,CAAA,EAAA,GAAG,MAAM,CAAC,aAAV,MAAuB,IAAvB,IAAuB,EAAA,KAAA,KAAA,CAAvB,GAAuB,EAAvB,GAA2B,IAAI,qBAAJ,EAA7C;AACA,UAAK,gBAAL,GAAqB,CAAA,EAAA,GAAG,MAAM,CAAC,gBAAV,MAA0B,IAA1B,IAA0B,EAAA,KAAA,KAAA,CAA1B,GAA0B,EAA1B,GAA8B,WAAW,CAAC,OAA/D;;AACA,IAAA,aAAY,CAAA,CAAA,EAAA,GAAC,MAAM,CAAC,SAAR,MAAiB,IAAjB,IAAiB,EAAA,KAAA,KAAA,CAAjB,GAAiB,EAAjB,GAAqB,SAAS,CAAC,KAA/B,CAAZ;;AAEA,UAAK,kBAAL,GAA0B,IAAI,kBAAJ,CAAuB,MAAK,OAA5B,CAA1B;AAEA,UAAK,mBAAL,GAA2B,MAAK,OAAL,CACxB,GADwB,CACpB,UAAU,CAAC,cADS,EAExB,IAFwB,CAEnB,UAAO,uBAAP;AAAA,aAAkC,SAAA,gCAAA,KAAA,CAAA,EAAA,KAAA,CAAA,wCAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qBAClC,uBADkC;AAAA;AAAA;AAAA;;AAAA,8BAE9B,IAF8B;AAAA;AAER,uBAAM,KAAK,cAAL,CAAoB,UAApB,CAA+B,uBAA/B,CAAN;;AAFQ;AAAA;AAAA;AAEpC,mCAAW,gBAAX;;AAFoC;AAAA;AAAA;;AAAA;AAAA;AAIpC,uBAAM,KAAK,gBAAL,CAAsB,SAAtB,CAAN;;AAJoC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAA,EAAlC;AAAA,KAFmB,EASxB,KATwB,CASlB,UAAO,YAAP;AAAA,aAAuB,SAAA,gCAAA,KAAA,CAAA,EAAA,KAAA,CAAA,wCAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC5B,uBAAM,KAAK,gBAAL,CAAsB,SAAtB,CAAN;;AAD4B;AAE5B,gBAAA,OAAO,CAAC,KAAR,CAAc,YAAd;;AAF4B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAA,EAAvB;AAAA,KATkB,CAA3B;AAcA,UAAK,gBAAL,GAAwB,MAAK,OAAL,CACrB,GADqB,CACjB,UAAU,CAAC,WADM,EAErB,IAFqB,CAEhB,UAAO,mBAAP;AAAA,aAA8B,SAAA,gCAAA,KAAA,CAAA,EAAA,KAAA,CAAA,wCAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,qBAC9B,mBAD8B;AAAA;AAAA;AAAA;;AAE1B,gBAAA,cAF0B,GAET,IAAI,WAAJ,CAAgB,KAAK,OAArB,EAA8B,UAAU,CAAC,wBAAzC,CAFS;AAG1B,gBAAA,sBAH0B,GAGD,IAAI,WAAJ,CAC7B,KAAK,OADwB,EAE7B,UAAU,CAAC,gCAFkB,CAHC;AAAA;AAQ7B,uBAAM,cAAc,CAAC,OAAf,CAAuB,mBAAvB,CAAN;;AAR6B;AAAA,+BAOtB,EAPsB;AAAA,gDAQqB,IARrB;;AAAA;AAAA;AAAA;AAAA;;AAAA,+BAQqB,EAAA,KAAA,KAAA,CARrB;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,+BAQqB,EARrB;AAAA;AAAA;;AAAA;AAAA;AAS7B,uBAAM,sBAAsB,CAAC,OAAvB,CAA+B,mBAA/B,CAAN;;AAT6B;AAAA;;AAAA;AAO1B,gBAAA,IAP0B;AAAA;AAUhC,uBAAM,KAAK,aAAL,CAAmB,IAAnB,CAAN;;AAVgC;AAAA;AAAA;;AAAA;AAAA;AAYhC,uBAAM,KAAK,aAAL,CAAmB,SAAnB,CAAN;;AAZgC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAA,EAA9B;AAAA,KAFgB,EAiBrB,KAjBqB,CAiBf,UAAO,YAAP;AAAA,aAAuB,SAAA,gCAAA,KAAA,CAAA,EAAA,KAAA,CAAA,wCAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC5B,uBAAM,KAAK,gBAAL,CAAsB,SAAtB,CAAN;;AAD4B;AAE5B,gBAAA,MAAM,CAAC,KAAP,CAAa,YAAb;;AAF4B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAA,EAAvB;AAAA,KAjBe,CAAxB;;AAsBA,UAAK,cAAL,GAAsB,UACpB,OADoB,EAEpB,cAFoB;AAAA,aAGH,SAAA,gCAAA,KAAA,CAAA,EAAA,KAAA,CAAA,wCAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACX,gBAAA,WADW,GACG,KAAK,YAAL,CAAkB,GAAlB,CAAsB,OAAO,CAAC,EAA9B,CADH;AAGjB,gBAAA,MAAM,CAAC,GAAP,CAAW,gBAAX,EAA6B,kBAA7B,EAAiD,OAAjD,EAA0D,cAA1D;;AAHiB,sBAKb,WAAW,IAAI,OAAO,CAAC,IAAR,KAAiB,iBAAiB,CAAC,WALrC;AAAA;AAAA;AAAA;;AAMf,gBAAA,MAAM,CAAC,GAAP,4CAA+C,OAAO,CAAC,EAAvD;AACA,gBAAA,OAAO,CAAC,OAAR,CAAgB,OAAO,CAAC,EAAxB,EAA4B,aAA5B;AAPe,+BASf,KAAK,MATU;AAAA,+BAUP,WAAW,CAAC,oBAVL;AAAA,+BAWX,OAXW;AAAA,+BAYA,EAZA;AAAA;AAaC,uBAAM,KAAK,aAAL,EAAN;;AAbD;AAAA;AAAA;AAWX,kBAAA,OAXW;AAYX,kBAAA,SAZW;AAaX,kBAAA,UAbW;AAAA;;AAAA,6BAUZ,IAVY,gDAeZ,KAfY,CAeN,OAAO,CAAC,KAfF;;AAAA;AAAA;;AAAA;AAAA,qBAgBN,WAhBM;AAAA;AAAA;AAAA;;AAAA,sBAiBX,OAAO,CAAC,IAAR,KAAiB,iBAAiB,CAAC,kBAAnC,IAAyD,OAAO,CAAC,WAjBtD;AAAA;AAAA;AAAA;;AAAA;AAkBb,uBAAM,KAAK,kBAAL,CAAwB,cAAxB,CAAuC,OAAO,CAAC,WAA/C,CAAN;;AAlBa;AAqBf,gBAAA,OAAO,CAAC,OAAR,CAAgB,OAAO,CAAC,EAAxB,EAA4B,UAA5B;AACA,gBAAA,OAAO,CAAC,OAAR,CAAgB,OAAO,CAAC,EAAxB;;AAEA,oBAAI,OAAO,CAAC,IAAR,KAAiB,iBAAiB,CAAC,KAAnC,IAA6C,OAAe,CAAC,SAAjE,EAA4E;AAC1E;AACA,kBAAA,WAAW,CAAC,MAAZ,CAAmB,OAAnB;AACD,iBAHD,MAGO;AACL,kBAAA,WAAW,CAAC,OAAZ,CAAoB;AAAE,oBAAA,OAAO,EAAP,OAAF;AAAW,oBAAA,cAAc,EAAd;AAAX,mBAApB;AACD;;AACD,qBAAK,YAAL,CAAkB,MAAlB,CAAyB,OAAO,CAAC,EAAjC;AA9Be;AAAA;;AAAA;AAAA,sBAgCX,OAAO,CAAC,IAAR,KAAiB,iBAAiB,CAAC,UAhCxB;AAAA;AAAA;AAAA;;AAAA,sBAkCX,cAAc,CAAC,MAAf,KAA0B,MAAM,CAAC,GAlCtB;AAAA;AAAA;AAAA;;AAAA,+BAmCP,KAAK,YAnCE;AAAA;AAAA;;AAAA;AAAA,sBAoCR,CAAA,EAAA,GAAC,KAAK,oBAAN,MAA0B,IAA1B,IAA0B,EAAA,KAAA,KAAA,CApClB;AAAA;AAAA;AAAA;;AAAA,+BAoCkB,EApClB;AAAA;AAAA;;AAAA;AAAA;AAoCuB,uBAAM,KAAK,SAAX;;AApCvB;AAAA;;AAAA;AAAA;;AAAA;AAiCP,gBAAA,iBAjCO;;AAAA,qBAsCT,iBAtCS;AAAA;AAAA;AAAA;;AAAA;AAwCuB,uBAAM,iBAAiB,CAAC,QAAlB,EAAN;;AAxCvB;AAwCL,gBAAA,KAxCK;AAyCL,gBAAA,IAzCK,GAyCgC,KAAK,CAAC,IAAN,CACzC,UAAC,MAAD;AAAA,yBAAY,MAAM,CAAC,QAAP,KAAoB,OAAO,CAAC,QAAxC;AAAA,iBADyC,CAzChC;;AAAA,qBA4CP,IA5CO;AAAA;AAAA;AAAA;;AAAA;AA6CT,uBAAM,iBAAiB,CAAC,UAAlB,CAA6B,IAA7B,CAAN;;AA7CS;AAAA;AA8CT,uBAAM,KAAK,sBAAL,CAA4B,CAAC,IAAD,CAA5B,CAAN;;AA9CS;AAAA;AA+CT,uBAAM,KAAK,MAAL,CAAY,IAAZ,CAAiB,WAAW,CAAC,cAA7B,CAAN;;AA/CS;AAAA;AAAA;;AAAA;AAiDT,gBAAA,MAAM,CAAC,KAAP,CAAa,kBAAb,EAAiC,gCAAjC,EAAmE,OAAO,CAAC,QAA3E;;AAjDS;AAAA;AAAA;;AAAA;AAqDb,gBAAA,MAAM,CAAC,KAAP,CAAa,gBAAb,EAA+B,0BAA/B,EAA2D,OAAO,CAAC,EAAnE;;AArDa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAA,EAHG;AAAA,KAAtB;;AA/CmC;AA2GpC;;AAlJH;AAAA;AAAA,WAoJe,kCAAsB;;;;;;;;AACjB,uBAAM,KAAK,OAAX;;;AAAV,gBAAA,O;;sBAEF,KAAK,oBAAL,IAA6B,KAAK,Y;;;;;;;;AAItC,qBAAK,oBAAL,GAA4B,IAAI,wBAAJ,CAA6B,KAAK,IAAlC,EAAwC,OAAxC,EAAiD,KAAK,OAAtD,CAA5B;;AACA,uBAAM,KAAK,WAAL,CAAiB,KAAK,oBAAtB,CAAN;;;AAEA,qBAAK,YAAL,GAAoB,IAAI,gBAAJ,CAClB,KAAK,IADa,EAElB,OAFkB,EAGlB,KAAK,OAHa,EAIlB,KAAK,WAJa,EAKlB,KAAK,OALa,EAMlB,KAAK,MANa,CAApB;;AAQA,uBAAM,KAAK,WAAL,CAAiB,KAAK,YAAtB,CAAN;;;;;;;;;AACD;AAvKH;AAAA;AAAA,WAyKe,cAAK,SAAL,EAA+B;AAAA;;;;;;;;;;;;;;;;;qBACtC,KAAK,Y;;;;;kDACA,KAAK,Y;;;;;AAIZ,uBAAM,KAAK,mBAAX;;;;;;;;;;;;;AAKA,uBAAM,KAAK,gBAAX;;;;;;;;;;;AAKF,qBAAK,YAAL,GAAoB,IAAI,OAAJ,CAAY,UAAO,OAAP;AAAA,yBAAkB,SAAA,CAAA,MAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,wCAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iCAC5C,SAD4C;AAAA;AAAA;AAAA;;AAAA;AAE9C,mCAAM,KAAK,WAAL,CAAiB,SAAjB,CAAN;;AAF8C;AAAA,2CAI9C,OAJ8C;AAAA;AAItC,mCAAM,MAAA,CAAM,IAAN,CAAU,IAAV,CAAU,IAAV,EAAW,SAAX,CAAN;;AAJsC;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA,iCAKrC,KAAK,UAAL,CAAgB,SAAhB,EALqC;AAAA;AAAA;AAAA;;AAAA;AAMvC,mCAAM,KAAK,SAAX;;AANuC;AAAA;AAM9C,kDAA6B,OAA7B;;AAN8C;AAAA,2CAQ9C,OAR8C;AAAA,2CAQhC,MAAA,CAAM,IAR0B;AAAA,2CAQtB,IARsB;AAAA;AAQrB,mCAAM,KAAK,SAAX;;AARqB;AAAA;AAAA;AAQtC,gDAAgB,IAAhB;;AARsC;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAUxB,mCAAM,KAAK,gBAAL,EAAN;;AAVwB;AAUxC,4BAAA,aAVwC;;AAYxC,4BAAA,aAZwC,GAYxB,SAAhB,aAAgB,GAAK;AACzB,kCAAI,MAAI,CAAC,oBAAT,EAA+B;AAC7B,gCAAA,MAAI,CAAC,oBAAL,CAA0B,wBAA1B,GAAqD,KAArD,CAA2D,OAAO,CAAC,KAAnE;AACD;;AACD,kCAAI,MAAI,CAAC,YAAT,EAAuB;AACrB,gCAAA,MAAI,CAAC,YAAL,CAAkB,wBAAlB,GAA6C,KAA7C,CAAmD,OAAO,CAAC,KAA3D;AACD;AACF,6BAnB6C;;AAAA;AAqB9C,mCAAM,KAAK,sBAAL,EAAN;;AArB8C;AAAA,kCAuB1C,CAAC,KAAK,oBAAN,IAA8B,CAAC,KAAK,YAvBM;AAAA;AAAA;AAAA;;AAAA;;AAAA;AA2B9C,iCAAK,oBAAL,CAA0B,OAA1B,GAAoC,IAApC,GAA2C,KAA3C,CAAiD,OAAO,CAAC,KAAzD;AACA,iCAAK,YAAL,CAAkB,OAAlB,GAA4B,IAA5B,GAAmC,KAAnC,CAAyC,OAAO,CAAC,KAAjD;;AA5B8C,kCA8B1C,aAAa,IAAI,aAAa,CAAC,MA9BW;AAAA;AAAA;AAAA;;AA+BtC,4BAAA,MA/BsC,GA+B7B,aAAa,CAAC,MAAd,CAAqB,IA/BQ,EAgC5C;;AAhC4C,kCAiCxC,MAAM,KAAK,MAAM,CAAC,SAjCsB;AAAA;AAAA;AAAA;;AAAA,2CAkC1C,OAlC0C;AAAA;AAkClC,mCAAM,MAAA,CAAM,IAAN,CAAU,IAAV,CAAU,IAAV,EAAW,KAAK,oBAAhB,CAAN;;AAlCkC;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA,kCAmCjC,MAAM,KAAK,MAAM,CAAC,GAnCe;AAAA;AAAA;AAAA;;AAAA,2CAoC1C,OApC0C;AAAA;AAoClC,mCAAM,MAAA,CAAM,IAAN,CAAU,IAAV,CAAU,IAAV,EAAW,KAAK,YAAhB,CAAN;;AApCkC;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAuCtC,4BAAA,YAvCsC,GAuCvB,KAAK,YAvCkB;AAwCtC,4BAAA,oBAxCsC,GAwCf,KAAK,oBAxCU;AA0C5C,4BAAA,oBAAoB,CACjB,gBADH,CACoB,UAAC,IAAD,EAAS;AACzB,8BAAA,MAAM,CAAC,GAAP,CAAW,MAAX,EAAmB,sCAAnB,EAA2D,IAA3D;;AACA,8BAAA,MAAI,CAAC,MAAL,CACG,IADH,CACQ,WAAW,CAAC,YADpB,EACkC,IADlC,EAEG,KAFH,CAES,UAAC,SAAD;AAAA,uCAAe,OAAO,CAAC,IAAR,CAAa,SAAb,CAAf;AAAA,+BAFT;;AAIA,8BAAA,MAAI,CAAC,aAAL,CAAmB,IAAnB,EAAyB,KAAzB,CAA+B,OAAO,CAAC,KAAvC;;AACA,8BAAA,MAAI,CAAC,YAAL,CAAkB,MAAI,CAAC,oBAAvB,EAA6C,KAA7C,CAAmD,OAAO,CAAC,KAA3D;;AACA,8BAAA,aAAa;AACb,8BAAA,OAAO,CAAC,aAAa,CAAC,YAAf,CAAP;AACD,6BAXH,EAYG,KAZH,CAYS,OAAO,CAAC,KAZjB;AAcA,4BAAA,YAAY,CACT,gBADH,CACoB,UAAC,IAAD,EAAS;AACzB,8BAAA,MAAM,CAAC,GAAP,CAAW,MAAX,EAAmB,8BAAnB,EAAmD,IAAnD;;AACA,8BAAA,MAAI,CAAC,MAAL,CACG,IADH,CACQ,WAAW,CAAC,YADpB,EACkC,IADlC,EAEG,KAFH,CAES,UAAC,SAAD;AAAA,uCAAe,OAAO,CAAC,IAAR,CAAa,SAAb,CAAf;AAAA,+BAFT;;AAIA,8BAAA,MAAI,CAAC,aAAL,CAAmB,IAAnB,EAAyB,KAAzB,CAA+B,OAAO,CAAC,KAAvC;;AACA,8BAAA,MAAI,CAAC,YAAL,CAAkB,MAAI,CAAC,YAAvB,EAAqC,KAArC,CAA2C,OAAO,CAAC,KAAnD;;AACA,8BAAA,aAAa;AACb,8BAAA,OAAO,CAAC,aAAa,CAAC,GAAf,CAAP;AACD,6BAXH,EAYG,KAZH,CAYS,OAAO,CAAC,KAZjB;AAcA,4BAAA,oBAAoB,CAAC,sBAArB,GACG,IADH,CACQ;AAAA,qCAAW,SAAA,CAAA,MAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,wCAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,uDACf,KAAK,MADU;AAAA,uDAEP,WAAW,CAAC,SAFL;AAAA;AAGE,+CAAM,YAAY,CAAC,qBAAb,EAAN;;AAHF;AAAA;AAAA;AAIU,+CAAM,oBAAoB,CAAC,qBAArB,EAAN;;AAJV;AAAA;AAAA,uDAKO,KAAK,gBALZ;;AAAA,uDAMK,0BAAK;AACnB,0CAAA,MAAI,CAAC,YAAL,GAAoB,SAApB;AACD,yCARU;;AAAA;AAGX,0CAAA,WAHW;AAIX,0CAAA,mBAJW;AAKX,0CAAA,gBALW;AAMX,0CAAA,cANW;AAAA;;AAAA,qDAEZ,IAFY,gDAUZ,KAVY,CAUN,UAAC,SAAD;AAAA,iDAAe,OAAO,CAAC,IAAR,CAAa,SAAb,CAAf;AAAA,yCAVM;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+BAAA,EAAX;AAAA,6BADR,EAaG,KAbH,CAaS,UAAC,KAAD,EAAU;AACf,8BAAA,MAAI,CAAC,YAAL,GAAoB,SAApB;AACA,8BAAA,OAAO,CAAC,KAAR,CAAc,KAAd;AACD,6BAhBH;;AAtE4C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAA,EAAlB;AAAA,iBAAZ,CAApB;kDA2FO,KAAK,Y;;;;;;;;;AACb;AAED;;AAEG;;AAzRL;AAAA;AAAA,WA0Re,4BAAgB;;;;;;mDACpB,KAAK,cAAL,CAAoB,O;;;;;;;;;AAC5B;AAED;;;;AAIG;;AAlSL;AAAA;AAAA,WAmSe,0BAAiB,OAAjB,EAAsC;;;;;;;AACjD,oBAAI,KAAK,cAAL,CAAoB,SAApB,EAAJ,EAAqC;AACnC;AACA,uBAAK,cAAL,GAAsB,cAAc,CAAC,OAAf,CAAgD,OAAhD,CAAtB;AACD,iBAHD,MAGO;AACL,uBAAK,cAAL,CAAoB,OAApB,CAA4B,OAA5B;AACD;;qBAEG,O;;;;;AACI,gBAAA,M,GAAS,OAAO,CAAC,MAAR,CAAe,I;;AAC9B,uBAAM,KAAK,sBAAL,EAAN;;;sBAGI,MAAM,KAAK,MAAM,CAAC,S;;;;;;AACpB,uBAAM,KAAK,YAAL,CAAkB,KAAK,oBAAvB,CAAN;;;;;;;sBACS,MAAM,KAAK,MAAM,CAAC,G;;;;;;AAC3B,uBAAM,KAAK,YAAL,CAAkB,KAAK,YAAvB,CAAN;;;;AAEW,uBAAM,KAAK,OAAL,CAAa,OAAb,CAAN;;;AAAP,gBAAA,I;;AACN,uBAAM,KAAK,aAAL,CAAmB,IAAnB,CAAN;;;;;;;;AAEA,uBAAM,KAAK,aAAL,CAAmB,SAAnB,CAAN;;;;AACA,uBAAM,KAAK,YAAL,CAAkB,SAAlB,CAAN;;;;AAGF,uBAAM,KAAK,OAAL,CAAa,GAAb,CACJ,UAAU,CAAC,cADP,EAEJ,OAAO,GAAG,OAAO,CAAC,iBAAX,GAA+B,SAFlC,CAAN;;;;AAKA,uBAAM,KAAK,MAAL,CAAY,IAAZ,CAAiB,WAAW,CAAC,kBAA7B,EAAiD,OAAjD,CAAN;;;;;;;;;;;;AAGD;AAED;;AAEG;;AAxUL;AAAA;AAAA,WAyUS,8BAAkB;AACvB,aAAO,KAAK,gBAAL,EAAP;AACD;AA3UH;AAAA;AAAA,WA6Ue,sBAAa,SAAb,EAAiC;;;;;;mDACrC,aAAY,CAAC,SAAD,C;;;;;;;;;AACpB;AA/UH;AAAA;AAAA,WAiVe,wBAAY;;;;;;mDAChB,aAAY,E;;;;;;;;;AACpB;AAED;;;;AAIG;;AAzVL;AAAA;AAAA,WA0Ve,0BAAc;;;;;;mDAClB,KAAK,iBAAL,E;;;;;;;;;AACR;AAED;;;;AAIG;;AAlWL;AAAA;AAAA,WAmWe,uBAAc,iBAAd,EAAuC;AAAA;;;;;;;;;;;;;;;;AAC5C,gBAAA,mB,GAAsB,MAAA,CAAM,aAAN,CAAmB,IAAnB,CAAmB,IAAnB,EAAoB,iBAApB,C;;AACmB,uBAAM,KAAK,gBAAL,EAAN;;;AAAzC,gBAAA,a;;sBAEF,aAAa,IAAI,aAAa,CAAC,iBAAd,KAAoC,iB;;;;;;AACvD,uBAAM,KAAK,gBAAL,CAAsB,SAAtB,CAAN;;;mDAGK,mB;;;;;;;;;AACR;AAED;;AAEG;;AAhXL;AAAA;AAAA,WAiXe,6BAAiB;AAAA;;;;;;;;;;;;;;;;AAC5B,uBAAM,MAAA,CAAM,iBAAN,CAAuB,IAAvB,CAAuB,IAAvB,CAAN;;;;AACA,uBAAM,KAAK,gBAAL,CAAsB,SAAtB,CAAN;;;;;;;;;AACD;AAED;;;;AAIG;;AA1XL;AAAA;AAAA,WA2Xe,oBACX,IADW,EAE0B;AAAA,UAArC,oBAAqC,uEAAL,KAAK;;;;;;;;AAEnB,uBAAM,KAAK,SAAX;;;AAAZ,gBAAA,S;AAEA,gBAAA,gB,GAAmB,SAAS,CAAC,UAAV,CAAqB,IAArB,C;;AAEzB,uBAAM,KAAK,sBAAL,CAA4B,CAAC,IAAD,CAA5B,CAAN;;;qBAEI,oB;;;;;;AACF,uBAAM,KAAK,oBAAL,CAA0B,IAA1B,EAAgC,SAAhC,CAAN;;;mDAGK,gB;;;;;;;;;AACR;AAED;;AAEG;;AA9YL;AAAA;AAAA,WA+Ye,0BAAqD;AAAA,UAAtC,qBAAsC,uEAAL,KAAK;;;;;;;;;;AAC9C,uBAAM,KAAK,SAAX;;;AAAZ,gBAAA,S;;AAE4B,uBAAM,SAAS,CAAC,QAAV,EAAN;;;AAA5B,gBAAA,K;AACA,gBAAA,gB,GAAmB,SAAS,CAAC,cAAV,E;;AAEzB,uBAAM,KAAK,sBAAL,CAA4B,KAA5B,CAAN;;;qBAEI,qB;;;;;AACI,gBAAA,kB,GAAqB,KAAK,CAAC,GAAN,CAAU,UAAC,IAAD;AAAA,yBAAU,MAAI,CAAC,oBAAL,CAA0B,IAA1B,EAAgC,SAAhC,CAAV;AAAA,iBAAV,C;;AAE3B,uBAAM,OAAO,CAAC,GAAR,CAAY,kBAAZ,CAAN;;;mDAGK,gB;;;;;;;;;AACR;AAED;;;;;AAKG;;AAraL;AAAA;AAAA,WAsae,0BACX,aADW,EAEX,aAFW,EAEkD;;;;;;;AAE7D,uBAAM,KAAK,MAAL,CAAY,EAAZ,CAAe,aAAf,EAA8B,aAA9B,CAAN;;;;;;;;;AACD;AAED;;;;;AAKG;;AAlbL;AAAA;AAAA,WAmbe,0BAAiB,IAAjB,EAAwC;;;;;;;sBAC/C,IAAI,KAAK,iBAAiB,CAAC,iB;;;;;mDACtB,I;;;;AAGsC,uBAAM,KAAK,gBAAL,EAAN;;;AAAzC,gBAAA,a;;oBAED,a;;;;;;AACG,uBAAM,KAAK,iBAAL,CAAuB,wBAAvB,CAAN;;;;;;AAGF,gBAAA,W,GAAc,aAAa,CAAC,M;gCAE1B,I;oDACD,iBAAiB,CAAC,gB,0BAElB,iBAAiB,CAAC,kB,0BAElB,iBAAiB,CAAC,gB;;;;mDAHd,WAAW,CAAC,QAAZ,CAAqB,eAAe,CAAC,iBAArC,C;;;mDAEA,WAAW,CAAC,QAAZ,CAAqB,eAAe,CAAC,IAArC,C;;;mDAEA,I;;;mDAEA,K;;;;;;;;;AAEZ;AAED;;;;;;AAMG;;AAldL;AAAA;AAAA,WAmde,4BACX,KADW,EACmB;;;;;;;;;;;AAGf,uBAAM,KAAK,iBAAL,EAAN;;;;gCACP,iBAAiB,CAAC,iB;gCACf,KAAK,IAAI,KAAK,CAAC,OAAf,GAAyB,KAAK,CAAC,OAA/B,GAAyC;AAAE,kBAAA,IAAI,EAAE,WAAW,CAAC;AAApB,iB;gCAEhD,KAAK,IAAI,KAAK,CAAC,MAAf,GACI,KAAK,CAAC,MADV,GAEI,CAAC,eAAe,CAAC,iBAAjB,EAAoC,eAAe,CAAC,IAApD,C;AAPF,gBAAA,O;AACJ,kBAAA,W;AACA,kBAAA,I;AACA,kBAAA,O;AACA,kBAAA,M;;;AAMkC,uBAAM,KAAK,WAAL,CAGxC,OAHwC,EAG/B,KAH+B,CAGzB,UAAO,YAAP;AAAA,yBAAsC,SAAA,CAAA,MAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,wCAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC/C,mCAAM,KAAK,kBAAL,CAAwB,OAAxB,EAAiC,YAAjC,CAAN;;AAD+C;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAA,EAAtC;AAAA,iBAHyB,CAAN;;;;AAA5B,gBAAA,O,yBAAA,O;AAAS,gBAAA,c,yBAAA,c;AAOjB;AACM,gBAAA,S,GAAY,OAAO,CAAC,SAAR,IAAsB,OAAe,CAAC,MAAtC,IAAiD,OAAe,CAAC,M;;AACnE,uBAAM,uBAAuB,CAAC,SAAD,CAA7B;;;AAAV,gBAAA,O;;AAGe,uBAAM,oBAAoB,CAAC,OAAD,EAAU,OAAO,CAAC,OAAlB,CAA1B;;;;gCACT,OAAO,CAAC,Q;gCACV;AACN,kBAAA,IAAI,EAAE,cAAc,CAAC,MADf;AAEN,kBAAA,EAAE,EAAE,cAAc,CAAC;AAFb,iB;gCAIR,O;gCACA,S;gCACS,OAAO,CAAC,O;iCACT,OAAO,CAAC,M;iCACL,OAAO,CAAC,S;iCACN,IAAI,IAAJ,GAAW,OAAX,E;AAZT,gBAAA,W;AACJ,kBAAA,iB;AACA,kBAAA,Q;AACA,kBAAA,M;AAIA,kBAAA,O;AACA,kBAAA,S;AACA,kBAAA,O;AACA,kBAAA,M;AACA,kBAAA,S;AACA,kBAAA,W;;;AAGF,uBAAM,KAAK,cAAL,CAAoB,UAApB,CAA+B,WAA/B,CAAN;;;;AACA,uBAAM,KAAK,gBAAL,CAAsB,WAAtB,CAAN;;;AAEM,gBAAA,M,GAAM,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACP,OADO,CAAA,EACA;AACV,kBAAA,OAAO,EAAP,OADU;AAEV,kBAAA,WAAW,EAAX;AAFU,iBADA,C;iCAMN,I;iCAAmB,O;iCACd,W;iCACT,M;iCACe,KAAK,a;iCACD,c;;AACP,uBAAM,KAAK,aAAL,EAAN;;;;;AAJZ,kBAAA,O;AACA,kBAAA,M;AACA,kBAAA,a;AACA,kBAAA,iB;AACA,kBAAA,U;;;AALF,sCAAW,aAAX;;;mDAQO,M;;;;;;;;;AACR;AAED;;;;;AAKG;;AAnhBL;AAAA;AAAA,WAohBe,4BACX,KADW,EACmB;;;;;;;;;;oBAEzB,KAAK,CAAC,O;;;;;;AACH,uBAAM,KAAK,iBAAL,CAAuB,0BAAvB,CAAN;;;;;;;AAEuC,uBAAM,KAAK,gBAAL,EAAN;;;AAAzC,gBAAA,a;;oBACD,a;;;;;;AACG,uBAAM,KAAK,iBAAL,CAAuB,oBAAvB,CAAN;;;;;;AAGF,gBAAA,O,GAAU,KAAK,CAAC,O;;sBAElB,OAAO,OAAP,KAAmB,Q;;;;;sBACf,IAAI,KAAJ,CAAU,0BAAV,C;;;AAGF,gBAAA,W,GAAe,YAAkB;AACrC,0BAAQ,KAAK,CAAC,WAAd;AACE,yBAAK,WAAW,CAAC,SAAjB;AACE,0BAAI,CAAC,OAAO,CAAC,UAAR,CAAmB,IAAnB,CAAL,EAA+B;AAC7B,8BAAM,IAAI,KAAJ,CACJ,8EADI,CAAN;AAGD;;AAED,6BAAO,WAAW,CAAC,SAAnB;;AAEF,yBAAK,WAAW,CAAC,SAAjB;AACE,0BAAI,CAAC,OAAO,CAAC,UAAR,CAAmB,IAAnB,CAAL,EAA+B;AAC7B,8BAAM,IAAI,KAAJ,CACJ,8EADI,CAAN;AAGD;;AAED,6BAAO,WAAW,CAAC,SAAnB;;AAEF,yBAAK,WAAW,CAAC,GAAjB;AACA;AACE,6BAAO,WAAW,CAAC,GAAnB;AArBJ;AAuBD,iBAxBmB,E;;AA0Bd,gBAAA,O,GAAmC;AACvC,kBAAA,IAAI,EAAE,iBAAiB,CAAC,kBADe;AAEvC,kBAAA,WAAW,EAAX,WAFuC;AAGvC,kBAAA,OAAO,EAAP,OAHuC;AAIvC,kBAAA,aAAa,EAAE,KAAK,CAAC,aAAN,IAAuB,aAAa,CAAC;AAJb,iB;;AAOL,uBAAM,KAAK,WAAL,CAGxC,OAHwC,EAG/B,KAH+B,CAGzB,UAAO,YAAP;AAAA,yBAAsC,SAAA,CAAA,OAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,wCAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC/C,mCAAM,KAAK,kBAAL,CAAwB,OAAxB,EAAiC,YAAjC,CAAN;;AAD+C;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAA,EAAtC;AAAA,iBAHyB,CAAN;;;;AAA5B,gBAAA,O,0BAAA,O;AAAS,gBAAA,c,0BAAA,c;gCAOX,I;gCAAmB,O;gCACd,a;gCACD,O;gCACW,c;;AACP,uBAAM,KAAK,aAAL,EAAN;;;;;AAHZ,kBAAA,O;AACA,kBAAA,M;AACA,kBAAA,iB;AACA,kBAAA,U;;;AAJF,qCAAW,aAAX;;;mDAOO,O;;;;;;;;;AACR;AAED;;;;;;AAMG;;AA7lBL;AAAA;AAAA,WA8lBe,0BAAiB,KAAjB,EAA6C;;;;;;;;;;oBACnD,KAAK,CAAC,gB;;;;;;AACH,uBAAM,KAAK,iBAAL,CAAuB,oCAAvB,CAAN;;;;;;;AAEuC,uBAAM,KAAK,gBAAL,EAAN;;;AAAzC,gBAAA,a;;oBACD,a;;;;;;AACG,uBAAM,KAAK,iBAAL,CAAuB,oBAAvB,CAAN;;;;;;AAGF,gBAAA,O,GAAiC;AACrC,kBAAA,IAAI,EAAE,iBAAiB,CAAC,gBADa;AAErC,kBAAA,OAAO,EAAE,aAAa,CAAC,OAAd,IAAyB;AAAE,oBAAA,IAAI,EAAE,WAAW,CAAC;AAApB,mBAFG;AAGrC,kBAAA,gBAAgB,EAAE,KAAK,CAAC,gBAHa;AAIrC,kBAAA,aAAa,EAAE,aAAa,CAAC,OAAd,IAAyB;AAJH,iB;;AAOH,uBAAM,KAAK,WAAL,CACxC,OADwC,EAExC,KAFwC,CAElC,UAAO,YAAP;AAAA,yBAAsC,SAAA,CAAA,OAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,wCAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACtC,mCAAM,KAAK,kBAAL,CAAwB,OAAxB,EAAiC,YAAjC,CAAN;;AADsC;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAA,EAAtC;AAAA,iBAFkC,CAAN;;;;AAA5B,gBAAA,O,0BAAA,O;AAAS,gBAAA,c,0BAAA,c;gCAMX,I;gCAAmB,O;gCACd,a;gCACD,O;gCACO,KAAK,a;gCACD,c;;AACP,uBAAM,KAAK,aAAL,EAAN;;;;;AAJZ,kBAAA,O;AACA,kBAAA,M;AACA,kBAAA,a;AACA,kBAAA,iB;AACA,kBAAA,U;;;AALF,qCAAW,aAAX;;;mDAQO,O;;;;;;;;;AACR;AAED;;;;;AAKG;;AApoBL;AAAA;AAAA,WAqoBe,0BAAiB,KAAjB,EAA6C;;;;;;;;;;oBACnD,KAAK,CAAC,iB;;;;;;AACH,uBAAM,KAAK,iBAAL,CAAuB,qCAAvB,CAAN;;;;;;AAGF,gBAAA,O,GAAU,KAAK,CAAC,OAAN,IAAiB;AAAE,kBAAA,IAAI,EAAE,WAAW,CAAC;AAApB,iB;AAE3B,gBAAA,O,GAAiC;AACrC,kBAAA,IAAI,EAAE,iBAAiB,CAAC,gBADa;AAErC,kBAAA,OAAO,EAAP,OAFqC;AAGrC,kBAAA,iBAAiB,EAAE,KAAK,CAAC;AAHY,iB;;AAMH,uBAAM,KAAK,WAAL,CACxC,OADwC,EAExC,KAFwC,CAElC,UAAO,YAAP;AAAA,yBAAsC,SAAA,CAAA,OAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,wCAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACtC,mCAAM,KAAK,kBAAL,CAAwB,OAAxB,EAAiC,YAAjC,CAAN;;AADsC;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAA,EAAtC;AAAA,iBAFkC,CAAN;;;;AAA5B,gBAAA,O,0BAAA,O;AAAS,gBAAA,c,0BAAA,c;gCAMX,I;gCAAmB,O;gCACvB,O;gCACQ,O;gCACO,KAAK,a;gCACD,c;;AACP,uBAAM,KAAK,aAAL,EAAN;;;;;AAJZ,kBAAA,O;AACA,kBAAA,M;AACA,kBAAA,a;AACA,kBAAA,iB;AACA,kBAAA,U;;;AALF,qCAAW,aAAX;;;mDAQO,O;;;;;;;;;AACR;AAjqBH;AAAA;AAAA,WAmqBkB,uBACd,IADc,EACwD;;;;;;AAEtE,oBAAI,KAAK,WAAL,CAAiB,SAAjB,EAAJ,EAAkC;AAChC;AACA,uBAAK,WAAL,GAAmB,cAAc,CAAC,OAAf,CAEjB,IAFiB,CAAnB;AAGD,iBALD,MAKO;AACL,uBAAK,WAAL,CAAiB,OAAjB,CAAyB,IAAzB;AACD;;qBAEG,I;;;;;;AACF,uBAAM,KAAK,sBAAL,EAAN;;;sBACI,IAAI,CAAC,IAAL,KAAc,8B;;;;;;AAChB,uBAAM,KAAK,YAAL,CAAkB,KAAK,oBAAvB,CAAN;;;;;;;sBACS,IAAI,CAAC,IAAL,KAAc,sB;;;;;;AACvB,uBAAM,KAAK,YAAL,CAAkB,KAAK,YAAvB,CAAN;;;;AAIJ,uBAAM,KAAK,OAAL,CAAa,GAAb,CAAiB,UAAU,CAAC,WAA5B,EAAyC,IAAI,GAAG,IAAI,CAAC,SAAR,GAAoB,SAAjE,CAAN;;;;;;;;;;;;AAGD;AAED;;AAEG;;AA/rBL;AAAA;AAAA,WAgsBkB,sBAAa,SAAb,EAAuC;AAAA;;;;;;;;;;;;;;;AACrD,oBAAI,CAAC,SAAL,EAAgB;AACd,uBAAK,YAAL,GAAoB,SAApB;AACD;;mDAEM,MAAA,CAAM,YAAN,CAAkB,IAAlB,CAAkB,IAAlB,EAAmB,SAAnB,C;;;;;;;;;AACR;AAED;;;;AAIG;;AA5sBL;AAAA;AAAA,WA6sBgB,2BAAkB,YAAlB,EAAsC;;;;;;;AAClD,uBAAM,KAAK,MAAL,CAAY,IAAZ,CAAiB,WAAW,CAAC,cAA7B,EAA6C,YAA7C,CAAN;;;sBACM,IAAI,KAAJ,CAAU,YAAV,C;;;;;;;;;AACP;AAED;;;;AAIG;;AAttBL;AAAA;AAAA,WAutBgB,gCAAuB,aAAvB,EAAwD;;;;;;;;AACnD,uBAAM,KAAK,cAAL,CAAoB,WAApB,EAAN;;;AAAX,gBAAA,Q;AAEA,gBAAA,e,GAAkB,aAAa,CAAC,GAAd,CAAkB,UAAC,IAAD;AAAA,yBAAU,IAAI,CAAC,QAAf;AAAA,iBAAlB,C,EACxB;;AACM,gBAAA,gB,GAAmB,QAAQ,CAAC,MAAT,CAAgB,UAAC,OAAD;AAAA,yBACvC,eAAe,CAAC,QAAhB,CAAyB,OAAO,CAAC,QAAjC,CADuC;AAAA,iBAAhB,C;AAGnB,gBAAA,0B,GAA6B,gBAAgB,CAAC,GAAjB,CACjC,UAAC,WAAD;AAAA,yBAAiB,WAAW,CAAC,iBAA7B;AAAA,iBADiC,C;;AAGnC,uBAAM,KAAK,cAAL,CAAoB,cAApB,CAAmC,0BAAnC,CAAN;;;;AAG+C,uBAAM,KAAK,gBAAL,EAAN;;;AAAzC,gBAAA,a;;qBAEF,a;;;;;qBACE,0BAA0B,CAAC,QAA3B,CAAoC,aAAa,CAAC,iBAAlD,C;;;;;;AACF,uBAAM,KAAK,gBAAL,CAAsB,SAAtB,CAAN;;;;;;;;;AAGL;AAED;;;;;AAKG;;AAnvBL;AAAA;AAAA,WAovBgB,4BACZ,OADY,EAEZ,WAFY,EAEc;;;;;;;;;AAE1B,gBAAA,MAAM,CAAC,KAAP,CAAa,oBAAb,EAAmC,gBAAnC,EAAqD,WAArD;;qBACI,WAAW,CAAC,S;;;;;AACR,gBAAA,O,GAAyB,E;;AAC/B,oBAAI,WAAW,CAAC,SAAZ,KAA0B,eAAe,CAAC,0BAA9C,EAA0E;AAClE,kBAAA,cADkE,GACjD,SAAjB,cAAiB;AAAA,2BAA0B,SAAA,CAAA,OAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,wCAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACzC,8BAAA,gBADyC,GACC,OADD,EAE/C;;AAF+C,oCAI3C,gBAAgB,CAAC,aAAjB,IAAkC,gBAAgB,CAAC,OAJR;AAAA;AAAA;AAAA;;AAAA;AAKnB,qCAAM,oBAAoB,CAClD,gBAAgB,CAAC,aADiC,EAElD,gBAAgB,CAAC,OAFiC,CAA1B;;AALmB;AAKvC,8BAAA,iBALuC;AAAA;AAS/B,qCAAM,KAAK,UAAL,CAAgB,iBAAhB,CAAN;;AAT+B;AAS7C,8BAAA,WAT6C;;AAAA,mCAWzC,WAXyC;AAAA;AAAA;AAAA;;AAAA;AAY3C,qCAAM,KAAK,aAAL,CAAmB,WAAW,CAAC,iBAA/B,CAAN;;AAZ2C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qBAAA,EAA1B;AAAA,mBADiD;;AAkBxE,kBAAA,OAAO,CAAC,IAAR,CAAa;AAAE,oBAAA,IAAI,EAAE,gBAAR;AAA0B,oBAAA,cAAc,EAAd;AAA1B,mBAAb;AACD;;;AAEY,uBAAM,KAAK,OAAL,EAAN;;;AAAP,gBAAA,I;;AACgB,uBAAM,KAAK,gBAAL,EAAN;;;AAAhB,gBAAA,a;gCAEN,KAAK,M;gCAED,aAAa,CAAC,OAAO,CAAC,IAAT,CAAb,CAA4B,K;gCACX,W;;AAAyB,uBAAM,KAAK,aAAL,CAAmB,IAAnB,EAAyB,aAAzB,CAAN;;;;;AAAxC,kBAAA,a;AAA4B,kBAAA,U;;gCAC9B,O;;8BAHD,I,kEAKA,K,CAAM,UAAC,SAAD;AAAA,yBAAe,MAAM,CAAC,KAAP,CAAa,oBAAb,EAAmC,SAAnC,CAAf;AAAA,iB;;sBAEH,WAAW,CAAC,QAAZ,CAAqB,WAAW,CAAC,SAAjC,EAA4C,WAAW,CAAC,SAAxD,C;;;sBAGF,W;;;;;;;;;AACP;AAED;;;;;AAKG;;AAtyBL;AAAA;AAAA,WAuyBgB,uBACZ,OADY,EAEZ,QAFY,EA4BP;;;;;;AAEL,qBAAK,MAAL,CACG,IADH,CACQ,aAAa,CAAC,OAAO,CAAC,IAAT,CAAb,CAA4B,OADpC,EAC6C,QAD7C,EAEG,KAFH,CAES,UAAC,SAAD;AAAA,yBAAe,OAAO,CAAC,IAAR,CAAa,SAAb,CAAf;AAAA,iBAFT;;;;;;;;;AAGD;AAx0BH;AAAA;AAAA,WA00BgB,uBAAc,IAAd,EAA+B,OAA/B,EAAoD;;;;;;;;;qBACxC,O;;;;;gCAAU,O;;;;;;AAAU,uBAAM,KAAK,gBAAL,EAAN;;;;;;AAAtC,gBAAA,e;;qBAEe,I;;;;;gCAAO,I;;;;;;AAAO,uBAAM,KAAK,OAAL,CAAa,eAAb,CAAN;;;;;;AAA7B,gBAAA,Y;;qBAGF,e;;;;;;AACW,uBAAM,KAAK,kBAAL,CAAwB,cAAxB,CAAuC,eAAe,CAAC,QAAvD,CAAN;;;AAAb,gBAAA,U;;;AAGI,gBAAA,S,GAAwC,Y;;AAE9C,oBAAI,CAAC,UAAL,EAAiB;AACf,kBAAA,UAAU,GAAG;AACX,oBAAA,IAAI,EAAE,SAAS,CAAC,IADL;AAEX,oBAAA,IAAI,EAAE,SAAS,CAAC;AAFL,mBAAb;AAID,iB,CAED;;;AACM,gBAAA,W,GAAW,CAAA,EAAA,GAAA,CAAA,EAAA,GAAA,CAAA,EAAA,GACf,OAAO,CAAC,IAAR,CAAa,UAAC,GAAD;AAAA,yBAAS,GAAG,CAAC,IAAJ,MAAa,UAAU,KAAA,IAAV,IAAA,UAAU,KAAA,KAAA,CAAV,GAAU,KAAA,CAAV,GAAA,UAAU,CAAE,IAAzB,CAAT;AAAA,iBAAb,CADe,MACqC,IADrC,IACqC,EAAA,KAAA,KAAA,CADrC,GACqC,EADrC,GAEf,OAAO,CAAC,IAAR,CAAa,UAAC,GAAD;AAAA,yBAAS,GAAG,CAAC,IAAJ,MAAa,UAAU,KAAA,IAAV,IAAA,UAAU,KAAA,KAAA,CAAV,GAAU,KAAA,CAAV,GAAA,UAAU,CAAE,IAAzB,CAAT;AAAA,iBAAb,CAFe,MAEqC,IAFrC,IAEqC,EAAA,KAAA,KAAA,CAFrC,GAEqC,EAFrC,GAGf,WAAW,CAAC,IAAZ,CAAiB,UAAC,GAAD;AAAA,yBAAS,GAAG,CAAC,IAAJ,MAAa,UAAU,KAAA,IAAV,IAAA,UAAU,KAAA,KAAA,CAAV,GAAU,KAAA,CAAV,GAAA,UAAU,CAAE,IAAzB,CAAT;AAAA,iBAAjB,CAHe,MAGyC,IAHzC,IAGyC,EAAA,KAAA,KAAA,CAHzC,GAGyC,EAHzC,GAIf,aAAa,CAAC,IAAd,CAAmB,UAAC,GAAD;AAAA,yBAAS,GAAG,CAAC,IAAJ,MAAa,UAAU,KAAA,IAAV,IAAA,UAAU,KAAA,KAAA,CAAV,GAAU,KAAA,CAAV,GAAA,UAAU,CAAE,IAAzB,CAAT;AAAA,iBAAnB,C;;qBAEE,W;;;;;mDACK;AACL,kBAAA,IAAI,EAAE,UAAU,CAAC,IADZ;AAEL,kBAAA,IAAI,EAAA,CAAA,EAAA,GAAE,UAAU,CAAC,IAAb,MAAiB,IAAjB,IAAiB,EAAA,KAAA,KAAA,CAAjB,GAAiB,EAAjB,GAAqB,WAAW,CAAC;AAFhC,iB;;;mDAMF,U;;;;;;;;;AACR;AA52BH;AAAA;AAAA,WA82BgB,iBAAQ,OAAR,EAA6B;;;;;;;;;qBAGrC,O;;;;;AACF,gBAAA,MAAM,CAAC,GAAP,CAAW,EAAX,EAAe,oBAAf,EAAqC,OAArC;;AAEG,uBAAA,CAAA,EAAA,GAAM,KAAK,oBAAX,MAA+B,IAA/B,IAA+B,EAAA,KAAA,KAAA,CAA/B,GAA+B,KAAA,CAA/B,GAA+B,EAAA,CAAE,QAAF,EAA/B;;;gCADmB,E;kDACyB,I;;;;;;;gCAAA,EAAA,KAAA,KAAA,C;;;;;;;;gCAAA,E;;;;;gCAAI,E;;;AAD7C,gBAAA,gB;;AAE0C,uBAAA,CAAA,EAAA,GAAM,KAAK,YAAX,MAAuB,IAAvB,IAAuB,EAAA,KAAA,KAAA,CAAvB,GAAuB,KAAA,CAAvB,GAAuB,EAAA,CAAE,QAAF,EAAvB;;;gCAAlC,E;kDAAsE,I;;;;;;;gCAAA,EAAA,KAAA,KAAA,C;;;;;;;;gCAAA,E;;;;;gCAAI,E;;;AAAlF,gBAAA,Q;AACA,gBAAA,K,gCAAY,gB,sBAAqB,Q;AAEvC,gBAAA,MAAM,CAAC,GAAP,CAAW,EAAX,EAAe,aAAf,EAA8B,KAA9B,EAAqC,OAArC;AAEA,gBAAA,IAAI,GAAG,KAAK,CAAC,IAAN,CAAW,UAAC,MAAD;AAAA,yBAAY,MAAM,CAAC,QAAP,KAAoB,OAAO,CAAC,QAAxC;AAAA,iBAAX,CAAP;;AACA,oBAAI,CAAC,IAAL,EAAW;AACT;AACA,kBAAA,IAAI,GAAG,KAAK,CAAC,IAAN,CAAW,UAAC,MAAD;AAAA,2BAAa,MAAc,CAAC,WAAf,KAA+B,OAAO,CAAC,MAAR,CAAe,EAA3D;AAAA,mBAAX,CAAP;AACD;;;;;;;AAEM,uBAAM,KAAK,WAAL,CAAiB,OAAvB;;;AAAP,gBAAA,I;AACA,gBAAA,MAAM,CAAC,GAAP,CAAW,EAAX,EAAe,aAAf,EAA8B,IAA9B;;;oBAGG,I;;;;;sBACG,IAAI,KAAJ,CAAU,yBAAV,C;;;mDAGD,I;;;;;;;;;AACR;AAED;;;;;;;AAOG;;AAl5BL;AAAA;AAAA,WAm5BgB,qBACZ,YADY,EAC4C;;;;;;;;;;;;AAKtC,uBAAM,YAAY,EAAlB;;;AAAZ,gBAAA,S;AACN,gBAAA,OAAO,CAAC,IAAR,CAAa,SAAb;AACA,gBAAA,MAAM,CAAC,GAAP,CAAW,aAAX,EAA0B,UAA1B;;AACA,uBAAM,KAAK,IAAL,EAAN;;;AACA,gBAAA,OAAO,CAAC,OAAR,CAAgB,SAAhB,EAA2B,WAA3B;AACA,gBAAA,MAAM,CAAC,GAAP,CAAW,aAAX,EAA0B,YAA1B;;AAEI,uBAAM,KAAK,+BAAL,EAAN;;;;;;;;AACF,qBAAK,MAAL,CACG,IADH,CACQ,WAAW,CAAC,wBADpB,EAEG,KAFH,CAES,UAAC,SAAD;AAAA,yBAAe,OAAO,CAAC,IAAR,CAAa,SAAb,CAAf;AAAA,iBAFT;sBAIM,IAAI,KAAJ,CAAU,oBAAV,C;;;;AAGF,uBAAM,KAAK,gBAAL,CAAsB,YAAY,CAAC,IAAnC,CAAN;;;;;;;;AACJ,qBAAK,MAAL,CAAY,IAAZ,CAAiB,WAAW,CAAC,cAA7B,EAA6C,KAA7C,CAAmD,UAAC,SAAD;AAAA,yBAAe,OAAO,CAAC,IAAR,CAAa,SAAb,CAAf;AAAA,iBAAnD;sBAEM,IAAI,KAAJ,CAAU,gDAAV,C;;;oBAGH,KAAK,Q;;;;;;AACF,uBAAM,KAAK,iBAAL,CAAuB,sBAAvB,CAAN;;;;;;gCAGK,M;gCAEP,S;gCACK,c;gCACO,W;;AAAY,uBAAM,KAAK,QAAX;;;;;AAAlB;;;;;AAFV,kBAAA,E;AACA,kBAAA,O;AACA,kBAAA,Q;;gCACG,Y;AALC,gBAAA,O,iBAAO,M;AAQP,gBAAA,O,GAAU,IAAI,cAAJ,E;AAKhB,qBAAK,cAAL,CAAoB,OAAO,CAAC,EAA5B,EAAgC,OAAhC;;AAEgB,uBAAM,IAAI,UAAJ,GAAiB,SAAjB,CAA2B,OAA3B,CAAN;;;AAAV,gBAAA,O;;AAEU,uBAAM,KAAK,gBAAL,EAAN;;;AAAV,gBAAA,O;;AAEO,uBAAM,KAAK,OAAL,CAAa,OAAb,CAAN;;;AAAP,gBAAA,I;;AAEa,uBAAM,KAAK,aAAL,CAAmB,IAAnB,EAAyB,OAAzB,CAAN;;;AAAb,gBAAA,U;AAEN,gBAAA,MAAM,CAAC,GAAP,CAAW,aAAX,EAA0B,iBAA1B,EAA6C,OAA7C;AACA,gBAAA,OAAO,CAAC,OAAR,CAAgB,SAAhB,EAA2B,SAA3B;;AACO,uBAAM,KAAK,SAAX;;;;AAAP,uCAA6B,IAA7B,CAAkC,OAAlC,EAA2C,IAA3C;;;AACA,gBAAA,OAAO,CAAC,OAAR,CAAgB,SAAhB,EAA2B,MAA3B;AAEA,qBAAK,MAAL,CACG,IADH,CACQ,aAAa,CAAC,YAAY,CAAC,IAAd,CAAb,CAAiC,IADzC,EAC+C;AAC3C,kBAAA,UAAU,EAAE;AACV,oBAAA,IAAI,EAAA,CAAA,EAAA,GAAE,UAAU,CAAC,IAAb,MAAiB,IAAjB,IAAiB,EAAA,KAAA,KAAA,CAAjB,GAAiB,EAAjB,GAAqB,QADf;AAEV,oBAAA,IAAI,EAAE,UAAU,CAAC;AAFP,mBAD+B;AAK3C,kBAAA,SAAS,EAAE;AACT,oBAAA,aAAa,EAAE;AAAA,6BAAW,SAAA,CAAA,OAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,wCAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gDAClB,OADkB;AAAA,gDACL,KAAK,kBAAL,EADK;AAAA;AACuB,uCAAM,KAAK,SAAX;;AADvB;AAAA,gEAC6C,UAD7C;AAAA;AAAA;AACxB,qDAAc,GAAd;;AADwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAA,EAAX;AAAA;AADN;AALgC,iBAD/C,EAYG,KAZH,CAYS,UAAC,SAAD;AAAA,yBAAe,OAAO,CAAC,IAAR,CAAa,SAAb,CAAf;AAAA,iBAZT,E,CAcA;;mDACO,OAAO,CAAC,O;;;;;;;;;AAChB;AAED;;;;;AAKG;;AAr+BL;AAAA;AAAA,WAs+BU,wBACN,EADM,EAEN,OAFM,EAKL;AAED,MAAA,MAAM,CAAC,GAAP,CAAW,gBAAX,EAA6B,KAAK,IAAlC,2BAA0D,EAA1D;AACA,WAAK,YAAL,CAAkB,GAAlB,CAAsB,EAAtB,EAA0B,OAA1B;AACD;AA/+BH;;AAAA;AAAA,EAAgC,MAAhC","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ExposedPromise } from '../../utils/exposed-promise';\nimport { Logger } from '../../utils/Logger';\nimport { generateGUID } from '../../utils/generate-uuid';\nimport { BeaconEvent } from '../../events';\nimport { BEACON_VERSION } from '../../constants';\nimport { getAddressFromPublicKey } from '../../utils/crypto';\nimport { Client, TransportType, StorageKey, BeaconMessageType, PermissionScope, NetworkType, Serializer, LocalStorage, BeaconError, Origin, PostMessageTransport, DappP2PTransport, DappPostMessageTransport, PeerManager, AppMetadataManager } from '../..';\nimport { messageEvents } from '../../beacon-message-events';\nimport { getAccountIdentifier } from '../../utils/get-account-identifier';\nimport { TezblockBlockExplorer } from '../../utils/tezblock-blockexplorer';\nimport { BeaconErrorType } from '../../types/BeaconErrorType';\nimport { getSenderId } from '../../utils/get-sender-id';\nimport { SigningType } from '../../types/beacon/SigningType';\nimport { ColorMode } from '../../types/ColorMode';\nimport { getColorMode, setColorMode } from '../../colorMode';\nimport { desktopList, extensionList, iOSList, webList } from '../../ui/alert/wallet-lists';\nconst logger = new Logger('DAppClient');\n/**\n * @publicapi\n *\n * The DAppClient has to be used in decentralized applications. It handles all the logic related to connecting to beacon-compatible\n * wallets and sending requests.\n *\n * @category DApp\n */\nexport class DAppClient extends Client {\n    constructor(config) {\n        var _a, _b, _c;\n        super(Object.assign({ storage: config && config.storage ? config.storage : new LocalStorage() }, config));\n        /**\n         * A map of requests that are currently \"open\", meaning we have sent them to a wallet and are still awaiting a response.\n         */\n        this.openRequests = new Map();\n        /**\n         * The currently active account. For all requests that are associated to a specific request (operation request, signing request),\n         * the active account is used to determine the network and destination wallet\n         */\n        this._activeAccount = new ExposedPromise();\n        /**\n         * The currently active peer. This is used to address a peer in case the active account is not set. (Eg. for permission requests)\n         */\n        this._activePeer = new ExposedPromise();\n        this.blockExplorer = (_a = config.blockExplorer) !== null && _a !== void 0 ? _a : new TezblockBlockExplorer();\n        this.preferredNetwork = (_b = config.preferredNetwork) !== null && _b !== void 0 ? _b : NetworkType.MAINNET;\n        setColorMode((_c = config.colorMode) !== null && _c !== void 0 ? _c : ColorMode.LIGHT);\n        this.appMetadataManager = new AppMetadataManager(this.storage);\n        this.activeAccountLoaded = this.storage\n            .get(StorageKey.ACTIVE_ACCOUNT)\n            .then((activeAccountIdentifier) => __awaiter(this, void 0, void 0, function* () {\n            if (activeAccountIdentifier) {\n                yield this.setActiveAccount(yield this.accountManager.getAccount(activeAccountIdentifier));\n            }\n            else {\n                yield this.setActiveAccount(undefined);\n            }\n        }))\n            .catch((storageError) => __awaiter(this, void 0, void 0, function* () {\n            yield this.setActiveAccount(undefined);\n            console.error(storageError);\n        }));\n        this.activePeerLoaded = this.storage\n            .get(StorageKey.ACTIVE_PEER)\n            .then((activePeerPublicKey) => __awaiter(this, void 0, void 0, function* () {\n            var _d;\n            if (activePeerPublicKey) {\n                const p2pPeerManager = new PeerManager(this.storage, StorageKey.TRANSPORT_P2P_PEERS_DAPP);\n                const postmessagePeerManager = new PeerManager(this.storage, StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP);\n                const peer = (_d = (yield p2pPeerManager.getPeer(activePeerPublicKey))) !== null && _d !== void 0 ? _d : (yield postmessagePeerManager.getPeer(activePeerPublicKey));\n                yield this.setActivePeer(peer);\n            }\n            else {\n                yield this.setActivePeer(undefined);\n            }\n        }))\n            .catch((storageError) => __awaiter(this, void 0, void 0, function* () {\n            yield this.setActiveAccount(undefined);\n            logger.error(storageError);\n        }));\n        this.handleResponse = (message, connectionInfo) => __awaiter(this, void 0, void 0, function* () {\n            var _e;\n            const openRequest = this.openRequests.get(message.id);\n            logger.log('handleResponse', 'Received message', message, connectionInfo);\n            if (openRequest && message.type === BeaconMessageType.Acknowledge) {\n                logger.log(`acknowledge message received for ${message.id}`);\n                console.timeLog(message.id, 'acknowledge');\n                this.events\n                    .emit(BeaconEvent.ACKNOWLEDGE_RECEIVED, {\n                    message,\n                    extraInfo: {},\n                    walletInfo: yield this.getWalletInfo()\n                })\n                    .catch(console.error);\n            }\n            else if (openRequest) {\n                if (message.type === BeaconMessageType.PermissionResponse && message.appMetadata) {\n                    yield this.appMetadataManager.addAppMetadata(message.appMetadata);\n                }\n                console.timeLog(message.id, 'response');\n                console.timeEnd(message.id);\n                if (message.type === BeaconMessageType.Error || message.errorType) {\n                    // TODO: Remove \"any\" once we remove support for v1 wallets\n                    openRequest.reject(message);\n                }\n                else {\n                    openRequest.resolve({ message, connectionInfo });\n                }\n                this.openRequests.delete(message.id);\n            }\n            else {\n                if (message.type === BeaconMessageType.Disconnect) {\n                    const relevantTransport = connectionInfo.origin === Origin.P2P\n                        ? this.p2pTransport\n                        : (_e = this.postMessageTransport) !== null && _e !== void 0 ? _e : (yield this.transport);\n                    if (relevantTransport) {\n                        // TODO: Handle removing it from the right transport (if it was received from the non-active transport)\n                        const peers = yield relevantTransport.getPeers();\n                        const peer = peers.find((peerEl) => peerEl.senderId === message.senderId);\n                        if (peer) {\n                            yield relevantTransport.removePeer(peer);\n                            yield this.removeAccountsForPeers([peer]);\n                            yield this.events.emit(BeaconEvent.CHANNEL_CLOSED);\n                        }\n                        else {\n                            logger.error('handleDisconnect', 'cannot find peer for sender ID', message.senderId);\n                        }\n                    }\n                }\n                else {\n                    logger.error('handleResponse', 'no request found for id ', message.id);\n                }\n            }\n        });\n    }\n    initInternalTransports() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const keyPair = yield this.keyPair;\n            if (this.postMessageTransport || this.p2pTransport) {\n                return;\n            }\n            this.postMessageTransport = new DappPostMessageTransport(this.name, keyPair, this.storage);\n            yield this.addListener(this.postMessageTransport);\n            this.p2pTransport = new DappP2PTransport(this.name, keyPair, this.storage, this.matrixNodes, this.iconUrl, this.appUrl);\n            yield this.addListener(this.p2pTransport);\n        });\n    }\n    init(transport) {\n        const _super = Object.create(null, {\n            init: { get: () => super.init }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._initPromise) {\n                return this._initPromise;\n            }\n            try {\n                yield this.activeAccountLoaded;\n            }\n            catch (_a) {\n                //\n            }\n            try {\n                yield this.activePeerLoaded;\n            }\n            catch (_b) {\n                //\n            }\n            this._initPromise = new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {\n                if (transport) {\n                    yield this.addListener(transport);\n                    resolve(yield _super.init.call(this, transport));\n                }\n                else if (this._transport.isSettled()) {\n                    yield (yield this.transport).connect();\n                    resolve(yield _super.init.call(this, yield this.transport));\n                }\n                else {\n                    const activeAccount = yield this.getActiveAccount();\n                    const stopListening = () => {\n                        if (this.postMessageTransport) {\n                            this.postMessageTransport.stopListeningForNewPeers().catch(console.error);\n                        }\n                        if (this.p2pTransport) {\n                            this.p2pTransport.stopListeningForNewPeers().catch(console.error);\n                        }\n                    };\n                    yield this.initInternalTransports();\n                    if (!this.postMessageTransport || !this.p2pTransport) {\n                        return;\n                    }\n                    this.postMessageTransport.connect().then().catch(console.error);\n                    this.p2pTransport.connect().then().catch(console.error);\n                    if (activeAccount && activeAccount.origin) {\n                        const origin = activeAccount.origin.type;\n                        // Select the transport that matches the active account\n                        if (origin === Origin.EXTENSION) {\n                            resolve(yield _super.init.call(this, this.postMessageTransport));\n                        }\n                        else if (origin === Origin.P2P) {\n                            resolve(yield _super.init.call(this, this.p2pTransport));\n                        }\n                    }\n                    else {\n                        const p2pTransport = this.p2pTransport;\n                        const postMessageTransport = this.postMessageTransport;\n                        postMessageTransport\n                            .listenForNewPeer((peer) => {\n                            logger.log('init', 'postmessage transport peer connected', peer);\n                            this.events\n                                .emit(BeaconEvent.PAIR_SUCCESS, peer)\n                                .catch((emitError) => console.warn(emitError));\n                            this.setActivePeer(peer).catch(console.error);\n                            this.setTransport(this.postMessageTransport).catch(console.error);\n                            stopListening();\n                            resolve(TransportType.POST_MESSAGE);\n                        })\n                            .catch(console.error);\n                        p2pTransport\n                            .listenForNewPeer((peer) => {\n                            logger.log('init', 'p2p transport peer connected', peer);\n                            this.events\n                                .emit(BeaconEvent.PAIR_SUCCESS, peer)\n                                .catch((emitError) => console.warn(emitError));\n                            this.setActivePeer(peer).catch(console.error);\n                            this.setTransport(this.p2pTransport).catch(console.error);\n                            stopListening();\n                            resolve(TransportType.P2P);\n                        })\n                            .catch(console.error);\n                        PostMessageTransport.getAvailableExtensions()\n                            .then(() => __awaiter(this, void 0, void 0, function* () {\n                            this.events\n                                .emit(BeaconEvent.PAIR_INIT, {\n                                p2pPeerInfo: yield p2pTransport.getPairingRequestInfo(),\n                                postmessagePeerInfo: yield postMessageTransport.getPairingRequestInfo(),\n                                preferredNetwork: this.preferredNetwork,\n                                abortedHandler: () => {\n                                    this._initPromise = undefined;\n                                }\n                            })\n                                .catch((emitError) => console.warn(emitError));\n                        }))\n                            .catch((error) => {\n                            this._initPromise = undefined;\n                            console.error(error);\n                        });\n                    }\n                }\n            }));\n            return this._initPromise;\n        });\n    }\n    /**\n     * Returns the active account\n     */\n    getActiveAccount() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._activeAccount.promise;\n        });\n    }\n    /**\n     * Sets the active account\n     *\n     * @param account The account that will be set as the active account\n     */\n    setActiveAccount(account) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._activeAccount.isSettled()) {\n                // If the promise has already been resolved we need to create a new one.\n                this._activeAccount = ExposedPromise.resolve(account);\n            }\n            else {\n                this._activeAccount.resolve(account);\n            }\n            if (account) {\n                const origin = account.origin.type;\n                yield this.initInternalTransports();\n                // Select the transport that matches the active account\n                if (origin === Origin.EXTENSION) {\n                    yield this.setTransport(this.postMessageTransport);\n                }\n                else if (origin === Origin.P2P) {\n                    yield this.setTransport(this.p2pTransport);\n                }\n                const peer = yield this.getPeer(account);\n                yield this.setActivePeer(peer);\n            }\n            else {\n                yield this.setActivePeer(undefined);\n                yield this.setTransport(undefined);\n            }\n            yield this.storage.set(StorageKey.ACTIVE_ACCOUNT, account ? account.accountIdentifier : undefined);\n            yield this.events.emit(BeaconEvent.ACTIVE_ACCOUNT_SET, account);\n            return;\n        });\n    }\n    /**\n     * Clear the active account\n     */\n    clearActiveAccount() {\n        return this.setActiveAccount();\n    }\n    setColorMode(colorMode) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return setColorMode(colorMode);\n        });\n    }\n    getColorMode() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return getColorMode();\n        });\n    }\n    /**\n     * @deprecated\n     *\n     * Use getOwnAppMetadata instead\n     */\n    getAppMetadata() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.getOwnAppMetadata();\n        });\n    }\n    /**\n     * Will remove the account from the local storage and set a new active account if necessary.\n     *\n     * @param accountIdentifier ID of the account\n     */\n    removeAccount(accountIdentifier) {\n        const _super = Object.create(null, {\n            removeAccount: { get: () => super.removeAccount }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            const removeAccountResult = _super.removeAccount.call(this, accountIdentifier);\n            const activeAccount = yield this.getActiveAccount();\n            if (activeAccount && activeAccount.accountIdentifier === accountIdentifier) {\n                yield this.setActiveAccount(undefined);\n            }\n            return removeAccountResult;\n        });\n    }\n    /**\n     * Remove all accounts and set active account to undefined\n     */\n    removeAllAccounts() {\n        const _super = Object.create(null, {\n            removeAllAccounts: { get: () => super.removeAllAccounts }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            yield _super.removeAllAccounts.call(this);\n            yield this.setActiveAccount(undefined);\n        });\n    }\n    /**\n     * Removes a peer and all the accounts that have been connected through that peer\n     *\n     * @param peer Peer to be removed\n     */\n    removePeer(peer, sendDisconnectToPeer = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const transport = yield this.transport;\n            const removePeerResult = transport.removePeer(peer);\n            yield this.removeAccountsForPeers([peer]);\n            if (sendDisconnectToPeer) {\n                yield this.sendDisconnectToPeer(peer, transport);\n            }\n            return removePeerResult;\n        });\n    }\n    /**\n     * Remove all peers and all accounts that have been connected through those peers\n     */\n    removeAllPeers(sendDisconnectToPeers = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const transport = yield this.transport;\n            const peers = yield transport.getPeers();\n            const removePeerResult = transport.removeAllPeers();\n            yield this.removeAccountsForPeers(peers);\n            if (sendDisconnectToPeers) {\n                const disconnectPromises = peers.map((peer) => this.sendDisconnectToPeer(peer, transport));\n                yield Promise.all(disconnectPromises);\n            }\n            return removePeerResult;\n        });\n    }\n    /**\n     * Allows the user to subscribe to specific events that are fired in the SDK\n     *\n     * @param internalEvent The event to subscribe to\n     * @param eventCallback The callback that will be called when the event occurs\n     */\n    subscribeToEvent(internalEvent, eventCallback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.events.on(internalEvent, eventCallback);\n        });\n    }\n    /**\n     * Check if we have permissions to send the specific message type to the active account.\n     * If no active account is set, only permission requests are allowed.\n     *\n     * @param type The type of the message\n     */\n    checkPermissions(type) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (type === BeaconMessageType.PermissionRequest) {\n                return true;\n            }\n            const activeAccount = yield this.getActiveAccount();\n            if (!activeAccount) {\n                throw yield this.sendInternalError('No active account set!');\n            }\n            const permissions = activeAccount.scopes;\n            switch (type) {\n                case BeaconMessageType.OperationRequest:\n                    return permissions.includes(PermissionScope.OPERATION_REQUEST);\n                case BeaconMessageType.SignPayloadRequest:\n                    return permissions.includes(PermissionScope.SIGN);\n                case BeaconMessageType.BroadcastRequest:\n                    return true;\n                default:\n                    return false;\n            }\n        });\n    }\n    /**\n     * Send a permission request to the DApp. This should be done as the first step. The wallet will respond\n     * with an publicKey and permissions that were given. The account returned will be set as the \"activeAccount\"\n     * and will be used for the following requests.\n     *\n     * @param input The message details we need to prepare the PermissionRequest message.\n     */\n    requestPermissions(input) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const request = {\n                appMetadata: yield this.getOwnAppMetadata(),\n                type: BeaconMessageType.PermissionRequest,\n                network: input && input.network ? input.network : { type: NetworkType.MAINNET },\n                scopes: input && input.scopes\n                    ? input.scopes\n                    : [PermissionScope.OPERATION_REQUEST, PermissionScope.SIGN]\n            };\n            const { message, connectionInfo } = yield this.makeRequest(request).catch((requestError) => __awaiter(this, void 0, void 0, function* () {\n                throw yield this.handleRequestError(request, requestError);\n            }));\n            // TODO: Migration code. Remove sometime after 1.0.0 release.\n            const publicKey = message.publicKey || message.pubkey || message.pubKey;\n            const address = yield getAddressFromPublicKey(publicKey);\n            const accountInfo = {\n                accountIdentifier: yield getAccountIdentifier(address, message.network),\n                senderId: message.senderId,\n                origin: {\n                    type: connectionInfo.origin,\n                    id: connectionInfo.id\n                },\n                address,\n                publicKey,\n                network: message.network,\n                scopes: message.scopes,\n                threshold: message.threshold,\n                connectedAt: new Date().getTime()\n            };\n            yield this.accountManager.addAccount(accountInfo);\n            yield this.setActiveAccount(accountInfo);\n            const output = Object.assign(Object.assign({}, message), { address,\n                accountInfo });\n            yield this.notifySuccess(request, {\n                account: accountInfo,\n                output,\n                blockExplorer: this.blockExplorer,\n                connectionContext: connectionInfo,\n                walletInfo: yield this.getWalletInfo()\n            });\n            return output;\n        });\n    }\n    /**\n     * This method will send a \"SignPayloadRequest\" to the wallet. This method is meant to be used to sign\n     * arbitrary data (eg. a string). It will return the signature in the format of \"edsig...\"\n     *\n     * @param input The message details we need to prepare the SignPayloadRequest message.\n     */\n    requestSignPayload(input) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!input.payload) {\n                throw yield this.sendInternalError('Payload must be provided');\n            }\n            const activeAccount = yield this.getActiveAccount();\n            if (!activeAccount) {\n                throw yield this.sendInternalError('No active account!');\n            }\n            const payload = input.payload;\n            if (typeof payload !== 'string') {\n                throw new Error('Payload must be a string');\n            }\n            const signingType = (() => {\n                switch (input.signingType) {\n                    case SigningType.OPERATION:\n                        if (!payload.startsWith('03')) {\n                            throw new Error('When using signing type \"OPERATION\", the payload must start with prefix \"03\"');\n                        }\n                        return SigningType.OPERATION;\n                    case SigningType.MICHELINE:\n                        if (!payload.startsWith('05')) {\n                            throw new Error('When using signing type \"MICHELINE\", the payload must start with prefix \"05\"');\n                        }\n                        return SigningType.MICHELINE;\n                    case SigningType.RAW:\n                    default:\n                        return SigningType.RAW;\n                }\n            })();\n            const request = {\n                type: BeaconMessageType.SignPayloadRequest,\n                signingType,\n                payload,\n                sourceAddress: input.sourceAddress || activeAccount.address\n            };\n            const { message, connectionInfo } = yield this.makeRequest(request).catch((requestError) => __awaiter(this, void 0, void 0, function* () {\n                throw yield this.handleRequestError(request, requestError);\n            }));\n            yield this.notifySuccess(request, {\n                account: activeAccount,\n                output: message,\n                connectionContext: connectionInfo,\n                walletInfo: yield this.getWalletInfo()\n            });\n            return message;\n        });\n    }\n    /**\n     * This method sends an OperationRequest to the wallet. This method should be used for all kinds of operations,\n     * eg. transaction or delegation. Not all properties have to be provided. Data like \"counter\" and fees will be\n     * fetched and calculated by the wallet (but they can still be provided if required).\n     *\n     * @param input The message details we need to prepare the OperationRequest message.\n     */\n    requestOperation(input) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!input.operationDetails) {\n                throw yield this.sendInternalError('Operation details must be provided');\n            }\n            const activeAccount = yield this.getActiveAccount();\n            if (!activeAccount) {\n                throw yield this.sendInternalError('No active account!');\n            }\n            const request = {\n                type: BeaconMessageType.OperationRequest,\n                network: activeAccount.network || { type: NetworkType.MAINNET },\n                operationDetails: input.operationDetails,\n                sourceAddress: activeAccount.address || ''\n            };\n            const { message, connectionInfo } = yield this.makeRequest(request).catch((requestError) => __awaiter(this, void 0, void 0, function* () {\n                throw yield this.handleRequestError(request, requestError);\n            }));\n            yield this.notifySuccess(request, {\n                account: activeAccount,\n                output: message,\n                blockExplorer: this.blockExplorer,\n                connectionContext: connectionInfo,\n                walletInfo: yield this.getWalletInfo()\n            });\n            return message;\n        });\n    }\n    /**\n     * Sends a \"BroadcastRequest\" to the wallet. This method can be used to inject an already signed transaction\n     * to the network.\n     *\n     * @param input The message details we need to prepare the BroadcastRequest message.\n     */\n    requestBroadcast(input) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!input.signedTransaction) {\n                throw yield this.sendInternalError('Signed transaction must be provided');\n            }\n            const network = input.network || { type: NetworkType.MAINNET };\n            const request = {\n                type: BeaconMessageType.BroadcastRequest,\n                network,\n                signedTransaction: input.signedTransaction\n            };\n            const { message, connectionInfo } = yield this.makeRequest(request).catch((requestError) => __awaiter(this, void 0, void 0, function* () {\n                throw yield this.handleRequestError(request, requestError);\n            }));\n            yield this.notifySuccess(request, {\n                network,\n                output: message,\n                blockExplorer: this.blockExplorer,\n                connectionContext: connectionInfo,\n                walletInfo: yield this.getWalletInfo()\n            });\n            return message;\n        });\n    }\n    setActivePeer(peer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._activePeer.isSettled()) {\n                // If the promise has already been resolved we need to create a new one.\n                this._activePeer = ExposedPromise.resolve(peer);\n            }\n            else {\n                this._activePeer.resolve(peer);\n            }\n            if (peer) {\n                yield this.initInternalTransports();\n                if (peer.type === 'postmessage-pairing-response') {\n                    yield this.setTransport(this.postMessageTransport);\n                }\n                else if (peer.type === 'p2p-pairing-response') {\n                    yield this.setTransport(this.p2pTransport);\n                }\n            }\n            yield this.storage.set(StorageKey.ACTIVE_PEER, peer ? peer.publicKey : undefined);\n            return;\n        });\n    }\n    /**\n     * A \"setter\" for when the transport needs to be changed.\n     */\n    setTransport(transport) {\n        const _super = Object.create(null, {\n            setTransport: { get: () => super.setTransport }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!transport) {\n                this._initPromise = undefined;\n            }\n            return _super.setTransport.call(this, transport);\n        });\n    }\n    /**\n     * This method will emit an internal error message.\n     *\n     * @param errorMessage The error message to send.\n     */\n    sendInternalError(errorMessage) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.events.emit(BeaconEvent.INTERNAL_ERROR, errorMessage);\n            throw new Error(errorMessage);\n        });\n    }\n    /**\n     * This method will remove all accounts associated with a specific peer.\n     *\n     * @param peersToRemove An array of peers for which accounts should be removed\n     */\n    removeAccountsForPeers(peersToRemove) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const accounts = yield this.accountManager.getAccounts();\n            const peerIdsToRemove = peersToRemove.map((peer) => peer.senderId);\n            // Remove all accounts with origin of the specified peer\n            const accountsToRemove = accounts.filter((account) => peerIdsToRemove.includes(account.senderId));\n            const accountIdentifiersToRemove = accountsToRemove.map((accountInfo) => accountInfo.accountIdentifier);\n            yield this.accountManager.removeAccounts(accountIdentifiersToRemove);\n            // Check if one of the accounts that was removed was the active account and if yes, set it to undefined\n            const activeAccount = yield this.getActiveAccount();\n            if (activeAccount) {\n                if (accountIdentifiersToRemove.includes(activeAccount.accountIdentifier)) {\n                    yield this.setActiveAccount(undefined);\n                }\n            }\n        });\n    }\n    /**\n     * This message handles errors that we receive from the wallet.\n     *\n     * @param request The request we sent\n     * @param beaconError The error we received\n     */\n    handleRequestError(request, beaconError) {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.error('handleRequestError', 'error response', beaconError);\n            if (beaconError.errorType) {\n                const buttons = [];\n                if (beaconError.errorType === BeaconErrorType.NO_PRIVATE_KEY_FOUND_ERROR) {\n                    const actionCallback = () => __awaiter(this, void 0, void 0, function* () {\n                        const operationRequest = request;\n                        // if the account we requested is not available, we remove it locally\n                        let accountInfo;\n                        if (operationRequest.sourceAddress && operationRequest.network) {\n                            const accountIdentifier = yield getAccountIdentifier(operationRequest.sourceAddress, operationRequest.network);\n                            accountInfo = yield this.getAccount(accountIdentifier);\n                            if (accountInfo) {\n                                yield this.removeAccount(accountInfo.accountIdentifier);\n                            }\n                        }\n                    });\n                    buttons.push({ text: 'Remove account', actionCallback });\n                }\n                const peer = yield this.getPeer();\n                const activeAccount = yield this.getActiveAccount();\n                this.events\n                    .emit(messageEvents[request.type].error, { errorResponse: beaconError, walletInfo: yield this.getWalletInfo(peer, activeAccount) }, buttons)\n                    .catch((emitError) => logger.error('handleRequestError', emitError));\n                throw BeaconError.getError(beaconError.errorType, beaconError.errorData);\n            }\n            throw beaconError;\n        });\n    }\n    /**\n     * This message will send an event when we receive a successful response to one of the requests we sent.\n     *\n     * @param request The request we sent\n     * @param response The response we received\n     */\n    notifySuccess(request, response) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.events\n                .emit(messageEvents[request.type].success, response)\n                .catch((emitError) => console.warn(emitError));\n        });\n    }\n    getWalletInfo(peer, account) {\n        var _a, _b, _c, _d;\n        return __awaiter(this, void 0, void 0, function* () {\n            const selectedAccount = account ? account : yield this.getActiveAccount();\n            const selectedPeer = peer ? peer : yield this.getPeer(selectedAccount);\n            let walletInfo;\n            if (selectedAccount) {\n                walletInfo = yield this.appMetadataManager.getAppMetadata(selectedAccount.senderId);\n            }\n            const typedPeer = selectedPeer;\n            if (!walletInfo) {\n                walletInfo = {\n                    name: typedPeer.name,\n                    icon: typedPeer.icon\n                };\n            }\n            // TODO: Remove once all wallets send the icon?\n            const selectedApp = (_c = (_b = (_a = iOSList.find((app) => app.name === (walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name))) !== null && _a !== void 0 ? _a : webList.find((app) => app.name === (walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name))) !== null && _b !== void 0 ? _b : desktopList.find((app) => app.name === (walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name))) !== null && _c !== void 0 ? _c : extensionList.find((app) => app.name === (walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name));\n            if (selectedApp) {\n                return {\n                    name: walletInfo.name,\n                    icon: (_d = walletInfo.icon) !== null && _d !== void 0 ? _d : selectedApp.logo\n                };\n            }\n            return walletInfo;\n        });\n    }\n    getPeer(account) {\n        var _a, _b, _c, _d;\n        return __awaiter(this, void 0, void 0, function* () {\n            let peer;\n            if (account) {\n                logger.log('', 'We have an account', account);\n                const postMessagePeers = (_b = (yield ((_a = this.postMessageTransport) === null || _a === void 0 ? void 0 : _a.getPeers()))) !== null && _b !== void 0 ? _b : [];\n                const p2pPeers = (_d = (yield ((_c = this.p2pTransport) === null || _c === void 0 ? void 0 : _c.getPeers()))) !== null && _d !== void 0 ? _d : [];\n                const peers = [...postMessagePeers, ...p2pPeers];\n                logger.log('', 'Found peers', peers, account);\n                peer = peers.find((peerEl) => peerEl.senderId === account.senderId);\n                if (!peer) {\n                    // We could not find an exact match for a sender, so we most likely received it over a relay\n                    peer = peers.find((peerEl) => peerEl.extensionId === account.origin.id);\n                }\n            }\n            else {\n                peer = yield this._activePeer.promise;\n                logger.log('', 'Active peer', peer);\n            }\n            if (!peer) {\n                throw new Error('No matching peer found.');\n            }\n            return peer;\n        });\n    }\n    /**\n     * This method handles sending of requests to the DApp. It makes sure that the DAppClient is initialized and connected\n     * to the transport. After that rate limits and permissions will be checked, an ID is attached and the request is sent\n     * to the DApp over the transport.\n     *\n     * @param requestInput The BeaconMessage to be sent to the wallet\n     * @param account The account that the message will be sent to\n     */\n    makeRequest(requestInput) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const messageId = yield generateGUID();\n            console.time(messageId);\n            logger.log('makeRequest', 'starting');\n            yield this.init();\n            console.timeLog(messageId, 'init done');\n            logger.log('makeRequest', 'after init');\n            if (yield this.addRequestAndCheckIfRateLimited()) {\n                this.events\n                    .emit(BeaconEvent.LOCAL_RATE_LIMIT_REACHED)\n                    .catch((emitError) => console.warn(emitError));\n                throw new Error('rate limit reached');\n            }\n            if (!(yield this.checkPermissions(requestInput.type))) {\n                this.events.emit(BeaconEvent.NO_PERMISSIONS).catch((emitError) => console.warn(emitError));\n                throw new Error('No permissions to send this request to wallet!');\n            }\n            if (!this.beaconId) {\n                throw yield this.sendInternalError('BeaconID not defined');\n            }\n            const request = Object.assign({ id: messageId, version: BEACON_VERSION, senderId: yield getSenderId(yield this.beaconId) }, requestInput);\n            const exposed = new ExposedPromise();\n            this.addOpenRequest(request.id, exposed);\n            const payload = yield new Serializer().serialize(request);\n            const account = yield this.getActiveAccount();\n            const peer = yield this.getPeer(account);\n            const walletInfo = yield this.getWalletInfo(peer, account);\n            logger.log('makeRequest', 'sending message', request);\n            console.timeLog(messageId, 'sending');\n            yield (yield this.transport).send(payload, peer);\n            console.timeLog(messageId, 'sent');\n            this.events\n                .emit(messageEvents[requestInput.type].sent, {\n                walletInfo: {\n                    name: (_a = walletInfo.name) !== null && _a !== void 0 ? _a : 'Wallet',\n                    icon: walletInfo.icon\n                },\n                extraInfo: {\n                    resetCallback: () => __awaiter(this, void 0, void 0, function* () {\n                        yield Promise.all([this.clearActiveAccount(), (yield this.transport).disconnect()]);\n                    })\n                }\n            })\n                .catch((emitError) => console.warn(emitError));\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            return exposed.promise; // TODO: fix type\n        });\n    }\n    /**\n     * Adds a requests to the \"openRequests\" set so we know what messages have already been answered/handled.\n     *\n     * @param id The ID of the message\n     * @param promise A promise that resolves once the response for that specific message is received\n     */\n    addOpenRequest(id, promise) {\n        logger.log('addOpenRequest', this.name, `adding request ${id} and waiting for answer`);\n        this.openRequests.set(id, promise);\n    }\n}\n//# sourceMappingURL=DAppClient.js.map"]},"metadata":{},"sourceType":"module"}