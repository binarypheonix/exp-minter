{"ast":null,"code":"/* eslint-disable no-redeclare */\nimport * as t from 'io-ts';\nimport * as e from 'fp-ts/Either';\nimport merge from \"ts-deepmerge\"; //// Contracts\n\nexport const ContractRow = storage => t.type({\n  type: t.string,\n  kind: t.string,\n  tzips: t.union([t.array(t.string), t.undefined]),\n  address: t.string,\n  balance: t.number,\n  creator: t.type({\n    address: t.string\n  }),\n  numContracts: t.number,\n  numDelegations: t.number,\n  numOriginations: t.number,\n  numTransactions: t.number,\n  numReveals: t.number,\n  numMigrations: t.number,\n  firstActivity: t.number,\n  firstActivityTime: t.string,\n  lastActivity: t.number,\n  lastActivityTime: t.string,\n  storage: storage\n}); //// Generic BigMaps\n\nexport const BigMapRow = props => t.type({\n  id: t.number,\n  active: t.boolean,\n  hash: t.string,\n  key: props.key,\n  value: props.value,\n  firstLevel: t.number,\n  lastLevel: t.number,\n  updates: t.number\n});\nexport const BigMapUpdateRow = content => t.type({\n  id: t.number,\n  level: t.number,\n  timestamp: t.string,\n  bigmap: t.number,\n  contract: t.intersection([t.partial({\n    alias: t.string\n  }), t.type({\n    address: t.string\n  })]),\n  path: t.string,\n  action: t.string,\n  content: t.type({\n    hash: t.string,\n    key: content.key,\n    value: content.value\n  })\n}); //// FA2 BigMaps\n\nexport const AssetMetadataBigMap = t.array(BigMapRow({\n  key: t.string,\n  value: t.string\n}));\nexport const LedgerBigMap = t.array(BigMapRow({\n  key: t.string,\n  value: t.string\n}));\nexport const TokenMetadataBigMap = t.array(BigMapRow({\n  key: t.string,\n  value: t.type({\n    token_id: t.string,\n    token_info: t.type({\n      '': t.string\n    })\n  })\n})); //// FixedPriceSale BigMaps\n\nfunction sequenceCodecs(inputCodec, transform, outputCodec, name = outputCodec.name) {\n  return new t.Type(name, outputCodec.is, (input, context) => e.chain(decoded => {\n    return outputCodec.validate(transform(decoded), context);\n  })(inputCodec.validate(input, context)), outputCodec.encode);\n} // Compatibility: Some fixed_price_sale contract bigmaps use a `sale_seller`\n// field while others use a `seller` field. This decoder conforms all bigmaps\n// to use the `sale_seller` field. The decoder receives an \"input\" codec that\n// describes the `sale_seller` and `seller` fields as optional strings. This\n// initial validation allows us to reference these (possibly undefined) fields\n// and pass them to the \"output\" codec for validation via a transformation\n// function.\n//\n// In this case the transformation defines the `sale_seller` field as one of the\n// two input fields. Note the resulting field could be undefined; however, the\n// \"output\" codec will fail if this is the case.\n\n\nconst legacySaleV1 = t.type({\n  sale_seller: t.string,\n  sale_token: t.type({\n    token_for_sale_address: t.string,\n    token_for_sale_token_id: t.string\n  })\n});\nconst legacySaleV2 = t.type({\n  seller: t.string,\n  sale_token: t.type({\n    token_for_sale_address: t.string,\n    token_for_sale_token_id: t.string\n  })\n});\nconst saleV3 = t.type({\n  sale_data: t.type({\n    amount: t.string,\n    price: t.string,\n    sale_token: t.type({\n      fa2_address: t.string,\n      token_id: t.string\n    })\n  }),\n  seller: t.string\n});\nconst sale = t.intersection([saleV3, t.partial({\n  isLegacy: t.boolean\n})]);\nexport const FixedPriceSaleBigMapKey = sequenceCodecs(t.union([legacySaleV1, legacySaleV2, saleV3]), decoded => ({ ...decoded,\n  sale_data: saleV3.is(decoded) ? decoded.sale_data : {\n    amount: \"1\",\n    price: \"0\",\n    sale_token: {\n      fa2_address: decoded.sale_token.token_for_sale_address,\n      token_id: decoded.sale_token.token_for_sale_token_id\n    }\n  },\n  seller: saleV3.is(decoded) || legacySaleV2.is(decoded) ? decoded.seller : decoded.sale_seller\n}), sale);\nconst FixedPriceSaleBigMapRowV1 = BigMapRow({\n  key: FixedPriceSaleBigMapKey,\n  value: t.string\n});\nconst FixedPriceSaleBigMapRowV2 = BigMapRow({\n  key: t.string,\n  value: FixedPriceSaleBigMapKey\n});\nexport const FixedPriceSaleBigMap = t.array(sequenceCodecs(t.union([FixedPriceSaleBigMapRowV1, FixedPriceSaleBigMapRowV2]), row => FixedPriceSaleBigMapRowV1.is(row) ? merge(row, {\n  key: row.id.toString(),\n  value: row.key\n}, {\n  value: {\n    isLegacy: true,\n    sale_data: {\n      price: row.value\n    }\n  }\n}) : merge(row, {\n  value: {\n    isLegacy: false\n  }\n}), FixedPriceSaleBigMapRowV2)); // Compatibility: fixed_price_sale contracts may have different storage\n// depending on which version was originated. Older versions only contain a\n// number referencing a `sales` bigmap, while newer versions store this number\n// in a `sales` field. For example:\n//   Legacy version:\n//     42\n//   Current version:\n//     { sales: 42 }\n//\n// This decoder conforms both storage schemas into the current version.\n\nexport const FixedPriceSaleStorage = sequenceCodecs(t.union([t.number, t.type({\n  sales: t.number\n})]), sales => t.number.is(sales) ? {\n  sales\n} : sales, t.type({\n  sales: t.number\n})); //// NFT Metadata\n\nexport const NftMetadataFormat = t.partial({\n  uri: t.string,\n  hash: t.string,\n  mimeType: t.string,\n  fileSize: t.number,\n  fileName: t.string,\n  duration: t.string,\n  dimensions: t.partial({\n    value: t.string,\n    unit: t.string\n  }),\n  dataRate: t.partial({\n    value: t.number,\n    unit: t.string\n  })\n});\nexport const NftMetadataAttribute = t.intersection([t.type({\n  name: t.string,\n  value: t.string\n}), t.partial({\n  type: t.string\n})]);\nexport const NftMetadata = t.partial({\n  '': t.string,\n  name: t.string,\n  minter: t.string,\n  symbol: t.string,\n  decimals: t.number,\n  rightUri: t.string,\n  artifactUri: t.string,\n  displayUri: t.string,\n  thumbnailUri: t.string,\n  externalUri: t.string,\n  description: t.string,\n  creators: t.array(t.string),\n  contributors: t.array(t.string),\n  publishers: t.array(t.string),\n  date: t.string,\n  blocklevel: t.number,\n  type: t.string,\n  tags: t.array(t.string),\n  genres: t.array(t.string),\n  language: t.string,\n  identifier: t.string,\n  rights: t.string,\n  isTransferable: t.boolean,\n  isBooleanAmount: t.boolean,\n  shouldPreferSymbol: t.boolean,\n  formats: t.array(NftMetadataFormat),\n  attributes: t.array(NftMetadataAttribute)\n});\nexport const NftSale = t.type({\n  id: t.number,\n  seller: t.string,\n  price: t.number,\n  mutez: t.number,\n  type: t.string,\n  saleToken: t.type({\n    address: t.string,\n    tokenId: t.number\n  }),\n  saleId: t.number\n});\nexport const Nft = t.intersection([t.type({\n  id: t.number,\n  title: t.string,\n  owner: t.string,\n  description: t.string,\n  artifactUri: t.string,\n  metadata: NftMetadata\n}), t.partial({\n  sale: NftSale,\n  address: t.string\n})]); //// Contract Metadata\n\nexport const AssetContractMetadata = t.type({\n  name: t.string\n});\nexport const AssetContract = t.intersection([ContractRow(t.unknown), t.type({\n  metadata: AssetContractMetadata\n})]);","map":{"version":3,"sources":["/Users/frankenstein/projects/minter/src/lib/nfts/decoders.ts"],"names":["t","e","merge","ContractRow","storage","type","string","kind","tzips","union","array","undefined","address","balance","number","creator","numContracts","numDelegations","numOriginations","numTransactions","numReveals","numMigrations","firstActivity","firstActivityTime","lastActivity","lastActivityTime","BigMapRow","props","id","active","boolean","hash","key","value","firstLevel","lastLevel","updates","BigMapUpdateRow","content","level","timestamp","bigmap","contract","intersection","partial","alias","path","action","AssetMetadataBigMap","LedgerBigMap","TokenMetadataBigMap","token_id","token_info","sequenceCodecs","inputCodec","transform","outputCodec","name","Type","is","input","context","chain","decoded","validate","encode","legacySaleV1","sale_seller","sale_token","token_for_sale_address","token_for_sale_token_id","legacySaleV2","seller","saleV3","sale_data","amount","price","fa2_address","sale","isLegacy","FixedPriceSaleBigMapKey","FixedPriceSaleBigMapRowV1","FixedPriceSaleBigMapRowV2","FixedPriceSaleBigMap","row","toString","FixedPriceSaleStorage","sales","NftMetadataFormat","uri","mimeType","fileSize","fileName","duration","dimensions","unit","dataRate","NftMetadataAttribute","NftMetadata","minter","symbol","decimals","rightUri","artifactUri","displayUri","thumbnailUri","externalUri","description","creators","contributors","publishers","date","blocklevel","tags","genres","language","identifier","rights","isTransferable","isBooleanAmount","shouldPreferSymbol","formats","attributes","NftSale","mutez","saleToken","tokenId","saleId","Nft","title","owner","metadata","AssetContractMetadata","AssetContract","unknown"],"mappings":"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","sourcesContent":["/* eslint-disable no-redeclare */\nimport * as t from 'io-ts';\nimport * as e from 'fp-ts/Either';\nimport merge from \"ts-deepmerge\";\n\n//// Contracts\n\nexport const ContractRow = <S extends t.Mixed>(storage: S) =>\n  t.type({\n    type: t.string,\n    kind: t.string,\n    tzips: t.union([t.array(t.string), t.undefined]),\n    address: t.string,\n    balance: t.number,\n    creator: t.type({\n      address: t.string\n    }),\n    numContracts: t.number,\n    numDelegations: t.number,\n    numOriginations: t.number,\n    numTransactions: t.number,\n    numReveals: t.number,\n    numMigrations: t.number,\n    firstActivity: t.number,\n    firstActivityTime: t.string,\n    lastActivity: t.number,\n    lastActivityTime: t.string,\n    storage: storage\n  });\n\n//// Generic BigMaps\n\nexport const BigMapRow = <K extends t.Mixed, V extends t.Mixed>(props: {\n  key: K;\n  value: V;\n}) =>\n  t.type({\n    id: t.number,\n    active: t.boolean,\n    hash: t.string,\n    key: props.key,\n    value: props.value,\n    firstLevel: t.number,\n    lastLevel: t.number,\n    updates: t.number\n  });\n\nexport const BigMapUpdateRow = <K extends t.Mixed, V extends t.Mixed>(content: {\n  key: K;\n  value: V;\n}) =>\n  t.type({\n    id: t.number,\n    level: t.number,\n    timestamp: t.string,\n    bigmap: t.number,\n    contract: t.intersection([\n      t.partial({ alias: t.string }),\n      t.type({ address: t.string })\n    ]),\n    path: t.string,\n    action: t.string,\n    content: t.type({ hash: t.string, key: content.key, value: content.value })\n  });\n\n//// FA2 BigMaps\n\nexport type AssetMetadataBigMap = t.TypeOf<typeof AssetMetadataBigMap>;\nexport const AssetMetadataBigMap = t.array(\n  BigMapRow({ key: t.string, value: t.string })\n);\n\nexport type LedgerBigMap = t.TypeOf<typeof LedgerBigMap>;\nexport const LedgerBigMap = t.array(\n  BigMapRow({ key: t.string, value: t.string })\n);\n\nexport type TokenMetadataBigMap = t.TypeOf<typeof TokenMetadataBigMap>;\nexport const TokenMetadataBigMap = t.array(\n  BigMapRow({\n    key: t.string,\n    value: t.type({\n      token_id: t.string,\n      token_info: t.type({\n        '': t.string\n      })\n    })\n  })\n);\n\n//// FixedPriceSale BigMaps\n\nfunction sequenceCodecs<A, B, O, P, H, I>(\n  inputCodec: t.Type<A, O, H>,\n  transform: (decoded: A) => I,\n  outputCodec: t.Type<B, P, I>,\n  name: string = outputCodec.name\n): t.Type<B, P, H> {\n  return new t.Type(\n    name,\n    outputCodec.is,\n    (input, context) =>\n      e.chain((decoded: A) => {\n        return outputCodec.validate(transform(decoded), context);\n      })(inputCodec.validate(input, context)),\n    outputCodec.encode\n  );\n}\n\n// Compatibility: Some fixed_price_sale contract bigmaps use a `sale_seller`\n// field while others use a `seller` field. This decoder conforms all bigmaps\n// to use the `sale_seller` field. The decoder receives an \"input\" codec that\n// describes the `sale_seller` and `seller` fields as optional strings. This\n// initial validation allows us to reference these (possibly undefined) fields\n// and pass them to the \"output\" codec for validation via a transformation\n// function.\n//\n// In this case the transformation defines the `sale_seller` field as one of the\n// two input fields. Note the resulting field could be undefined; however, the\n// \"output\" codec will fail if this is the case.\n\nexport type FixedPriceSaleBigMapKey = t.TypeOf<typeof FixedPriceSaleBigMapKey>;\nconst legacySaleV1 = t.type({\n    sale_seller: t.string,\n    sale_token: t.type({\n      token_for_sale_address: t.string,\n      token_for_sale_token_id: t.string\n    })\n  });\nconst legacySaleV2 = t.type({\n    seller: t.string,\n    sale_token: t.type({\n      token_for_sale_address: t.string,\n      token_for_sale_token_id: t.string\n    })\n  });\nconst saleV3 = t.type({\n  sale_data: t.type({\n    amount: t.string,\n    price: t.string,\n    sale_token: t.type({\n      fa2_address: t.string,\n      token_id: t.string\n    }),\n  }),\n  seller: t.string\n});\nconst sale = t.intersection([\n  saleV3,\n  t.partial({ isLegacy: t.boolean })\n]);\n\nexport const FixedPriceSaleBigMapKey = sequenceCodecs(\n  t.union([ legacySaleV1, legacySaleV2, saleV3 ]),\n  decoded => ({\n    ...decoded,\n    sale_data: saleV3.is(decoded) ? decoded.sale_data : {\n      amount: \"1\",\n      price: \"0\",\n      sale_token: {\n        fa2_address: decoded.sale_token.token_for_sale_address,\n        token_id: decoded.sale_token.token_for_sale_token_id\n      }\n    },\n    seller: (saleV3.is(decoded) || legacySaleV2.is(decoded)) ? decoded.seller : decoded.sale_seller\n  }),\n  sale\n);\n\nconst FixedPriceSaleBigMapRowV1 = BigMapRow({\n  key: FixedPriceSaleBigMapKey,\n  value: t.string\n});\n\nconst FixedPriceSaleBigMapRowV2 = BigMapRow({\n  key: t.string,\n  value: FixedPriceSaleBigMapKey\n});\n\nexport type FixedPriceSaleBigMap = t.TypeOf<typeof FixedPriceSaleBigMap>;\nexport const FixedPriceSaleBigMap = t.array(sequenceCodecs(\n  t.union([ FixedPriceSaleBigMapRowV1, FixedPriceSaleBigMapRowV2 ]),\n  row => (FixedPriceSaleBigMapRowV1.is(row) ? merge(\n      row,\n      { key: row.id.toString(), value: row.key },\n      { value: { isLegacy: true, sale_data: { price: row.value }}}\n    ) : merge(row, { value: { isLegacy: false }})\n  ),\n  FixedPriceSaleBigMapRowV2\n));\n\n// Compatibility: fixed_price_sale contracts may have different storage\n// depending on which version was originated. Older versions only contain a\n// number referencing a `sales` bigmap, while newer versions store this number\n// in a `sales` field. For example:\n//   Legacy version:\n//     42\n//   Current version:\n//     { sales: 42 }\n//\n// This decoder conforms both storage schemas into the current version.\n\nexport type FixedPriceSaleStorage = t.TypeOf<typeof FixedPriceSaleStorage>;\nexport const FixedPriceSaleStorage = sequenceCodecs(\n  t.union([t.number, t.type({ sales: t.number })]),\n  sales => (t.number.is(sales) ? { sales } : sales),\n  t.type({ sales: t.number })\n);\n\n//// NFT Metadata\n\nexport type NftMetadataFormat = t.TypeOf<typeof NftMetadataFormat>;\nexport const NftMetadataFormat = t.partial({\n  uri: t.string,\n  hash: t.string,\n  mimeType: t.string,\n  fileSize: t.number,\n  fileName: t.string,\n  duration: t.string,\n  dimensions: t.partial({\n    value: t.string,\n    unit: t.string\n  }),\n  dataRate: t.partial({\n    value: t.number,\n    unit: t.string\n  })\n});\n\nexport type NftMetadataAttribute = t.TypeOf<typeof NftMetadataAttribute>;\nexport const NftMetadataAttribute = t.intersection([\n  t.type({ name: t.string, value: t.string }),\n  t.partial({ type: t.string })\n]);\n\nexport type NftMetadata = t.TypeOf<typeof NftMetadata>;\nexport const NftMetadata = t.partial({\n  '': t.string,\n  name: t.string,\n  minter: t.string,\n  symbol: t.string,\n  decimals: t.number,\n  rightUri: t.string,\n  artifactUri: t.string,\n  displayUri: t.string,\n  thumbnailUri: t.string,\n  externalUri: t.string,\n  description: t.string,\n  creators: t.array(t.string),\n  contributors: t.array(t.string),\n  publishers: t.array(t.string),\n  date: t.string,\n  blocklevel: t.number,\n  type: t.string,\n  tags: t.array(t.string),\n  genres: t.array(t.string),\n  language: t.string,\n  identifier: t.string,\n  rights: t.string,\n  isTransferable: t.boolean,\n  isBooleanAmount: t.boolean,\n  shouldPreferSymbol: t.boolean,\n  formats: t.array(NftMetadataFormat),\n  attributes: t.array(NftMetadataAttribute)\n});\n\nexport type NftSale = t.TypeOf<typeof NftSale>;\nexport const NftSale = t.type({\n  id: t.number,\n  seller: t.string,\n  price: t.number,\n  mutez: t.number,\n  type: t.string,\n  saleToken: t.type({\n    address: t.string,\n    tokenId: t.number\n  }),\n  saleId: t.number\n});\n\nexport type Nft = t.TypeOf<typeof Nft>;\nexport const Nft = t.intersection([\n  t.type({\n    id: t.number,\n    title: t.string,\n    owner: t.string,\n    description: t.string,\n    artifactUri: t.string,\n    metadata: NftMetadata\n  }),\n  t.partial({\n    sale: NftSale,\n    address: t.string\n  })\n]);\n\n//// Contract Metadata\n\nexport const AssetContractMetadata = t.type({\n  name: t.string\n});\n\nexport type AssetContract = t.TypeOf<typeof AssetContract>;\nexport const AssetContract = t.intersection([\n  ContractRow(t.unknown),\n  t.type({\n    metadata: AssetContractMetadata\n  })\n]);\n"]},"metadata":{},"sourceType":"module"}