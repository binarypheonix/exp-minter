{"ast":null,"code":"import _regeneratorRuntime from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _classCallCheck from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport * as sodium from 'libsodium-wrappers';\nimport { BEACON_VERSION } from '../../constants';\nimport { decryptCryptoboxPayload, encryptCryptoboxPayload } from '../../utils/crypto';\nimport { generateGUID } from '../../utils/generate-uuid';\nimport { CommunicationClient } from './CommunicationClient';\n/**\n * @internalapi\n *\n *\n */\n\nexport var MessageBasedClient = /*#__PURE__*/function (_CommunicationClient) {\n  _inherits(MessageBasedClient, _CommunicationClient);\n\n  var _super = _createSuper(MessageBasedClient);\n\n  function MessageBasedClient(name, keyPair) {\n    var _this;\n\n    _classCallCheck(this, MessageBasedClient);\n\n    _this = _super.call(this, keyPair);\n    _this.name = name;\n    /**\n     * The listeners that will be notified of new messages\n     */\n\n    _this.activeListeners = new Map();\n\n    _this.init().catch(console.error);\n\n    return _this;\n  }\n  /**\n   * start the client and make sure all dependencies are ready\n   */\n\n\n  _createClass(MessageBasedClient, [{\n    key: \"start\",\n    value: function start() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return sodium.ready;\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n    }\n    /**\n     * Get the pairing request information. This will be shared with the peer during the connection setup\n     */\n\n  }, {\n    key: \"getPairingRequestInfo\",\n    value: function getPairingRequestInfo() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return generateGUID();\n\n              case 2:\n                _context2.t0 = _context2.sent;\n                _context2.t1 = this.name;\n                _context2.t2 = BEACON_VERSION;\n                _context2.next = 7;\n                return this.getPublicKey();\n\n              case 7:\n                _context2.t3 = _context2.sent;\n                return _context2.abrupt(\"return\", {\n                  id: _context2.t0,\n                  type: 'postmessage-pairing-request',\n                  name: _context2.t1,\n                  version: _context2.t2,\n                  publicKey: _context2.t3\n                });\n\n              case 9:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n    /**\n     * Get the pairing response information. This will be shared with the peer during the connection setup\n     */\n\n  }, {\n    key: \"getPairingResponseInfo\",\n    value: function getPairingResponseInfo(request) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.t0 = request.id;\n                _context3.t1 = this.name;\n                _context3.t2 = BEACON_VERSION;\n                _context3.next = 5;\n                return this.getPublicKey();\n\n              case 5:\n                _context3.t3 = _context3.sent;\n                return _context3.abrupt(\"return\", {\n                  id: _context3.t0,\n                  type: 'postmessage-pairing-response',\n                  name: _context3.t1,\n                  version: _context3.t2,\n                  publicKey: _context3.t3\n                });\n\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n    /**\n     * Unsubscribe from encrypted messages from a specific peer\n     *\n     * @param senderPublicKey\n     */\n\n  }, {\n    key: \"unsubscribeFromEncryptedMessage\",\n    value: function unsubscribeFromEncryptedMessage(senderPublicKey) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var listener;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                listener = this.activeListeners.get(senderPublicKey);\n\n                if (listener) {\n                  _context4.next = 3;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\");\n\n              case 3:\n                this.activeListeners.delete(senderPublicKey);\n\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n    /**\n     * Unsubscribe from all encrypted messages\n     */\n\n  }, {\n    key: \"unsubscribeFromEncryptedMessages\",\n    value: function unsubscribeFromEncryptedMessages() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                this.activeListeners.clear();\n\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n    }\n    /**\n     * Decrypt a message from a specific peer\n     *\n     * @param senderPublicKey\n     * @param payload\n     */\n\n  }, {\n    key: \"decryptMessage\",\n    value: function decryptMessage(senderPublicKey, payload) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        var _yield$this$createCry, sharedRx, hexPayload;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this.createCryptoBoxServer(senderPublicKey, this.keyPair.privateKey);\n\n              case 2:\n                _yield$this$createCry = _context6.sent;\n                sharedRx = _yield$this$createCry.sharedRx;\n                hexPayload = Buffer.from(payload, 'hex');\n\n                if (!(hexPayload.length >= sodium.crypto_secretbox_NONCEBYTES + sodium.crypto_secretbox_MACBYTES)) {\n                  _context6.next = 14;\n                  break;\n                }\n\n                _context6.prev = 6;\n                _context6.next = 9;\n                return decryptCryptoboxPayload(hexPayload, sharedRx);\n\n              case 9:\n                return _context6.abrupt(\"return\", _context6.sent);\n\n              case 12:\n                _context6.prev = 12;\n                _context6.t0 = _context6[\"catch\"](6);\n\n              case 14:\n                throw new Error('Could not decrypt message');\n\n              case 15:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[6, 12]]);\n      }));\n    }\n    /**\n     * Encrypt a message for a specific publicKey (receiver)\n     *\n     * @param recipientPublicKey\n     * @param message\n     */\n\n  }, {\n    key: \"encryptMessage\",\n    value: function encryptMessage(recipientPublicKey, message) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        var _yield$this$createCry2, sharedTx;\n\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return this.createCryptoBoxClient(recipientPublicKey, this.keyPair.privateKey);\n\n              case 2:\n                _yield$this$createCry2 = _context7.sent;\n                sharedTx = _yield$this$createCry2.sharedTx;\n                return _context7.abrupt(\"return\", encryptCryptoboxPayload(message, sharedTx));\n\n              case 5:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n    }\n  }]);\n\n  return MessageBasedClient;\n}(CommunicationClient);","map":{"version":3,"sources":["../../../../src/transports/clients/MessageBasedClient.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAO,KAAK,MAAZ,MAAwB,oBAAxB;AACA,SAAS,cAAT,QAA+B,iBAA/B;AAGA,SAAS,uBAAT,EAAkC,uBAAlC,QAAiE,oBAAjE;AACA,SAAS,YAAT,QAA6B,2BAA7B;AACA,SAAS,mBAAT,QAAoC,uBAApC;AAEA;;;;AAIG;;AACH,WAAsB,kBAAtB;AAAA;;AAAA;;AAME,8BAA+B,IAA/B,EAA6C,OAA7C,EAAoE;AAAA;;AAAA;;AAClE,8BAAM,OAAN;AAD6B,UAAA,IAAA,GAAA,IAAA;AAL/B;;AAEG;;AACyB,UAAA,eAAA,GAAwC,IAAI,GAAJ,EAAxC;;AAI1B,UAAK,IAAL,GAAY,KAAZ,CAAkB,OAAO,CAAC,KAA1B;;AAFkE;AAGnE;AAED;;AAEG;;;AAbL;AAAA;AAAA,WAce,iBAAK;;;;;;;AAChB,uBAAM,MAAM,CAAC,KAAb;;;;;;;;;AACD;AAED;;AAEG;;AApBL;AAAA;AAAA,WAqBe,iCAAqB;;;;;;;AAE1B,uBAAM,YAAY,EAAlB;;;;+BAEE,KAAK,I;+BACF,c;;AACE,uBAAM,KAAK,YAAL,EAAN;;;;;AAJX,kBAAA,E;AACA,kBAAA,I,EAAM,6B;AACN,kBAAA,I;AACA,kBAAA,O;AACA,kBAAA,S;;;;;;;;;;AAEH;AAED;;AAEG;;AAjCL;AAAA;AAAA,WAkCe,gCACX,OADW,EACuB;;;;;;+BAG5B,OAAO,CAAC,E;+BAEN,KAAK,I;+BACF,c;;AACE,uBAAM,KAAK,YAAL,EAAN;;;;;AAJX,kBAAA,E;AACA,kBAAA,I,EAAM,8B;AACN,kBAAA,I;AACA,kBAAA,O;AACA,kBAAA,S;;;;;;;;;;AAEH;AAED;;;;AAIG;;AAlDL;AAAA;AAAA,WAmDe,yCAAgC,eAAhC,EAAuD;;;;;;;AAC5D,gBAAA,Q,GAAW,KAAK,eAAL,CAAqB,GAArB,CAAyB,eAAzB,C;;oBACZ,Q;;;;;;;;AAIL,qBAAK,eAAL,CAAqB,MAArB,CAA4B,eAA5B;;;;;;;;;AACD;AAED;;AAEG;;AA9DL;AAAA;AAAA,WA+De,4CAAgC;;;;;;AAC3C,qBAAK,eAAL,CAAqB,KAArB;;;;;;;;;AACD;AAED;;;;;AAKG;;AAxEL;AAAA;AAAA,WAyEkB,wBAAe,eAAf,EAAwC,OAAxC,EAAuD;;;;;;;;;AAChD,uBAAM,KAAK,qBAAL,CAA2B,eAA3B,EAA4C,KAAK,OAAL,CAAa,UAAzD,CAAN;;;;AAAb,gBAAA,Q,yBAAA,Q;AAEF,gBAAA,U,GAAa,MAAM,CAAC,IAAP,CAAY,OAAZ,EAAqB,KAArB,C;;sBAGjB,UAAU,CAAC,MAAX,IACA,MAAM,CAAC,2BAAP,GAAqC,MAAM,CAAC,yB;;;;;;;AAGnC,uBAAM,uBAAuB,CAAC,UAAD,EAAa,QAAb,CAA7B;;;;;;;;;;sBAML,IAAI,KAAJ,CAAU,2BAAV,C;;;;;;;;;AACP;AAED;;;;;AAKG;;AAjGL;AAAA;AAAA,WAkGkB,wBAAe,kBAAf,EAA2C,OAA3C,EAA0D;;;;;;;;;AACnD,uBAAM,KAAK,qBAAL,CACzB,kBADyB,EAEzB,KAAK,OAAL,CAAa,UAFY,CAAN;;;;AAAb,gBAAA,Q,0BAAA,Q;kDAKD,uBAAuB,CAAC,OAAD,EAAU,QAAV,C;;;;;;;;;AAC/B;AAzGH;;AAAA;AAAA,EAAiD,mBAAjD","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as sodium from 'libsodium-wrappers';\nimport { BEACON_VERSION } from '../../constants';\nimport { decryptCryptoboxPayload, encryptCryptoboxPayload } from '../../utils/crypto';\nimport { generateGUID } from '../../utils/generate-uuid';\nimport { CommunicationClient } from './CommunicationClient';\n/**\n * @internalapi\n *\n *\n */\nexport class MessageBasedClient extends CommunicationClient {\n    constructor(name, keyPair) {\n        super(keyPair);\n        this.name = name;\n        /**\n         * The listeners that will be notified of new messages\n         */\n        this.activeListeners = new Map();\n        this.init().catch(console.error);\n    }\n    /**\n     * start the client and make sure all dependencies are ready\n     */\n    start() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield sodium.ready;\n        });\n    }\n    /**\n     * Get the pairing request information. This will be shared with the peer during the connection setup\n     */\n    getPairingRequestInfo() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return {\n                id: yield generateGUID(),\n                type: 'postmessage-pairing-request',\n                name: this.name,\n                version: BEACON_VERSION,\n                publicKey: yield this.getPublicKey()\n            };\n        });\n    }\n    /**\n     * Get the pairing response information. This will be shared with the peer during the connection setup\n     */\n    getPairingResponseInfo(request) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return {\n                id: request.id,\n                type: 'postmessage-pairing-response',\n                name: this.name,\n                version: BEACON_VERSION,\n                publicKey: yield this.getPublicKey()\n            };\n        });\n    }\n    /**\n     * Unsubscribe from encrypted messages from a specific peer\n     *\n     * @param senderPublicKey\n     */\n    unsubscribeFromEncryptedMessage(senderPublicKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const listener = this.activeListeners.get(senderPublicKey);\n            if (!listener) {\n                return;\n            }\n            this.activeListeners.delete(senderPublicKey);\n        });\n    }\n    /**\n     * Unsubscribe from all encrypted messages\n     */\n    unsubscribeFromEncryptedMessages() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.activeListeners.clear();\n        });\n    }\n    /**\n     * Decrypt a message from a specific peer\n     *\n     * @param senderPublicKey\n     * @param payload\n     */\n    decryptMessage(senderPublicKey, payload) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { sharedRx } = yield this.createCryptoBoxServer(senderPublicKey, this.keyPair.privateKey);\n            const hexPayload = Buffer.from(payload, 'hex');\n            if (hexPayload.length >=\n                sodium.crypto_secretbox_NONCEBYTES + sodium.crypto_secretbox_MACBYTES) {\n                try {\n                    return yield decryptCryptoboxPayload(hexPayload, sharedRx);\n                }\n                catch (decryptionError) {\n                    /* NO-OP. We try to decode every message, but some might not be addressed to us. */\n                }\n            }\n            throw new Error('Could not decrypt message');\n        });\n    }\n    /**\n     * Encrypt a message for a specific publicKey (receiver)\n     *\n     * @param recipientPublicKey\n     * @param message\n     */\n    encryptMessage(recipientPublicKey, message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { sharedTx } = yield this.createCryptoBoxClient(recipientPublicKey, this.keyPair.privateKey);\n            return encryptCryptoboxPayload(message, sharedTx);\n        });\n    }\n}\n//# sourceMappingURL=MessageBasedClient.js.map"]},"metadata":{},"sourceType":"module"}