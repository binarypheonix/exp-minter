{"ast":null,"code":"import _regeneratorRuntime from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _classCallCheck from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { ExposedPromise, ExposedPromiseStatus } from '../../utils/exposed-promise';\nimport { Serializer, TransportStatus, BeaconMessageType } from '../..';\nimport { BeaconEventHandler, BeaconEvent } from '../../events';\nimport { BeaconClient } from '../beacon-client/BeaconClient';\nimport { AccountManager } from '../../managers/AccountManager';\nimport { generateGUID } from '../../utils/generate-uuid';\nimport { BEACON_VERSION } from '../../constants';\nimport { getSenderId } from '../../utils/get-sender-id';\nimport { Logger } from '../../utils/Logger';\nvar logger = new Logger('Client');\n/**\n * @internalapi\n *\n * This abstract class handles the a big part of the logic that is shared between the dapp and wallet client.\n * For example, it selects and manages the transport and accounts.\n */\n\nexport var Client = /*#__PURE__*/function (_BeaconClient) {\n  _inherits(Client, _BeaconClient);\n\n  var _super2 = _createSuper(Client);\n\n  function Client(config) {\n    var _this;\n\n    _classCallCheck(this, Client);\n\n    var _a, _b;\n\n    _this = _super2.call(this, config);\n    /**\n     * How many requests can be sent after another\n     */\n\n    _this.rateLimit = 2;\n    /**\n     * The time window in seconds in which the \"rateLimit\" is checked\n     */\n\n    _this.rateLimitWindowInSeconds = 5;\n    /**\n     * Stores the times when requests have been made to determine if the rate limit has been reached\n     */\n\n    _this.requestCounter = [];\n    _this._transport = new ExposedPromise();\n    _this.events = new BeaconEventHandler(config.eventHandlers, (_a = config.disableDefaultEvents) !== null && _a !== void 0 ? _a : false);\n    _this.accountManager = new AccountManager(config.storage);\n    _this.matrixNodes = (_b = config.matrixNodes) !== null && _b !== void 0 ? _b : [];\n\n    _this.handleResponse = function (message, connectionInfo) {\n      throw new Error(\"not overwritten\".concat(JSON.stringify(message), \" - \").concat(JSON.stringify(connectionInfo)));\n    };\n\n    return _this;\n  }\n\n  _createClass(Client, [{\n    key: \"transport\",\n    get: function get() {\n      return this._transport.promise;\n    }\n    /**\n     * Returns the connection status of the Client\n     */\n\n  }, {\n    key: \"connectionStatus\",\n    get: function get() {\n      var _a, _b;\n\n      return (_b = (_a = this._transport.promiseResult) === null || _a === void 0 ? void 0 : _a.connectionStatus) !== null && _b !== void 0 ? _b : TransportStatus.NOT_CONNECTED;\n    }\n    /**\n     * Returns whether or not the transaport is ready\n     */\n\n  }, {\n    key: \"ready\",\n    get: function get() {\n      return this.transport.then(function () {\n        return undefined;\n      });\n    }\n    /**\n     * Return all locally known accounts\n     */\n\n  }, {\n    key: \"getAccounts\",\n    value: function getAccounts() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", this.accountManager.getAccounts());\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * Return the account by ID\n     * @param accountIdentifier The ID of an account\n     */\n\n  }, {\n    key: \"getAccount\",\n    value: function getAccount(accountIdentifier) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", this.accountManager.getAccount(accountIdentifier));\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n    /**\n     * Remove the account by ID\n     * @param accountIdentifier The ID of an account\n     */\n\n  }, {\n    key: \"removeAccount\",\n    value: function removeAccount(accountIdentifier) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", this.accountManager.removeAccount(accountIdentifier));\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n    /**\n     * Remove all locally stored accounts\n     */\n\n  }, {\n    key: \"removeAllAccounts\",\n    value: function removeAllAccounts() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                return _context4.abrupt(\"return\", this.accountManager.removeAllAccounts());\n\n              case 1:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n    /**\n     * Add a new request (current timestamp) to the pending requests, remove old ones and check if we are above the limit\n     */\n\n  }, {\n    key: \"addRequestAndCheckIfRateLimited\",\n    value: function addRequestAndCheckIfRateLimited() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        var _this2 = this;\n\n        var now;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                now = new Date().getTime();\n                this.requestCounter = this.requestCounter.filter(function (date) {\n                  return date + _this2.rateLimitWindowInSeconds * 1000 > now;\n                });\n                this.requestCounter.push(now);\n                return _context5.abrupt(\"return\", this.requestCounter.length > this.rateLimit);\n\n              case 4:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n    }\n    /**\n     * This method initializes the client. It will check if the connection should be established to a\n     * browser extension or if the P2P transport should be used.\n     *\n     * @param transport A transport that can be provided by the user\n     */\n\n  }, {\n    key: \"init\",\n    value: function init(transport) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (!(this._transport.status === ExposedPromiseStatus.RESOLVED)) {\n                  _context6.next = 4;\n                  break;\n                }\n\n                _context6.next = 3;\n                return this.transport;\n\n              case 3:\n                return _context6.abrupt(\"return\", _context6.sent.type);\n\n              case 4:\n                _context6.next = 6;\n                return this.setTransport(transport);\n\n              case 6:\n                return _context6.abrupt(\"return\", transport.type);\n\n              case 7:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n    }\n    /**\n     * Returns the metadata of this DApp\n     */\n\n  }, {\n    key: \"getOwnAppMetadata\",\n    value: function getOwnAppMetadata() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.t0 = getSenderId;\n                _context7.next = 3;\n                return this.beaconId;\n\n              case 3:\n                _context7.t1 = _context7.sent;\n                _context7.next = 6;\n                return (0, _context7.t0)(_context7.t1);\n\n              case 6:\n                _context7.t2 = _context7.sent;\n                _context7.t3 = this.name;\n                _context7.t4 = this.iconUrl;\n                return _context7.abrupt(\"return\", {\n                  senderId: _context7.t2,\n                  name: _context7.t3,\n                  icon: _context7.t4\n                });\n\n              case 10:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n    }\n    /**\n     * Return all known peers\n     */\n\n  }, {\n    key: \"getPeers\",\n    value: function getPeers() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.next = 2;\n                return this.transport;\n\n              case 2:\n                return _context8.abrupt(\"return\", _context8.sent.getPeers());\n\n              case 3:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n    }\n    /**\n     * Add a new peer to the known peers\n     * @param peer The new peer to add\n     */\n\n  }, {\n    key: \"addPeer\",\n    value: function addPeer(peer) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.next = 2;\n                return this.transport;\n\n              case 2:\n                return _context9.abrupt(\"return\", _context9.sent.addPeer(peer));\n\n              case 3:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _this3 = this;\n\n      var _super = Object.create(null, {\n        destroy: {\n          get: function get() {\n            return _get(_getPrototypeOf(Client.prototype), \"destroy\", _this3);\n          }\n        }\n      });\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                if (!(this._transport.status === ExposedPromiseStatus.RESOLVED)) {\n                  _context10.next = 5;\n                  break;\n                }\n\n                _context10.next = 3;\n                return this.transport;\n\n              case 3:\n                _context10.next = 5;\n                return _context10.sent.disconnect();\n\n              case 5:\n                _context10.next = 7;\n                return _super.destroy.call(this);\n\n              case 7:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n    }\n    /**\n     * A \"setter\" for when the transport needs to be changed.\n     */\n\n  }, {\n    key: \"setTransport\",\n    value: function setTransport(transport) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee11() {\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                if (transport) {\n                  if (this._transport.isSettled()) {\n                    // If the promise has already been resolved we need to create a new one.\n                    this._transport = ExposedPromise.resolve(transport);\n                  } else {\n                    this._transport.resolve(transport);\n                  }\n                } else {\n                  if (this._transport.isSettled()) {\n                    // If the promise has already been resolved we need to create a new one.\n                    this._transport = new ExposedPromise();\n                  }\n                }\n\n                _context11.next = 3;\n                return this.events.emit(BeaconEvent.ACTIVE_TRANSPORT_SET, transport);\n\n              case 3:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n    }\n  }, {\n    key: \"addListener\",\n    value: function addListener(transport) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee13() {\n        var _this4 = this;\n\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                transport.addListener(function (message, connectionInfo) {\n                  return __awaiter(_this4, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee12() {\n                    var deserializedMessage;\n                    return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n                      while (1) {\n                        switch (_context12.prev = _context12.next) {\n                          case 0:\n                            if (!(typeof message === 'string')) {\n                              _context12.next = 5;\n                              break;\n                            }\n\n                            _context12.next = 3;\n                            return new Serializer().deserialize(message);\n\n                          case 3:\n                            deserializedMessage = _context12.sent;\n                            this.handleResponse(deserializedMessage, connectionInfo);\n\n                          case 5:\n                          case \"end\":\n                            return _context12.stop();\n                        }\n                      }\n                    }, _callee12, this);\n                  }));\n                }).catch(function (error) {\n                  return logger.error('addListener', error);\n                });\n\n              case 1:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13);\n      }));\n    }\n  }, {\n    key: \"sendDisconnectToPeer\",\n    value: function sendDisconnectToPeer(peer, transport) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee14() {\n        var request, payload, selectedTransport;\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                _context14.next = 2;\n                return generateGUID();\n\n              case 2:\n                _context14.t0 = _context14.sent;\n                _context14.t1 = BEACON_VERSION;\n                _context14.t2 = getSenderId;\n                _context14.next = 7;\n                return this.beaconId;\n\n              case 7:\n                _context14.t3 = _context14.sent;\n                _context14.next = 10;\n                return (0, _context14.t2)(_context14.t3);\n\n              case 10:\n                _context14.t4 = _context14.sent;\n                _context14.t5 = BeaconMessageType.Disconnect;\n                request = {\n                  id: _context14.t0,\n                  version: _context14.t1,\n                  senderId: _context14.t4,\n                  type: _context14.t5\n                };\n                _context14.next = 15;\n                return new Serializer().serialize(request);\n\n              case 15:\n                payload = _context14.sent;\n\n                if (!(transport !== null && transport !== void 0)) {\n                  _context14.next = 20;\n                  break;\n                }\n\n                _context14.t6 = transport;\n                _context14.next = 23;\n                break;\n\n              case 20:\n                _context14.next = 22;\n                return this.transport;\n\n              case 22:\n                _context14.t6 = _context14.sent;\n\n              case 23:\n                selectedTransport = _context14.t6;\n                _context14.next = 26;\n                return selectedTransport.send(payload, peer);\n\n              case 26:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n    }\n  }]);\n\n  return Client;\n}(BeaconClient);","map":{"version":3,"sources":["../../../../src/clients/client/Client.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ExposedPromise, ExposedPromiseStatus } from '../../utils/exposed-promise';\nimport { Serializer, TransportStatus, BeaconMessageType } from '../..';\nimport { BeaconEventHandler, BeaconEvent } from '../../events';\nimport { BeaconClient } from '../beacon-client/BeaconClient';\nimport { AccountManager } from '../../managers/AccountManager';\nimport { generateGUID } from '../../utils/generate-uuid';\nimport { BEACON_VERSION } from '../../constants';\nimport { getSenderId } from '../../utils/get-sender-id';\nimport { Logger } from '../../utils/Logger';\nconst logger = new Logger('Client');\n/**\n * @internalapi\n *\n * This abstract class handles the a big part of the logic that is shared between the dapp and wallet client.\n * For example, it selects and manages the transport and accounts.\n */\nexport class Client extends BeaconClient {\n    constructor(config) {\n        var _a, _b;\n        super(config);\n        /**\n         * How many requests can be sent after another\n         */\n        this.rateLimit = 2;\n        /**\n         * The time window in seconds in which the \"rateLimit\" is checked\n         */\n        this.rateLimitWindowInSeconds = 5;\n        /**\n         * Stores the times when requests have been made to determine if the rate limit has been reached\n         */\n        this.requestCounter = [];\n        this._transport = new ExposedPromise();\n        this.events = new BeaconEventHandler(config.eventHandlers, (_a = config.disableDefaultEvents) !== null && _a !== void 0 ? _a : false);\n        this.accountManager = new AccountManager(config.storage);\n        this.matrixNodes = (_b = config.matrixNodes) !== null && _b !== void 0 ? _b : [];\n        this.handleResponse = (message, connectionInfo) => {\n            throw new Error(`not overwritten${JSON.stringify(message)} - ${JSON.stringify(connectionInfo)}`);\n        };\n    }\n    get transport() {\n        return this._transport.promise;\n    }\n    /**\n     * Returns the connection status of the Client\n     */\n    get connectionStatus() {\n        var _a, _b;\n        return (_b = (_a = this._transport.promiseResult) === null || _a === void 0 ? void 0 : _a.connectionStatus) !== null && _b !== void 0 ? _b : TransportStatus.NOT_CONNECTED;\n    }\n    /**\n     * Returns whether or not the transaport is ready\n     */\n    get ready() {\n        return this.transport.then(() => undefined);\n    }\n    /**\n     * Return all locally known accounts\n     */\n    getAccounts() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.accountManager.getAccounts();\n        });\n    }\n    /**\n     * Return the account by ID\n     * @param accountIdentifier The ID of an account\n     */\n    getAccount(accountIdentifier) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.accountManager.getAccount(accountIdentifier);\n        });\n    }\n    /**\n     * Remove the account by ID\n     * @param accountIdentifier The ID of an account\n     */\n    removeAccount(accountIdentifier) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.accountManager.removeAccount(accountIdentifier);\n        });\n    }\n    /**\n     * Remove all locally stored accounts\n     */\n    removeAllAccounts() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.accountManager.removeAllAccounts();\n        });\n    }\n    /**\n     * Add a new request (current timestamp) to the pending requests, remove old ones and check if we are above the limit\n     */\n    addRequestAndCheckIfRateLimited() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const now = new Date().getTime();\n            this.requestCounter = this.requestCounter.filter((date) => date + this.rateLimitWindowInSeconds * 1000 > now);\n            this.requestCounter.push(now);\n            return this.requestCounter.length > this.rateLimit;\n        });\n    }\n    /**\n     * This method initializes the client. It will check if the connection should be established to a\n     * browser extension or if the P2P transport should be used.\n     *\n     * @param transport A transport that can be provided by the user\n     */\n    init(transport) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._transport.status === ExposedPromiseStatus.RESOLVED) {\n                return (yield this.transport).type;\n            }\n            yield this.setTransport(transport); // Let users define their own transport\n            return transport.type;\n        });\n    }\n    /**\n     * Returns the metadata of this DApp\n     */\n    getOwnAppMetadata() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return {\n                senderId: yield getSenderId(yield this.beaconId),\n                name: this.name,\n                icon: this.iconUrl\n            };\n        });\n    }\n    /**\n     * Return all known peers\n     */\n    getPeers() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return (yield this.transport).getPeers();\n        });\n    }\n    /**\n     * Add a new peer to the known peers\n     * @param peer The new peer to add\n     */\n    addPeer(peer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return (yield this.transport).addPeer(peer);\n        });\n    }\n    destroy() {\n        const _super = Object.create(null, {\n            destroy: { get: () => super.destroy }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._transport.status === ExposedPromiseStatus.RESOLVED) {\n                yield (yield this.transport).disconnect();\n            }\n            yield _super.destroy.call(this);\n        });\n    }\n    /**\n     * A \"setter\" for when the transport needs to be changed.\n     */\n    setTransport(transport) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (transport) {\n                if (this._transport.isSettled()) {\n                    // If the promise has already been resolved we need to create a new one.\n                    this._transport = ExposedPromise.resolve(transport);\n                }\n                else {\n                    this._transport.resolve(transport);\n                }\n            }\n            else {\n                if (this._transport.isSettled()) {\n                    // If the promise has already been resolved we need to create a new one.\n                    this._transport = new ExposedPromise();\n                }\n            }\n            yield this.events.emit(BeaconEvent.ACTIVE_TRANSPORT_SET, transport);\n        });\n    }\n    addListener(transport) {\n        return __awaiter(this, void 0, void 0, function* () {\n            transport\n                .addListener((message, connectionInfo) => __awaiter(this, void 0, void 0, function* () {\n                if (typeof message === 'string') {\n                    const deserializedMessage = (yield new Serializer().deserialize(message));\n                    this.handleResponse(deserializedMessage, connectionInfo);\n                }\n            }))\n                .catch((error) => logger.error('addListener', error));\n        });\n    }\n    sendDisconnectToPeer(peer, transport) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const request = {\n                id: yield generateGUID(),\n                version: BEACON_VERSION,\n                senderId: yield getSenderId(yield this.beaconId),\n                type: BeaconMessageType.Disconnect\n            };\n            const payload = yield new Serializer().serialize(request);\n            const selectedTransport = transport !== null && transport !== void 0 ? transport : (yield this.transport);\n            yield selectedTransport.send(payload, peer);\n        });\n    }\n}\n//# sourceMappingURL=Client.js.map"]},"metadata":{},"sourceType":"module"}