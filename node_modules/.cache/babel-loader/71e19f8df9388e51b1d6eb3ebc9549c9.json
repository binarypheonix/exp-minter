{"ast":null,"code":"import _regeneratorRuntime from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _classCallCheck from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { Logger } from '../utils/Logger';\nimport { ExposedPromise } from '../utils/exposed-promise';\nimport { MatrixClientStore } from './MatrixClientStore';\nimport { MatrixHttpClient } from './MatrixHttpClient';\nimport { MatrixRoom, MatrixRoomStatus } from './models/MatrixRoom';\nimport { MatrixRoomService } from './services/MatrixRoomService';\nimport { MatrixUserService } from './services/MatrixUserService';\nimport { MatrixEventService } from './services/MatrixEventService';\nimport { MatrixClientEventEmitter } from './MatrixClientEventEmitter';\nvar logger = new Logger('MatrixClient');\nvar MAX_POLLING_RETRIES = 3;\n/**\n * The matrix client used to connect to the matrix network\n */\n\nexport var MatrixClient = /*#__PURE__*/function () {\n  function MatrixClient(store, eventEmitter, userService, roomService, eventService, httpClient) {\n    var _this = this;\n\n    _classCallCheck(this, MatrixClient);\n\n    this.store = store;\n    this.eventEmitter = eventEmitter;\n    this.userService = userService;\n    this.roomService = roomService;\n    this.eventService = eventService;\n    this.httpClient = httpClient;\n    this.isActive = true;\n    this._isReady = new ExposedPromise();\n    this.store.onStateChanged(function (oldState, newState, stateChange) {\n      _this.eventEmitter.onStateChanged(oldState, newState, stateChange);\n    }, 'rooms');\n  }\n  /**\n   * Create a matrix client based on the options provided\n   *\n   * @param config\n   */\n\n\n  _createClass(MatrixClient, [{\n    key: \"joinedRooms\",\n    get:\n    /**\n     * Return all the rooms we are currently part of\n     */\n    function get() {\n      var _this2 = this;\n\n      return new Promise(function (resolve) {\n        return __awaiter(_this2, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.next = 2;\n                  return this.isConnected();\n\n                case 2:\n                  resolve(Object.values(this.store.get('rooms')).filter(function (room) {\n                    return room.status === MatrixRoomStatus.JOINED;\n                  }));\n\n                case 3:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this);\n        }));\n      });\n    }\n    /**\n     * Return all the rooms to which we have received invitations\n     */\n\n  }, {\n    key: \"invitedRooms\",\n    get: function get() {\n      var _this3 = this;\n\n      return new Promise(function (resolve) {\n        return __awaiter(_this3, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  _context2.next = 2;\n                  return this.isConnected();\n\n                case 2:\n                  resolve(Object.values(this.store.get('rooms')).filter(function (room) {\n                    return room.status === MatrixRoomStatus.INVITED;\n                  }));\n\n                case 3:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, this);\n        }));\n      });\n    }\n    /**\n     * Return all the rooms that we left\n     */\n\n  }, {\n    key: \"leftRooms\",\n    get: function get() {\n      var _this4 = this;\n\n      return new Promise(function (resolve) {\n        return __awaiter(_this4, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n          return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  _context3.next = 2;\n                  return this.isConnected();\n\n                case 2:\n                  resolve(Object.values(this.store.get('rooms')).filter(function (room) {\n                    return room.status === MatrixRoomStatus.LEFT;\n                  }));\n\n                case 3:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3, this);\n        }));\n      });\n    }\n    /**\n     * Initiate the connection to the matrix node and log in\n     *\n     * @param user\n     */\n\n  }, {\n    key: \"start\",\n    value: function start(user) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        var _this5 = this;\n\n        var response, initialPollingResult;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return this.userService.login(user.id, user.password, user.deviceId);\n\n              case 2:\n                response = _context7.sent;\n                _context7.next = 5;\n                return this.store.update({\n                  accessToken: response.access_token\n                });\n\n              case 5:\n                initialPollingResult = new Promise(function (resolve, reject) {\n                  return __awaiter(_this5, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n                    var _this6 = this;\n\n                    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n                      while (1) {\n                        switch (_context6.prev = _context6.next) {\n                          case 0:\n                            _context6.next = 2;\n                            return this.poll(0, function (pollingResponse) {\n                              return __awaiter(_this6, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n                                return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                                  while (1) {\n                                    switch (_context4.prev = _context4.next) {\n                                      case 0:\n                                        if (!this.store.get('isRunning')) {\n                                          resolve();\n                                        }\n\n                                        _context4.next = 3;\n                                        return this.store.update({\n                                          isRunning: true,\n                                          syncToken: pollingResponse.next_batch,\n                                          pollingTimeout: 30000,\n                                          pollingRetries: 0,\n                                          rooms: MatrixRoom.fromSync(pollingResponse.rooms)\n                                        });\n\n                                      case 3:\n                                      case \"end\":\n                                        return _context4.stop();\n                                    }\n                                  }\n                                }, _callee4, this);\n                              }));\n                            }, function (error) {\n                              return __awaiter(_this6, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n                                return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n                                  while (1) {\n                                    switch (_context5.prev = _context5.next) {\n                                      case 0:\n                                        if (!this.store.get('isRunning')) {\n                                          reject(error);\n                                        }\n\n                                        _context5.next = 3;\n                                        return this.store.update({\n                                          isRunning: false,\n                                          pollingRetries: this.store.get('pollingRetries') + 1\n                                        });\n\n                                      case 3:\n                                      case \"end\":\n                                        return _context5.stop();\n                                    }\n                                  }\n                                }, _callee5, this);\n                              }));\n                            });\n\n                          case 2:\n                          case \"end\":\n                            return _context6.stop();\n                        }\n                      }\n                    }, _callee6, this);\n                  }));\n                });\n                initialPollingResult.then(function () {\n                  _this5._isReady.resolve();\n                }).catch(console.error);\n                return _context7.abrupt(\"return\", initialPollingResult);\n\n              case 8:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n    }\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                return _context8.abrupt(\"return\", this._isReady.promise);\n\n              case 1:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n    }\n    /**\n     * Stop all running requests\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                logger.log(\"MATRIX CLIENT STOPPED\");\n                this.isActive = false;\n                this._isReady = new ExposedPromise();\n                return _context9.abrupt(\"return\", this.httpClient.cancelAllRequests());\n\n              case 4:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n    }\n    /**\n     * Subscribe to new matrix events\n     *\n     * @param event\n     * @param listener\n     */\n\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(event, listener) {\n      this.eventEmitter.on(event, listener);\n    }\n    /**\n     * Unsubscribe from matrix events\n     *\n     * @param event\n     * @param listener\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(event, listener) {\n      if (listener) {\n        this.eventEmitter.removeListener(event, listener);\n      } else {\n        this.eventEmitter.removeAllListeners(event);\n      }\n    }\n  }, {\n    key: \"getRoomById\",\n    value: function getRoomById(id) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.next = 2;\n                return this.isConnected();\n\n              case 2:\n                return _context10.abrupt(\"return\", this.store.getRoom(id));\n\n              case 3:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n    }\n    /**\n     * Create a private room with the supplied members\n     *\n     * @param members Members that will be in the room\n     */\n\n  }, {\n    key: \"createTrustedPrivateRoom\",\n    value: function createTrustedPrivateRoom() {\n      for (var _len = arguments.length, members = new Array(_len), _key = 0; _key < _len; _key++) {\n        members[_key] = arguments[_key];\n      }\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee12() {\n        var _this7 = this;\n\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.next = 2;\n                return this.isConnected();\n\n              case 2:\n                return _context12.abrupt(\"return\", this.requiresAuthorization('createRoom', function (accessToken) {\n                  return __awaiter(_this7, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee11() {\n                    var response;\n                    return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n                      while (1) {\n                        switch (_context11.prev = _context11.next) {\n                          case 0:\n                            _context11.next = 2;\n                            return this.roomService.createRoom(accessToken, {\n                              invite: members,\n                              preset: 'trusted_private_chat',\n                              is_direct: true\n                            });\n\n                          case 2:\n                            response = _context11.sent;\n                            return _context11.abrupt(\"return\", response.room_id);\n\n                          case 4:\n                          case \"end\":\n                            return _context11.stop();\n                        }\n                      }\n                    }, _callee11, this);\n                  }));\n                }));\n\n              case 3:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n    }\n    /**\n     * Invite user to rooms\n     *\n     * @param user The user to be invited\n     * @param roomsOrIds The rooms the user will be invited to\n     */\n\n  }, {\n    key: \"inviteToRooms\",\n    value: function inviteToRooms(user) {\n      for (var _len2 = arguments.length, roomsOrIds = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        roomsOrIds[_key2 - 1] = arguments[_key2];\n      }\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee13() {\n        var _this8 = this;\n\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                _context13.next = 2;\n                return this.isConnected();\n\n              case 2:\n                _context13.next = 4;\n                return this.requiresAuthorization('invite', function (accessToken) {\n                  return Promise.all(roomsOrIds.map(function (roomOrId) {\n                    var room = _this8.store.getRoom(roomOrId);\n\n                    _this8.roomService.inviteToRoom(accessToken, user, room).catch(function (error) {\n                      return logger.warn('inviteToRooms', error);\n                    });\n                  }));\n                });\n\n              case 4:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n    }\n    /**\n     * Join rooms\n     *\n     * @param roomsOrIds\n     */\n\n  }, {\n    key: \"joinRooms\",\n    value: function joinRooms() {\n      for (var _len3 = arguments.length, roomsOrIds = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        roomsOrIds[_key3] = arguments[_key3];\n      }\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee14() {\n        var _this9 = this;\n\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                _context14.next = 2;\n                return this.isConnected();\n\n              case 2:\n                _context14.next = 4;\n                return this.requiresAuthorization('join', function (accessToken) {\n                  return Promise.all(roomsOrIds.map(function (roomOrId) {\n                    var room = _this9.store.getRoom(roomOrId);\n\n                    return _this9.roomService.joinRoom(accessToken, room);\n                  }));\n                });\n\n              case 4:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n    }\n    /**\n     * Send a text message\n     *\n     * @param roomOrId\n     * @param message\n     */\n\n  }, {\n    key: \"sendTextMessage\",\n    value: function sendTextMessage(roomId, message) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee16() {\n        var _this10 = this;\n\n        return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                _context16.next = 2;\n                return this.isConnected();\n\n              case 2:\n                _context16.next = 4;\n                return this.requiresAuthorization('send', function (accessToken) {\n                  return __awaiter(_this10, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee15() {\n                    var txnId;\n                    return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n                      while (1) {\n                        switch (_context15.prev = _context15.next) {\n                          case 0:\n                            _context15.next = 2;\n                            return this.createTxnId();\n\n                          case 2:\n                            txnId = _context15.sent;\n                            return _context15.abrupt(\"return\", this.eventService.sendMessage(accessToken, roomId, {\n                              msgtype: 'm.text',\n                              body: message\n                            }, txnId));\n\n                          case 4:\n                          case \"end\":\n                            return _context15.stop();\n                        }\n                      }\n                    }, _callee15, this);\n                  }));\n                });\n\n              case 4:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n    }\n    /**\n     * Poll the server to get the latest data and get notified of changes\n     *\n     * @param interval\n     * @param onSyncSuccess\n     * @param onSyncError\n     */\n\n  }, {\n    key: \"poll\",\n    value: function poll(interval, onSyncSuccess, onSyncError) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee19() {\n        var _this11 = this;\n\n        var store, sync, pollSync;\n        return _regeneratorRuntime.wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                store = this.store;\n                sync = this.sync.bind(this);\n\n                pollSync = function pollSync(resolve, reject) {\n                  return __awaiter(_this11, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee18() {\n                    var _this12 = this;\n\n                    var continueSyncing, response;\n                    return _regeneratorRuntime.wrap(function _callee18$(_context18) {\n                      while (1) {\n                        switch (_context18.prev = _context18.next) {\n                          case 0:\n                            continueSyncing = false;\n                            _context18.prev = 1;\n                            _context18.next = 4;\n                            return sync();\n\n                          case 4:\n                            response = _context18.sent;\n                            onSyncSuccess(response);\n                            continueSyncing = true;\n                            _context18.next = 14;\n                            break;\n\n                          case 9:\n                            _context18.prev = 9;\n                            _context18.t0 = _context18[\"catch\"](1);\n                            onSyncError(_context18.t0);\n                            continueSyncing = store.get('pollingRetries') < MAX_POLLING_RETRIES; // console.warn('Could not sync:', error)\n\n                            if (continueSyncing && this.isActive) {\n                              logger.log('Retry syncing...');\n                            }\n\n                          case 14:\n                            _context18.prev = 14;\n\n                            if (this.isActive) {\n                              if (continueSyncing) {\n                                setTimeout(function () {\n                                  return __awaiter(_this12, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee17() {\n                                    return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n                                      while (1) {\n                                        switch (_context17.prev = _context17.next) {\n                                          case 0:\n                                            _context17.next = 2;\n                                            return pollSync(resolve, reject);\n\n                                          case 2:\n                                          case \"end\":\n                                            return _context17.stop();\n                                        }\n                                      }\n                                    }, _callee17);\n                                  }));\n                                }, interval);\n                              } else {\n                                reject(new Error(\"Max polling retries exeeded: \".concat(MAX_POLLING_RETRIES)));\n                              }\n                            } else {\n                              reject(new Error(\"Syncing stopped manually.\"));\n                            }\n\n                            return _context18.finish(14);\n\n                          case 17:\n                          case \"end\":\n                            return _context18.stop();\n                        }\n                      }\n                    }, _callee18, this, [[1, 9, 14, 17]]);\n                  }));\n                };\n\n                return _context19.abrupt(\"return\", new Promise(pollSync));\n\n              case 4:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, this);\n      }));\n    }\n    /**\n     * Get state from server\n     */\n\n  }, {\n    key: \"sync\",\n    value: function sync() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee21() {\n        var _this13 = this;\n\n        return _regeneratorRuntime.wrap(function _callee21$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                return _context21.abrupt(\"return\", this.requiresAuthorization('sync', function (accessToken) {\n                  return __awaiter(_this13, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee20() {\n                    return _regeneratorRuntime.wrap(function _callee20$(_context20) {\n                      while (1) {\n                        switch (_context20.prev = _context20.next) {\n                          case 0:\n                            return _context20.abrupt(\"return\", this.eventService.sync(accessToken, {\n                              pollingTimeout: this.store.get('pollingTimeout'),\n                              syncToken: this.store.get('syncToken')\n                            }));\n\n                          case 1:\n                          case \"end\":\n                            return _context20.stop();\n                        }\n                      }\n                    }, _callee20, this);\n                  }));\n                }));\n\n              case 1:\n              case \"end\":\n                return _context21.stop();\n            }\n          }\n        }, _callee21, this);\n      }));\n    }\n    /**\n     * A helper method that makes sure an access token is provided\n     *\n     * @param name\n     * @param action\n     */\n\n  }, {\n    key: \"requiresAuthorization\",\n    value: function requiresAuthorization(name, action) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee22() {\n        var storedToken;\n        return _regeneratorRuntime.wrap(function _callee22$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                storedToken = this.store.get('accessToken');\n\n                if (storedToken) {\n                  _context22.next = 3;\n                  break;\n                }\n\n                return _context22.abrupt(\"return\", Promise.reject(\"\".concat(name, \" requires authorization but no access token has been provided.\")));\n\n              case 3:\n                return _context22.abrupt(\"return\", action(storedToken));\n\n              case 4:\n              case \"end\":\n                return _context22.stop();\n            }\n          }\n        }, _callee22, this);\n      }));\n    }\n    /**\n     * Create a transaction ID\n     */\n\n  }, {\n    key: \"createTxnId\",\n    value: function createTxnId() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee23() {\n        var timestamp, counter;\n        return _regeneratorRuntime.wrap(function _callee23$(_context23) {\n          while (1) {\n            switch (_context23.prev = _context23.next) {\n              case 0:\n                timestamp = new Date().getTime();\n                counter = this.store.get('txnNo');\n                _context23.next = 4;\n                return this.store.update({\n                  txnNo: counter + 1\n                });\n\n              case 4:\n                return _context23.abrupt(\"return\", \"m\".concat(timestamp, \".\").concat(counter));\n\n              case 5:\n              case \"end\":\n                return _context23.stop();\n            }\n          }\n        }, _callee23, this);\n      }));\n    }\n  }], [{\n    key: \"create\",\n    value: function create(config) {\n      var store = new MatrixClientStore(config.storage);\n      var eventEmitter = new MatrixClientEventEmitter();\n      var httpClient = new MatrixHttpClient(config.baseUrl);\n      var accountService = new MatrixUserService(httpClient);\n      var roomService = new MatrixRoomService(httpClient);\n      var eventService = new MatrixEventService(httpClient);\n      return new MatrixClient(store, eventEmitter, accountService, roomService, eventService, httpClient);\n    }\n  }]);\n\n  return MatrixClient;\n}();","map":{"version":3,"sources":["../../../src/matrix-client/MatrixClient.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,SAAS,MAAT,QAAuB,iBAAvB;AACA,SAAS,cAAT,QAA+B,0BAA/B;AACA,SAAS,iBAAT,QAAkC,qBAAlC;AACA,SAAS,gBAAT,QAAiC,oBAAjC;AACA,SAAS,UAAT,EAAqB,gBAArB,QAA6C,qBAA7C;AACA,SAAS,iBAAT,QAAkC,8BAAlC;AACA,SAAS,iBAAT,QAAkC,8BAAlC;AACA,SAAS,kBAAT,QAAmC,+BAAnC;AAEA,SAAS,wBAAT,QAAyC,4BAAzC;AAGA,IAAM,MAAM,GAAG,IAAI,MAAJ,CAAW,cAAX,CAAf;AAaA,IAAM,mBAAmB,GAAG,CAA5B;AAEA;;AAEG;;AACH,WAAa,YAAb;AAIE,wBACmB,KADnB,EAEmB,YAFnB,EAGmB,WAHnB,EAImB,WAJnB,EAKmB,YALnB,EAMmB,UANnB,EAM+C;AAAA;;AAAA;;AAL5B,SAAA,KAAA,GAAA,KAAA;AACA,SAAA,YAAA,GAAA,YAAA;AACA,SAAA,WAAA,GAAA,WAAA;AACA,SAAA,WAAA,GAAA,WAAA;AACA,SAAA,YAAA,GAAA,YAAA;AACA,SAAA,UAAA,GAAA,UAAA;AATX,SAAA,QAAA,GAAoB,IAApB;AACA,SAAA,QAAA,GAAiC,IAAI,cAAJ,EAAjC;AAUN,SAAK,KAAL,CAAW,cAAX,CAA0B,UAAC,QAAD,EAAW,QAAX,EAAqB,WAArB,EAAoC;AAC5D,MAAA,KAAI,CAAC,YAAL,CAAkB,cAAlB,CAAiC,QAAjC,EAA2C,QAA3C,EAAqD,WAArD;AACD,KAFD,EAEG,OAFH;AAGD;AAED;;;;AAIG;;;AArBL;AAAA;AAAA;AA0CE;;AAEG;AACH,mBAAsB;AAAA;;AACpB,aAAO,IAAI,OAAJ,CAAY,UAAO,OAAP;AAAA,eAAkB,SAAA,CAAA,MAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,wCAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACnC,yBAAM,KAAK,WAAL,EAAN;;AADmC;AAGnC,kBAAA,OAAO,CACL,MAAM,CAAC,MAAP,CAAc,KAAK,KAAL,CAAW,GAAX,CAAe,OAAf,CAAd,EAAuC,MAAvC,CACE,UAAC,IAAD;AAAA,2BAAU,IAAI,CAAC,MAAL,KAAgB,gBAAgB,CAAC,MAA3C;AAAA,mBADF,CADK,CAAP;;AAHmC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAA,EAAlB;AAAA,OAAZ,CAAP;AASD;AAED;;AAEG;;AA3DL;AAAA;AAAA,SA4DE,eAAuB;AAAA;;AACrB,aAAO,IAAI,OAAJ,CAAY,UAAO,OAAP;AAAA,eAAkB,SAAA,CAAA,MAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,wCAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACnC,yBAAM,KAAK,WAAL,EAAN;;AADmC;AAGnC,kBAAA,OAAO,CACL,MAAM,CAAC,MAAP,CAAc,KAAK,KAAL,CAAW,GAAX,CAAe,OAAf,CAAd,EAAuC,MAAvC,CACE,UAAC,IAAD;AAAA,2BAAU,IAAI,CAAC,MAAL,KAAgB,gBAAgB,CAAC,OAA3C;AAAA,mBADF,CADK,CAAP;;AAHmC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAA,EAAlB;AAAA,OAAZ,CAAP;AASD;AAED;;AAEG;;AA1EL;AAAA;AAAA,SA2EE,eAAoB;AAAA;;AAClB,aAAO,IAAI,OAAJ,CAAY,UAAO,OAAP;AAAA,eAAkB,SAAA,CAAA,MAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,wCAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACnC,yBAAM,KAAK,WAAL,EAAN;;AADmC;AAGnC,kBAAA,OAAO,CACL,MAAM,CAAC,MAAP,CAAc,KAAK,KAAL,CAAW,GAAX,CAAe,OAAf,CAAd,EAAuC,MAAvC,CACE,UAAC,IAAD;AAAA,2BAAU,IAAI,CAAC,MAAL,KAAgB,gBAAgB,CAAC,IAA3C;AAAA,mBADF,CADK,CAAP;;AAHmC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAA,EAAlB;AAAA,OAAZ,CAAP;AASD;AAED;;;;AAIG;;AA3FL;AAAA;AAAA,WA4Fe,eAAM,IAAN,EAA6B;;;;;;;;;;AACvB,uBAAM,KAAK,WAAL,CAAiB,KAAjB,CAAuB,IAAI,CAAC,EAA5B,EAAgC,IAAI,CAAC,QAArC,EAA+C,IAAI,CAAC,QAApD,CAAN;;;AAAX,gBAAA,Q;;AAEN,uBAAM,KAAK,KAAL,CAAW,MAAX,CAAkB;AACtB,kBAAA,WAAW,EAAE,QAAQ,CAAC;AADA,iBAAlB,CAAN;;;AAIM,gBAAA,oB,GAAuB,IAAI,OAAJ,CAAkB,UAAO,OAAP,EAAgB,MAAhB;AAAA,yBAA0B,SAAA,CAAA,MAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,wCAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AACvE,mCAAM,KAAK,IAAL,CACJ,CADI,EAEJ,UAAO,eAAP;AAAA,qCAA8C,SAAA,CAAA,MAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,wCAAA;AAAA;AAAA;AAAA;AAAA;AAC5C,4CAAI,CAAC,KAAK,KAAL,CAAW,GAAX,CAAe,WAAf,CAAL,EAAkC;AAChC,0CAAA,OAAO;AACR;;AAH2C;AAI5C,+CAAM,KAAK,KAAL,CAAW,MAAX,CAAkB;AACtB,0CAAA,SAAS,EAAE,IADW;AAEtB,0CAAA,SAAS,EAAE,eAAe,CAAC,UAFL;AAGtB,0CAAA,cAAc,EAAE,KAHM;AAItB,0CAAA,cAAc,EAAE,CAJM;AAKtB,0CAAA,KAAK,EAAE,UAAU,CAAC,QAAX,CAAoB,eAAe,CAAC,KAApC;AALe,yCAAlB,CAAN;;AAJ4C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+BAAA,EAA9C;AAAA,6BAFI,EAcJ,UAAO,KAAP;AAAA,qCAAgB,SAAA,CAAA,MAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,wCAAA;AAAA;AAAA;AAAA;AAAA;AACd,4CAAI,CAAC,KAAK,KAAL,CAAW,GAAX,CAAe,WAAf,CAAL,EAAkC;AAChC,0CAAA,MAAM,CAAC,KAAD,CAAN;AACD;;AAHa;AAId,+CAAM,KAAK,KAAL,CAAW,MAAX,CAAkB;AACtB,0CAAA,SAAS,EAAE,KADW;AAEtB,0CAAA,cAAc,EAAE,KAAK,KAAL,CAAW,GAAX,CAAe,gBAAf,IAAmC;AAF7B,yCAAlB,CAAN;;AAJc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+BAAA,EAAhB;AAAA,6BAdI,CAAN;;AADuE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAA,EAA1B;AAAA,iBAAlB,C;AA2B7B,gBAAA,oBAAoB,CACjB,IADH,CACQ,YAAK;AACT,kBAAA,MAAI,CAAC,QAAL,CAAc,OAAd;AACD,iBAHH,EAIG,KAJH,CAIS,OAAO,CAAC,KAJjB;kDAMO,oB;;;;;;;;;AACR;AArIH;AAAA;AAAA,WAuIe,uBAAW;;;;;;kDACf,KAAK,QAAL,CAAc,O;;;;;;;;;AACtB;AAED;;AAEG;;AA7IL;AAAA;AAAA,WA8Ie,gBAAI;;;;;;AACf,gBAAA,MAAM,CAAC,GAAP;AACA,qBAAK,QAAL,GAAgB,KAAhB;AACA,qBAAK,QAAL,GAAgB,IAAI,cAAJ,EAAhB;kDAEO,KAAK,UAAL,CAAgB,iBAAhB,E;;;;;;;;;AACR;AAED;;;;;AAKG;;AA3JL;AAAA;AAAA,WA4JS,mBACL,KADK,EAEL,QAFK,EAE0C;AAE/C,WAAK,YAAL,CAAkB,EAAlB,CAAqB,KAArB,EAA4B,QAA5B;AACD;AAED;;;;;AAKG;;AAxKL;AAAA;AAAA,WAyKS,qBACL,KADK,EAEL,QAFK,EAE6C;AAElD,UAAI,QAAJ,EAAc;AACZ,aAAK,YAAL,CAAkB,cAAlB,CAAiC,KAAjC,EAAwC,QAAxC;AACD,OAFD,MAEO;AACL,aAAK,YAAL,CAAkB,kBAAlB,CAAqC,KAArC;AACD;AACF;AAlLH;AAAA;AAAA,WAoLe,qBAAY,EAAZ,EAAsB;;;;;;;AACjC,uBAAM,KAAK,WAAL,EAAN;;;mDAEO,KAAK,KAAL,CAAW,OAAX,CAAmB,EAAnB,C;;;;;;;;;AACR;AAED;;;;AAIG;;AA9LL;AAAA;AAAA,WA+Le,oCAA6C;AAAA,wCAAjB,OAAiB;AAAjB,QAAA,OAAiB;AAAA;;;;;;;;;;AACxD,uBAAM,KAAK,WAAL,EAAN;;;mDAEO,KAAK,qBAAL,CAA2B,YAA3B,EAAyC,UAAO,WAAP;AAAA,yBAAsB,SAAA,CAAA,MAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,wCAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACnD,mCAAM,KAAK,WAAL,CAAiB,UAAjB,CAA4B,WAA5B,EAAyC;AAC9D,8BAAA,MAAM,EAAE,OADsD;AAE9D,8BAAA,MAAM,EAAE,sBAFsD;AAG9D,8BAAA,SAAS,EAAE;AAHmD,6BAAzC,CAAN;;AADmD;AAC9D,4BAAA,QAD8D;AAAA,+DAO7D,QAAQ,CAAC,OAPoD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAA,EAAtB;AAAA,iBAAzC,C;;;;;;;;;AASR;AAED;;;;;AAKG;;AAlNL;AAAA;AAAA,WAmNe,uBAAc,IAAd,EAAkE;AAAA,yCAAnC,UAAmC;AAAnC,QAAA,UAAmC;AAAA;;;;;;;;;;AAC7E,uBAAM,KAAK,WAAL,EAAN;;;;AAEA,uBAAM,KAAK,qBAAL,CAA2B,QAA3B,EAAqC,UAAC,WAAD;AAAA,yBACzC,OAAO,CAAC,GAAR,CACG,UAAoB,CAAC,GAArB,CAAyB,UAAC,QAAD,EAAa;AACrC,wBAAM,IAAI,GAAG,MAAI,CAAC,KAAL,CAAW,OAAX,CAAmB,QAAnB,CAAb;;AACA,oBAAA,MAAI,CAAC,WAAL,CACG,YADH,CACgB,WADhB,EAC6B,IAD7B,EACmC,IADnC,EAEG,KAFH,CAES,UAAC,KAAD;AAAA,6BAAW,MAAM,CAAC,IAAP,CAAY,eAAZ,EAA6B,KAA7B,CAAX;AAAA,qBAFT;AAGD,mBALA,CADH,CADyC;AAAA,iBAArC,CAAN;;;;;;;;;AAUD;AAED;;;;AAIG;;AAtOL;AAAA;AAAA,WAuOe,qBAAgD;AAAA,yCAAnC,UAAmC;AAAnC,QAAA,UAAmC;AAAA;;;;;;;;;;AAC3D,uBAAM,KAAK,WAAL,EAAN;;;;AAEA,uBAAM,KAAK,qBAAL,CAA2B,MAA3B,EAAmC,UAAC,WAAD;AAAA,yBACvC,OAAO,CAAC,GAAR,CACG,UAAoB,CAAC,GAArB,CAAyB,UAAC,QAAD,EAAa;AACrC,wBAAM,IAAI,GAAG,MAAI,CAAC,KAAL,CAAW,OAAX,CAAmB,QAAnB,CAAb;;AAEA,2BAAO,MAAI,CAAC,WAAL,CAAiB,QAAjB,CAA0B,WAA1B,EAAuC,IAAvC,CAAP;AACD,mBAJA,CADH,CADuC;AAAA,iBAAnC,CAAN;;;;;;;;;AASD;AAED;;;;;AAKG;;AA1PL;AAAA;AAAA,WA2Pe,yBAAgB,MAAhB,EAAgC,OAAhC,EAA+C;;;;;;;;;AAC1D,uBAAM,KAAK,WAAL,EAAN;;;;AAEA,uBAAM,KAAK,qBAAL,CAA2B,MAA3B,EAAmC,UAAO,WAAP;AAAA,yBAAsB,SAAA,CAAA,OAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,wCAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC/C,mCAAM,KAAK,WAAL,EAAN;;AAD+C;AACvD,4BAAA,KADuD;AAAA,+DAGtD,KAAK,YAAL,CAAkB,WAAlB,CACL,WADK,EAEL,MAFK,EAGL;AACE,8BAAA,OAAO,EAAE,QADX;AAEE,8BAAA,IAAI,EAAE;AAFR,6BAHK,EAOL,KAPK,CAHsD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAA,EAAtB;AAAA,iBAAnC,CAAN;;;;;;;;;AAaD;AAED;;;;;;AAMG;;AAnRL;AAAA;AAAA,WAoRgB,cACZ,QADY,EAEZ,aAFY,EAGZ,WAHY,EAGyB;;;;;;;;;AAE/B,gBAAA,K,GAAQ,KAAK,K;AACb,gBAAA,I,GAAO,KAAK,IAAL,CAAU,IAAV,CAAe,IAAf,C;;AAEP,gBAAA,Q,GAAW,SAAX,QAAW,CACf,OADe,EAEf,MAFe;AAAA,yBAGE,SAAA,CAAA,OAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,wCAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AACb,4BAAA,eADa,GACc,KADd;AAAA;AAAA;AAGE,mCAAM,IAAI,EAAV;;AAHF;AAGT,4BAAA,QAHS;AAIf,4BAAA,aAAa,CAAC,QAAD,CAAb;AAEA,4BAAA,eAAe,GAAG,IAAlB;AANe;AAAA;;AAAA;AAAA;AAAA;AAQf,4BAAA,WAAW,eAAX;AAEA,4BAAA,eAAe,GAAG,KAAK,CAAC,GAAN,CAAU,gBAAV,IAA8B,mBAAhD,CAVe,CAWf;;AACA,gCAAI,eAAe,IAAI,KAAK,QAA5B,EAAsC;AACpC,8BAAA,MAAM,CAAC,GAAP,CAAW,kBAAX;AACD;;AAdc;AAAA;;AAgBf,gCAAI,KAAK,QAAT,EAAmB;AACjB,kCAAI,eAAJ,EAAqB;AACnB,gCAAA,UAAU,CAAC;AAAA,yCAAW,SAAA,CAAA,OAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,wCAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACpB,mDAAM,QAAQ,CAAC,OAAD,EAAU,MAAV,CAAd;;AADoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mCAAA,EAAX;AAAA,iCAAD,EAEP,QAFO,CAAV;AAGD,+BAJD,MAIO;AACL,gCAAA,MAAM,CAAC,IAAI,KAAJ,wCAA0C,mBAA1C,EAAD,CAAN;AACD;AACF,6BARD,MAQO;AACL,8BAAA,MAAM,CAAC,IAAI,KAAJ,6BAAD,CAAN;AACD;;AA1Bc;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAA,EAHF;AAAA,iB;;mDAiCV,IAAI,OAAJ,CAAY,QAAZ,C;;;;;;;;;AACR;AAED;;AAEG;;AAlUL;AAAA;AAAA,WAmUgB,gBAAI;;;;;;;;mDACT,KAAK,qBAAL,CAA2B,MAA3B,EAAmC,UAAO,WAAP;AAAA,yBAAsB,SAAA,CAAA,OAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,wCAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+DAC9D,KAAK,YAAL,CAAkB,IAAlB,CAAuB,WAAvB,EAAoC;AAClC,8BAAA,cAAc,EAAE,KAAK,KAAL,CAAW,GAAX,CAAe,gBAAf,CADkB;AAElC,8BAAA,SAAS,EAAE,KAAK,KAAL,CAAW,GAAX,CAAe,WAAf;AAFuB,6BAApC,CAD8D;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAA,EAAtB;AAAA,iBAAnC,C;;;;;;;;;AAMR;AAED;;;;;AAKG;;AAjVL;AAAA;AAAA,WAkVgB,+BACZ,IADY,EAEZ,MAFY,EAE+B;;;;;;;AAErC,gBAAA,W,GAAkC,KAAK,KAAL,CAAW,GAAX,CAAe,aAAf,C;;oBAEnC,W;;;;;mDACI,OAAO,CAAC,MAAR,WAAkB,IAAlB,oE;;;mDAGF,MAAM,CAAC,WAAD,C;;;;;;;;;AACd;AAED;;AAEG;;AAjWL;AAAA;AAAA,WAkWgB,uBAAW;;;;;;;AACjB,gBAAA,S,GAAY,IAAI,IAAJ,GAAW,OAAX,E;AACZ,gBAAA,O,GAAU,KAAK,KAAL,CAAW,GAAX,CAAe,OAAf,C;;AAEhB,uBAAM,KAAK,KAAL,CAAW,MAAX,CAAkB;AACtB,kBAAA,KAAK,EAAE,OAAO,GAAG;AADK,iBAAlB,CAAN;;;8DAIW,S,cAAa,O;;;;;;;;;AACzB;AA3WH;AAAA;AAAA,WAsBS,gBAAc,MAAd,EAAyC;AAC9C,UAAM,KAAK,GAAG,IAAI,iBAAJ,CAAsB,MAAM,CAAC,OAA7B,CAAd;AACA,UAAM,YAAY,GAAG,IAAI,wBAAJ,EAArB;AAEA,UAAM,UAAU,GAAG,IAAI,gBAAJ,CAAqB,MAAM,CAAC,OAA5B,CAAnB;AAEA,UAAM,cAAc,GAAG,IAAI,iBAAJ,CAAsB,UAAtB,CAAvB;AACA,UAAM,WAAW,GAAG,IAAI,iBAAJ,CAAsB,UAAtB,CAApB;AACA,UAAM,YAAY,GAAG,IAAI,kBAAJ,CAAuB,UAAvB,CAArB;AAEA,aAAO,IAAI,YAAJ,CACL,KADK,EAEL,YAFK,EAGL,cAHK,EAIL,WAJK,EAKL,YALK,EAML,UANK,CAAP;AAQD;AAxCH;;AAAA;AAAA","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Logger } from '../utils/Logger';\nimport { ExposedPromise } from '../utils/exposed-promise';\nimport { MatrixClientStore } from './MatrixClientStore';\nimport { MatrixHttpClient } from './MatrixHttpClient';\nimport { MatrixRoom, MatrixRoomStatus } from './models/MatrixRoom';\nimport { MatrixRoomService } from './services/MatrixRoomService';\nimport { MatrixUserService } from './services/MatrixUserService';\nimport { MatrixEventService } from './services/MatrixEventService';\nimport { MatrixClientEventEmitter } from './MatrixClientEventEmitter';\nconst logger = new Logger('MatrixClient');\nconst MAX_POLLING_RETRIES = 3;\n/**\n * The matrix client used to connect to the matrix network\n */\nexport class MatrixClient {\n    constructor(store, eventEmitter, userService, roomService, eventService, httpClient) {\n        this.store = store;\n        this.eventEmitter = eventEmitter;\n        this.userService = userService;\n        this.roomService = roomService;\n        this.eventService = eventService;\n        this.httpClient = httpClient;\n        this.isActive = true;\n        this._isReady = new ExposedPromise();\n        this.store.onStateChanged((oldState, newState, stateChange) => {\n            this.eventEmitter.onStateChanged(oldState, newState, stateChange);\n        }, 'rooms');\n    }\n    /**\n     * Create a matrix client based on the options provided\n     *\n     * @param config\n     */\n    static create(config) {\n        const store = new MatrixClientStore(config.storage);\n        const eventEmitter = new MatrixClientEventEmitter();\n        const httpClient = new MatrixHttpClient(config.baseUrl);\n        const accountService = new MatrixUserService(httpClient);\n        const roomService = new MatrixRoomService(httpClient);\n        const eventService = new MatrixEventService(httpClient);\n        return new MatrixClient(store, eventEmitter, accountService, roomService, eventService, httpClient);\n    }\n    /**\n     * Return all the rooms we are currently part of\n     */\n    get joinedRooms() {\n        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {\n            yield this.isConnected();\n            resolve(Object.values(this.store.get('rooms')).filter((room) => room.status === MatrixRoomStatus.JOINED));\n        }));\n    }\n    /**\n     * Return all the rooms to which we have received invitations\n     */\n    get invitedRooms() {\n        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {\n            yield this.isConnected();\n            resolve(Object.values(this.store.get('rooms')).filter((room) => room.status === MatrixRoomStatus.INVITED));\n        }));\n    }\n    /**\n     * Return all the rooms that we left\n     */\n    get leftRooms() {\n        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {\n            yield this.isConnected();\n            resolve(Object.values(this.store.get('rooms')).filter((room) => room.status === MatrixRoomStatus.LEFT));\n        }));\n    }\n    /**\n     * Initiate the connection to the matrix node and log in\n     *\n     * @param user\n     */\n    start(user) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.userService.login(user.id, user.password, user.deviceId);\n            yield this.store.update({\n                accessToken: response.access_token\n            });\n            const initialPollingResult = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                yield this.poll(0, (pollingResponse) => __awaiter(this, void 0, void 0, function* () {\n                    if (!this.store.get('isRunning')) {\n                        resolve();\n                    }\n                    yield this.store.update({\n                        isRunning: true,\n                        syncToken: pollingResponse.next_batch,\n                        pollingTimeout: 30000,\n                        pollingRetries: 0,\n                        rooms: MatrixRoom.fromSync(pollingResponse.rooms)\n                    });\n                }), (error) => __awaiter(this, void 0, void 0, function* () {\n                    if (!this.store.get('isRunning')) {\n                        reject(error);\n                    }\n                    yield this.store.update({\n                        isRunning: false,\n                        pollingRetries: this.store.get('pollingRetries') + 1\n                    });\n                }));\n            }));\n            initialPollingResult\n                .then(() => {\n                this._isReady.resolve();\n            })\n                .catch(console.error);\n            return initialPollingResult;\n        });\n    }\n    isConnected() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._isReady.promise;\n        });\n    }\n    /**\n     * Stop all running requests\n     */\n    stop() {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.log(`MATRIX CLIENT STOPPED`);\n            this.isActive = false;\n            this._isReady = new ExposedPromise();\n            return this.httpClient.cancelAllRequests();\n        });\n    }\n    /**\n     * Subscribe to new matrix events\n     *\n     * @param event\n     * @param listener\n     */\n    subscribe(event, listener) {\n        this.eventEmitter.on(event, listener);\n    }\n    /**\n     * Unsubscribe from matrix events\n     *\n     * @param event\n     * @param listener\n     */\n    unsubscribe(event, listener) {\n        if (listener) {\n            this.eventEmitter.removeListener(event, listener);\n        }\n        else {\n            this.eventEmitter.removeAllListeners(event);\n        }\n    }\n    getRoomById(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.isConnected();\n            return this.store.getRoom(id);\n        });\n    }\n    /**\n     * Create a private room with the supplied members\n     *\n     * @param members Members that will be in the room\n     */\n    createTrustedPrivateRoom(...members) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.isConnected();\n            return this.requiresAuthorization('createRoom', (accessToken) => __awaiter(this, void 0, void 0, function* () {\n                const response = yield this.roomService.createRoom(accessToken, {\n                    invite: members,\n                    preset: 'trusted_private_chat',\n                    is_direct: true\n                });\n                return response.room_id;\n            }));\n        });\n    }\n    /**\n     * Invite user to rooms\n     *\n     * @param user The user to be invited\n     * @param roomsOrIds The rooms the user will be invited to\n     */\n    inviteToRooms(user, ...roomsOrIds) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.isConnected();\n            yield this.requiresAuthorization('invite', (accessToken) => Promise.all(roomsOrIds.map((roomOrId) => {\n                const room = this.store.getRoom(roomOrId);\n                this.roomService\n                    .inviteToRoom(accessToken, user, room)\n                    .catch((error) => logger.warn('inviteToRooms', error));\n            })));\n        });\n    }\n    /**\n     * Join rooms\n     *\n     * @param roomsOrIds\n     */\n    joinRooms(...roomsOrIds) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.isConnected();\n            yield this.requiresAuthorization('join', (accessToken) => Promise.all(roomsOrIds.map((roomOrId) => {\n                const room = this.store.getRoom(roomOrId);\n                return this.roomService.joinRoom(accessToken, room);\n            })));\n        });\n    }\n    /**\n     * Send a text message\n     *\n     * @param roomOrId\n     * @param message\n     */\n    sendTextMessage(roomId, message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.isConnected();\n            yield this.requiresAuthorization('send', (accessToken) => __awaiter(this, void 0, void 0, function* () {\n                const txnId = yield this.createTxnId();\n                return this.eventService.sendMessage(accessToken, roomId, {\n                    msgtype: 'm.text',\n                    body: message\n                }, txnId);\n            }));\n        });\n    }\n    /**\n     * Poll the server to get the latest data and get notified of changes\n     *\n     * @param interval\n     * @param onSyncSuccess\n     * @param onSyncError\n     */\n    poll(interval, onSyncSuccess, onSyncError) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const store = this.store;\n            const sync = this.sync.bind(this);\n            const pollSync = (resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                let continueSyncing = false;\n                try {\n                    const response = yield sync();\n                    onSyncSuccess(response);\n                    continueSyncing = true;\n                }\n                catch (error) {\n                    onSyncError(error);\n                    continueSyncing = store.get('pollingRetries') < MAX_POLLING_RETRIES;\n                    // console.warn('Could not sync:', error)\n                    if (continueSyncing && this.isActive) {\n                        logger.log('Retry syncing...');\n                    }\n                }\n                finally {\n                    if (this.isActive) {\n                        if (continueSyncing) {\n                            setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n                                yield pollSync(resolve, reject);\n                            }), interval);\n                        }\n                        else {\n                            reject(new Error(`Max polling retries exeeded: ${MAX_POLLING_RETRIES}`));\n                        }\n                    }\n                    else {\n                        reject(new Error(`Syncing stopped manually.`));\n                    }\n                }\n            });\n            return new Promise(pollSync);\n        });\n    }\n    /**\n     * Get state from server\n     */\n    sync() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.requiresAuthorization('sync', (accessToken) => __awaiter(this, void 0, void 0, function* () {\n                return this.eventService.sync(accessToken, {\n                    pollingTimeout: this.store.get('pollingTimeout'),\n                    syncToken: this.store.get('syncToken')\n                });\n            }));\n        });\n    }\n    /**\n     * A helper method that makes sure an access token is provided\n     *\n     * @param name\n     * @param action\n     */\n    requiresAuthorization(name, action) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const storedToken = this.store.get('accessToken');\n            if (!storedToken) {\n                return Promise.reject(`${name} requires authorization but no access token has been provided.`);\n            }\n            return action(storedToken);\n        });\n    }\n    /**\n     * Create a transaction ID\n     */\n    createTxnId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const timestamp = new Date().getTime();\n            const counter = this.store.get('txnNo');\n            yield this.store.update({\n                txnNo: counter + 1\n            });\n            return `m${timestamp}.${counter}`;\n        });\n    }\n}\n//# sourceMappingURL=MatrixClient.js.map"]},"metadata":{},"sourceType":"module"}