{"ast":null,"code":"import { MichelsonMap } from '@taquito/taquito';\nimport { Fa2MultiNftAssetCode, Fa2MultiNftFaucetCode } from '@tqtezos/minter-contracts';\nimport { Buffer } from 'buffer';\nimport { uploadIPFSJSON } from '../util/ipfs';\n\nfunction toHexString(input) {\n  return Buffer.from(input).toString('hex');\n}\n\nexport async function createFaucetContract(system, name) {\n  const metadataMap = new MichelsonMap();\n  const resp = await uploadIPFSJSON(system.config.ipfsApi, {\n    name,\n    description: 'An OpenMinter base collection contract.',\n    interfaces: ['TZIP-012', 'TZIP-016', 'TZIP-020'],\n    tokenCategory: 'collectibles'\n  });\n  metadataMap.set('', toHexString(resp.data.ipfsUri));\n  return await system.toolkit.wallet.originate({\n    code: Fa2MultiNftFaucetCode.code,\n    storage: {\n      assets: {\n        ledger: new MichelsonMap(),\n        next_token_id: 0,\n        operators: new MichelsonMap(),\n        token_metadata: new MichelsonMap()\n      },\n      metadata: metadataMap\n    }\n  }).send();\n}\nexport async function createAssetContract(system, metadata) {\n  const metadataMap = new MichelsonMap();\n  const resp = await uploadIPFSJSON(system.config.ipfsApi, {\n    description: 'An OpenMinter assets contract.',\n    interfaces: ['TZIP-012', 'TZIP-016', 'TZIP-020'],\n    tokenCategory: 'collectibles',\n    ...metadata\n  });\n  metadataMap.set('', toHexString(resp.data.ipfsUri));\n  return await system.toolkit.wallet.originate({\n    code: Fa2MultiNftAssetCode.code,\n    storage: {\n      assets: {\n        ledger: new MichelsonMap(),\n        next_token_id: 0,\n        operators: new MichelsonMap(),\n        token_metadata: new MichelsonMap()\n      },\n      admin: {\n        admin: system.tzPublicKey,\n        pending_admin: null,\n        paused: false\n      },\n      metadata: metadataMap\n    }\n  }).send();\n}\nexport async function mintToken(system, address, metadata) {\n  const contract = await system.toolkit.wallet.at(address);\n  const storage = await contract.storage();\n  const token_id = storage.assets.next_token_id;\n  const token_info = new MichelsonMap();\n  const resp = await uploadIPFSJSON(system.config.ipfsApi, { ...metadata,\n    decimals: 0,\n    isBooleanAmount: true\n  });\n  token_info.set('', toHexString(resp.data.ipfsUri));\n  return contract.methods.mint([{\n    owner: system.tzPublicKey,\n    token_metadata: {\n      token_id,\n      token_info\n    }\n  }]).send();\n}\nexport async function mintTokens(system, address, metadata) {\n  const contract = await system.toolkit.wallet.at(address);\n  const storage = await contract.storage();\n  const token_id = storage.assets.next_token_id;\n  const mints = [];\n\n  for (const [index, meta] of metadata.entries()) {\n    const token_info = new MichelsonMap();\n    const resp = await uploadIPFSJSON(system.config.ipfsApi, { ...meta,\n      decimals: 0,\n      isBooleanAmount: true\n    });\n    token_info.set('', toHexString(resp.data.ipfsUri));\n    mints.push({\n      owner: system.tzPublicKey,\n      token_metadata: {\n        token_id: token_id + index,\n        token_info\n      }\n    });\n  }\n\n  return contract.methods.mint(mints).send();\n}\nexport async function transferToken(system, contractAddress, tokenId, toAddress) {\n  const contract = await system.toolkit.wallet.at(contractAddress);\n  return contract.methods.transfer([{\n    from_: system.tzPublicKey,\n    txs: [{\n      to_: toAddress,\n      token_id: tokenId,\n      amount: 1\n    }]\n  }]).send();\n}\nexport async function listTokenForSale(system, marketplaceContract, tokenContract, tokenId, salePrice, saleQty) {\n  const contractM = await system.toolkit.wallet.at(marketplaceContract);\n  const contractT = await system.toolkit.wallet.at(tokenContract);\n  const batch = system.toolkit.wallet.batch([]).withContractCall(contractT.methods.update_operators([{\n    add_operator: {\n      owner: system.tzPublicKey,\n      operator: marketplaceContract,\n      token_id: tokenId\n    }\n  }]));\n  const sellSchema = contractM.parameterSchema.ExtractSchema()['sell'];\n\n  if (sellSchema.hasOwnProperty('sale_token_param_tez')) {\n    batch.withContractCall(contractM.methods.sell(salePrice, tokenContract, tokenId));\n  } else {\n    batch.withContractCall(contractM.methods.sell(tokenContract, tokenId, salePrice, saleQty));\n  }\n\n  return batch.send();\n}\nexport async function cancelTokenSaleLegacy(system, marketplaceContract, tokenContract, tokenId) {\n  const contractM = await system.toolkit.wallet.at(marketplaceContract);\n  const contractT = await system.toolkit.wallet.at(tokenContract);\n  const batch = system.toolkit.wallet.batch([]).withContractCall(contractM.methods.cancel(system.tzPublicKey, tokenContract, tokenId)).withContractCall(contractT.methods.update_operators([{\n    remove_operator: {\n      owner: system.tzPublicKey,\n      operator: marketplaceContract,\n      token_id: tokenId\n    }\n  }]));\n  return batch.send();\n}\nexport async function cancelTokenSale(system, marketplaceContract, tokenContract, tokenId, saleId) {\n  const contractM = await system.toolkit.wallet.at(marketplaceContract);\n  const contractT = await system.toolkit.wallet.at(tokenContract);\n  const batch = system.toolkit.wallet.batch([]).withContractCall(contractM.methods.cancel(saleId)).withContractCall(contractT.methods.update_operators([{\n    remove_operator: {\n      owner: system.tzPublicKey,\n      operator: marketplaceContract,\n      token_id: tokenId\n    }\n  }]));\n  return batch.send();\n}\nexport async function approveTokenOperator(system, contractAddress, tokenId, operatorAddress) {\n  const contract = await system.toolkit.wallet.at(contractAddress);\n  return contract.methods.update_operators([{\n    add_operator: {\n      owner: system.tzPublicKey,\n      operator: operatorAddress,\n      token_id: tokenId\n    }\n  }]).send();\n}\nexport async function removeTokenOperator(system, contractAddress, tokenId, operatorAddress) {\n  const contract = await system.toolkit.wallet.at(contractAddress);\n  return contract.methods.update_operators([{\n    remove_operator: {\n      owner: system.tzPublicKey,\n      operator: operatorAddress,\n      token_id: tokenId\n    }\n  }]).send();\n}\nexport async function buyTokenLegacy(system, marketplaceContract, tokenContract, tokenId, tokenSeller, salePrice) {\n  const contract = await system.toolkit.wallet.at(marketplaceContract);\n  return contract.methods.buy(tokenSeller, tokenContract, tokenId).send({\n    amount: salePrice\n  });\n}\nexport async function buyToken(system, marketplaceContract, saleId, salePrice) {\n  const contract = await system.toolkit.wallet.at(marketplaceContract);\n  return contract.methods.buy(saleId).send({\n    amount: salePrice\n  });\n}","map":{"version":3,"sources":["/Users/frankenstein/projects/minter/src/lib/nfts/actions.ts"],"names":["MichelsonMap","Fa2MultiNftAssetCode","Fa2MultiNftFaucetCode","Buffer","uploadIPFSJSON","toHexString","input","from","toString","createFaucetContract","system","name","metadataMap","resp","config","ipfsApi","description","interfaces","tokenCategory","set","data","ipfsUri","toolkit","wallet","originate","code","storage","assets","ledger","next_token_id","operators","token_metadata","metadata","send","createAssetContract","admin","tzPublicKey","pending_admin","paused","mintToken","address","contract","at","token_id","token_info","decimals","isBooleanAmount","methods","mint","owner","mintTokens","mints","index","meta","entries","push","transferToken","contractAddress","tokenId","toAddress","transfer","from_","txs","to_","amount","listTokenForSale","marketplaceContract","tokenContract","salePrice","saleQty","contractM","contractT","batch","withContractCall","update_operators","add_operator","operator","sellSchema","parameterSchema","ExtractSchema","hasOwnProperty","sell","cancelTokenSaleLegacy","cancel","remove_operator","cancelTokenSale","saleId","approveTokenOperator","operatorAddress","removeTokenOperator","buyTokenLegacy","tokenSeller","buy","buyToken"],"mappings":"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","sourcesContent":["import { MichelsonMap } from '@taquito/taquito';\nimport {\n  Fa2MultiNftAssetCode,\n  Fa2MultiNftFaucetCode\n} from '@tqtezos/minter-contracts';\nimport { Buffer } from 'buffer';\nimport { SystemWithWallet } from '../system';\nimport { uploadIPFSJSON } from '../util/ipfs';\nimport { NftMetadata } from './decoders';\n\nfunction toHexString(input: string) {\n  return Buffer.from(input).toString('hex');\n}\n\nexport async function createFaucetContract(\n  system: SystemWithWallet,\n  name: string\n) {\n  const metadataMap = new MichelsonMap<string, string>();\n  const resp = await uploadIPFSJSON(system.config.ipfsApi, {\n    name,\n    description: 'An OpenMinter base collection contract.',\n    interfaces: ['TZIP-012', 'TZIP-016', 'TZIP-020'],\n    tokenCategory: 'collectibles'\n  });\n  metadataMap.set('', toHexString(resp.data.ipfsUri));\n  return await system.toolkit.wallet\n    .originate({\n      code: Fa2MultiNftFaucetCode.code,\n      storage: {\n        assets: {\n          ledger: new MichelsonMap(),\n          next_token_id: 0,\n          operators: new MichelsonMap(),\n          token_metadata: new MichelsonMap()\n        },\n        metadata: metadataMap\n      }\n    })\n    .send();\n}\n\nexport async function createAssetContract(\n  system: SystemWithWallet,\n  metadata: Record<string, string>\n) {\n  const metadataMap = new MichelsonMap<string, string>();\n  const resp = await uploadIPFSJSON(system.config.ipfsApi, {\n    description: 'An OpenMinter assets contract.',\n    interfaces: ['TZIP-012', 'TZIP-016', 'TZIP-020'],\n    tokenCategory: 'collectibles',\n    ...metadata\n  });\n  metadataMap.set('', toHexString(resp.data.ipfsUri));\n  return await system.toolkit.wallet\n    .originate({\n      code: Fa2MultiNftAssetCode.code,\n      storage: {\n        assets: {\n          ledger: new MichelsonMap(),\n          next_token_id: 0,\n          operators: new MichelsonMap(),\n          token_metadata: new MichelsonMap()\n        },\n        admin: {\n          admin: system.tzPublicKey,\n          pending_admin: null,\n          paused: false\n        },\n        metadata: metadataMap\n      }\n    })\n    .send();\n}\n\nexport async function mintToken(\n  system: SystemWithWallet,\n  address: string,\n  metadata: NftMetadata\n) {\n  const contract = await system.toolkit.wallet.at(address);\n  const storage = await contract.storage<any>();\n\n  const token_id = storage.assets.next_token_id;\n  const token_info = new MichelsonMap<string, string>();\n  const resp = await uploadIPFSJSON(system.config.ipfsApi, {\n    ...metadata,\n    decimals: 0,\n    isBooleanAmount: true\n  });\n  token_info.set('', toHexString(resp.data.ipfsUri));\n\n  return contract.methods\n    .mint([\n      {\n        owner: system.tzPublicKey,\n        token_metadata: {\n          token_id,\n          token_info\n        }\n      }\n    ])\n    .send();\n}\n\ninterface MintData {\n  owner: string;\n  token_metadata: {\n    token_id: number;\n    token_info: MichelsonMap<string, string>;\n  };\n}\n\nexport async function mintTokens(\n  system: SystemWithWallet,\n  address: string,\n  metadata: NftMetadata[]\n) {\n  const contract = await system.toolkit.wallet.at(address);\n  const storage = await contract.storage<any>();\n\n  const token_id = storage.assets.next_token_id;\n  const mints: MintData[] = [];\n  for (const [index, meta] of metadata.entries()) {\n    const token_info = new MichelsonMap<string, string>();\n    const resp = await uploadIPFSJSON(system.config.ipfsApi, {\n      ...meta,\n      decimals: 0,\n      isBooleanAmount: true\n    });\n    token_info.set('', toHexString(resp.data.ipfsUri));\n    mints.push({\n      owner: system.tzPublicKey,\n      token_metadata: {\n        token_id: token_id + index,\n        token_info\n      }\n    });\n  }\n\n  return contract.methods.mint(mints).send();\n}\n\nexport async function transferToken(\n  system: SystemWithWallet,\n  contractAddress: string,\n  tokenId: number,\n  toAddress: string\n) {\n  const contract = await system.toolkit.wallet.at(contractAddress);\n  return contract.methods\n    .transfer([\n      {\n        from_: system.tzPublicKey,\n        txs: [{ to_: toAddress, token_id: tokenId, amount: 1 }]\n      }\n    ])\n    .send();\n}\n\nexport async function listTokenForSale(\n  system: SystemWithWallet,\n  marketplaceContract: string,\n  tokenContract: string,\n  tokenId: number,\n  salePrice: number,\n  saleQty: number\n) {\n  const contractM = await system.toolkit.wallet.at(marketplaceContract);\n  const contractT = await system.toolkit.wallet.at(tokenContract);\n  const batch = system.toolkit.wallet\n    .batch([])\n    .withContractCall(\n      contractT.methods.update_operators([\n        {\n          add_operator: {\n            owner: system.tzPublicKey,\n            operator: marketplaceContract,\n            token_id: tokenId\n          }\n        }\n      ])\n    );\n\n  const sellSchema = contractM.parameterSchema.ExtractSchema()['sell'];\n  if (sellSchema.hasOwnProperty('sale_token_param_tez')) {\n    batch.withContractCall(\n      contractM.methods.sell(salePrice, tokenContract, tokenId)\n    );\n  } else {\n    batch.withContractCall(\n      contractM.methods.sell(tokenContract, tokenId, salePrice, saleQty)\n    );\n  }\n\n  return batch.send();\n}\n\nexport async function cancelTokenSaleLegacy(\n  system: SystemWithWallet,\n  marketplaceContract: string,\n  tokenContract: string,\n  tokenId: number\n) {\n  const contractM = await system.toolkit.wallet.at(marketplaceContract);\n  const contractT = await system.toolkit.wallet.at(tokenContract);\n  const batch = system.toolkit.wallet\n    .batch([])\n    .withContractCall(\n      contractM.methods.cancel(system.tzPublicKey, tokenContract, tokenId)\n    )\n    .withContractCall(\n      contractT.methods.update_operators([\n        {\n          remove_operator: {\n            owner: system.tzPublicKey,\n            operator: marketplaceContract,\n            token_id: tokenId\n          }\n        }\n      ])\n    );\n  return batch.send();\n}\n\nexport async function cancelTokenSale(\n  system: SystemWithWallet,\n  marketplaceContract: string,\n  tokenContract: string,\n  tokenId: number,\n  saleId: number\n) {\n  const contractM = await system.toolkit.wallet.at(marketplaceContract);\n  const contractT = await system.toolkit.wallet.at(tokenContract);\n  const batch = system.toolkit.wallet\n    .batch([])\n    .withContractCall(\n      contractM.methods.cancel(saleId)\n    )\n    .withContractCall(\n      contractT.methods.update_operators([\n        {\n          remove_operator: {\n            owner: system.tzPublicKey,\n            operator: marketplaceContract,\n            token_id: tokenId\n          }\n        }\n      ])\n    );\n  return batch.send();\n}\n\nexport async function approveTokenOperator(\n  system: SystemWithWallet,\n  contractAddress: string,\n  tokenId: number,\n  operatorAddress: string\n) {\n  const contract = await system.toolkit.wallet.at(contractAddress);\n  return contract.methods\n    .update_operators([\n      {\n        add_operator: {\n          owner: system.tzPublicKey,\n          operator: operatorAddress,\n          token_id: tokenId\n        }\n      }\n    ])\n    .send();\n}\n\nexport async function removeTokenOperator(\n  system: SystemWithWallet,\n  contractAddress: string,\n  tokenId: number,\n  operatorAddress: string\n) {\n  const contract = await system.toolkit.wallet.at(contractAddress);\n  return contract.methods\n    .update_operators([\n      {\n        remove_operator: {\n          owner: system.tzPublicKey,\n          operator: operatorAddress,\n          token_id: tokenId\n        }\n      }\n    ])\n    .send();\n}\n\nexport async function buyTokenLegacy(\n  system: SystemWithWallet,\n  marketplaceContract: string,\n  tokenContract: string,\n  tokenId: number,\n  tokenSeller: string,\n  salePrice: number\n) {\n  const contract = await system.toolkit.wallet.at(marketplaceContract);\n  return contract.methods\n    .buy(tokenSeller, tokenContract, tokenId)\n    .send({ amount: salePrice });\n}\n\nexport async function buyToken(\n  system: SystemWithWallet,\n  marketplaceContract: string,\n  saleId: number,\n  salePrice: number\n) {\n  const contract = await system.toolkit.wallet.at(marketplaceContract);\n  return contract.methods\n    .buy(saleId)\n    .send({ amount: salePrice });\n}"]},"metadata":{},"sourceType":"module"}