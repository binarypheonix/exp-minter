{"ast":null,"code":"import { createSlice } from '@reduxjs/toolkit';\nimport { pushNotification, readNotification, deliverNotification } from './notificationsActions';\nimport { createAssetContractAction, mintTokenAction, transferTokenAction, listTokenAction, cancelTokenSaleAction, buyTokenAction } from '../async/actions';\nimport { connectWallet, disconnectWallet } from '../async/wallet';\nimport { getContractNftsQuery, getNftAssetContractQuery, getWalletAssetContractsQuery } from '../async/queries';\nconst initialState = [];\nconst slice = createSlice({\n  name: 'notifications',\n  initialState,\n  reducers: {},\n  extraReducers: ({\n    addCase\n  }) => {\n    addCase(pushNotification, (state, {\n      payload\n    }) => {\n      state.push(payload);\n    });\n    addCase(readNotification, (state, {\n      payload: requestId\n    }) => {\n      return state.map(n => {\n        return n.requestId === requestId ? { ...n,\n          read: true\n        } : n;\n      });\n    });\n    addCase(deliverNotification, (state, {\n      payload: requestId\n    }) => {\n      return state.map(n => {\n        return n.requestId === requestId ? { ...n,\n          delivered: true\n        } : n;\n      });\n    }); // Action errors are abstracted by their payloads. This allows us to iterate\n    // through a list of actions and assign a notification without individually\n    // matching against each one through `addCase`\n\n    [createAssetContractAction, mintTokenAction, transferTokenAction, listTokenAction, cancelTokenSaleAction, buyTokenAction, getContractNftsQuery, getNftAssetContractQuery, getWalletAssetContractsQuery, connectWallet, disconnectWallet].forEach(action => {\n      addCase(action.rejected, (state, {\n        meta,\n        payload\n      }) => {\n        if (!payload) {\n          return;\n        }\n\n        state.push({\n          requestId: meta.requestId,\n          read: false,\n          delivered: false,\n          status: 'error',\n          title: 'Error',\n          description: payload.message,\n          kind: payload.kind\n        });\n      });\n    });\n  }\n});\nexport default slice;","map":{"version":3,"sources":["/Users/frankenstein/projects/minter/src/reducer/slices/notifications.ts"],"names":["createSlice","pushNotification","readNotification","deliverNotification","createAssetContractAction","mintTokenAction","transferTokenAction","listTokenAction","cancelTokenSaleAction","buyTokenAction","connectWallet","disconnectWallet","getContractNftsQuery","getNftAssetContractQuery","getWalletAssetContractsQuery","initialState","slice","name","reducers","extraReducers","addCase","state","payload","push","requestId","map","n","read","delivered","forEach","action","rejected","meta","status","title","description","message","kind"],"mappings":"AAAA,SAASA,WAAT,QAA4B,kBAA5B;AACA,SACEC,gBADF,EAEEC,gBAFF,EAGEC,mBAHF,QAIO,wBAJP;AAKA,SACEC,yBADF,EAEEC,eAFF,EAGEC,mBAHF,EAIEC,eAJF,EAKEC,qBALF,EAMEC,cANF,QAOO,kBAPP;AAQA,SAASC,aAAT,EAAwBC,gBAAxB,QAAgD,iBAAhD;AACA,SACEC,oBADF,EAEEC,wBAFF,EAGEC,4BAHF,QAIO,kBAJP;AAmBA,MAAMC,YAA+B,GAAG,EAAxC;AAEA,MAAMC,KAAK,GAAGhB,WAAW,CAAC;AACxBiB,EAAAA,IAAI,EAAE,eADkB;AAExBF,EAAAA,YAFwB;AAGxBG,EAAAA,QAAQ,EAAE,EAHc;AAIxBC,EAAAA,aAAa,EAAE,CAAC;AAAEC,IAAAA;AAAF,GAAD,KAAiB;AAC9BA,IAAAA,OAAO,CAACnB,gBAAD,EAAmB,CAACoB,KAAD,EAAQ;AAAEC,MAAAA;AAAF,KAAR,KAAwB;AAChDD,MAAAA,KAAK,CAACE,IAAN,CAAWD,OAAX;AACD,KAFM,CAAP;AAIAF,IAAAA,OAAO,CAAClB,gBAAD,EAAmB,CAACmB,KAAD,EAAQ;AAAEC,MAAAA,OAAO,EAAEE;AAAX,KAAR,KAAmC;AAC3D,aAAOH,KAAK,CAACI,GAAN,CAAUC,CAAC,IAAI;AACpB,eAAOA,CAAC,CAACF,SAAF,KAAgBA,SAAhB,GAA4B,EAAE,GAAGE,CAAL;AAAQC,UAAAA,IAAI,EAAE;AAAd,SAA5B,GAAmDD,CAA1D;AACD,OAFM,CAAP;AAGD,KAJM,CAAP;AAMAN,IAAAA,OAAO,CAACjB,mBAAD,EAAsB,CAACkB,KAAD,EAAQ;AAAEC,MAAAA,OAAO,EAAEE;AAAX,KAAR,KAAmC;AAC9D,aAAOH,KAAK,CAACI,GAAN,CAAUC,CAAC,IAAI;AACpB,eAAOA,CAAC,CAACF,SAAF,KAAgBA,SAAhB,GAA4B,EAAE,GAAGE,CAAL;AAAQE,UAAAA,SAAS,EAAE;AAAnB,SAA5B,GAAwDF,CAA/D;AACD,OAFM,CAAP;AAGD,KAJM,CAAP,CAX8B,CAiB9B;AACA;AACA;;AACA,KACEtB,yBADF,EAEEC,eAFF,EAGEC,mBAHF,EAIEC,eAJF,EAKEC,qBALF,EAMEC,cANF,EAOEG,oBAPF,EAQEC,wBARF,EASEC,4BATF,EAUEJ,aAVF,EAWEC,gBAXF,EAYEkB,OAZF,CAYUC,MAAM,IAAI;AAClBV,MAAAA,OAAO,CAACU,MAAM,CAACC,QAAR,EAAkB,CAACV,KAAD,EAAQ;AAAEW,QAAAA,IAAF;AAAQV,QAAAA;AAAR,OAAR,KAA8B;AACrD,YAAI,CAACA,OAAL,EAAc;AACZ;AACD;;AACDD,QAAAA,KAAK,CAACE,IAAN,CAAW;AACTC,UAAAA,SAAS,EAAEQ,IAAI,CAACR,SADP;AAETG,UAAAA,IAAI,EAAE,KAFG;AAGTC,UAAAA,SAAS,EAAE,KAHF;AAITK,UAAAA,MAAM,EAAE,OAJC;AAKTC,UAAAA,KAAK,EAAE,OALE;AAMTC,UAAAA,WAAW,EAAEb,OAAO,CAACc,OANZ;AAOTC,UAAAA,IAAI,EAAEf,OAAO,CAACe;AAPL,SAAX;AASD,OAbM,CAAP;AAcD,KA3BD;AA4BD;AApDuB,CAAD,CAAzB;AAuDA,eAAerB,KAAf","sourcesContent":["import { createSlice } from '@reduxjs/toolkit';\nimport {\n  pushNotification,\n  readNotification,\n  deliverNotification\n} from './notificationsActions';\nimport {\n  createAssetContractAction,\n  mintTokenAction,\n  transferTokenAction,\n  listTokenAction,\n  cancelTokenSaleAction,\n  buyTokenAction\n} from '../async/actions';\nimport { connectWallet, disconnectWallet } from '../async/wallet';\nimport {\n  getContractNftsQuery,\n  getNftAssetContractQuery,\n  getWalletAssetContractsQuery\n} from '../async/queries';\nimport { ErrorKind } from '../async/errors';\n\nexport interface Notification {\n  requestId: string;\n  read: boolean;\n  delivered: boolean;\n  status: 'success' | 'pending' | 'error';\n  title: string;\n  description: string;\n  kind: ErrorKind | null;\n}\n\nexport type NotificationState = Notification[];\n\nconst initialState: NotificationState = [];\n\nconst slice = createSlice({\n  name: 'notifications',\n  initialState,\n  reducers: {},\n  extraReducers: ({ addCase }) => {\n    addCase(pushNotification, (state, { payload }) => {\n      state.push(payload);\n    });\n\n    addCase(readNotification, (state, { payload: requestId }) => {\n      return state.map(n => {\n        return n.requestId === requestId ? { ...n, read: true } : n;\n      });\n    });\n\n    addCase(deliverNotification, (state, { payload: requestId }) => {\n      return state.map(n => {\n        return n.requestId === requestId ? { ...n, delivered: true } : n;\n      });\n    });\n\n    // Action errors are abstracted by their payloads. This allows us to iterate\n    // through a list of actions and assign a notification without individually\n    // matching against each one through `addCase`\n    [\n      createAssetContractAction,\n      mintTokenAction,\n      transferTokenAction,\n      listTokenAction,\n      cancelTokenSaleAction,\n      buyTokenAction,\n      getContractNftsQuery,\n      getNftAssetContractQuery,\n      getWalletAssetContractsQuery,\n      connectWallet,\n      disconnectWallet\n    ].forEach(action => {\n      addCase(action.rejected, (state, { meta, payload }) => {\n        if (!payload) {\n          return;\n        }\n        state.push({\n          requestId: meta.requestId,\n          read: false,\n          delivered: false,\n          status: 'error',\n          title: 'Error',\n          description: payload.message,\n          kind: payload.kind\n        });\n      });\n    });\n  }\n});\n\nexport default slice;\n"]},"metadata":{},"sourceType":"module"}