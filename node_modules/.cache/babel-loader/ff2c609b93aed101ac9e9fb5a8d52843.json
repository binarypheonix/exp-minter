{"ast":null,"code":"import _regeneratorRuntime from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _classCallCheck from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { BeaconMessageType } from '..';\nimport { BEACON_VERSION } from '../constants';\nimport { getAddressFromPublicKey } from '../utils/crypto';\nimport { getAccountIdentifier } from '../utils/get-account-identifier';\nimport { BeaconErrorType } from '../types/BeaconErrorType';\nimport { Logger } from '../utils/Logger';\nvar logger = new Logger('OutgoingResponseInterceptor');\n/**\n * @internalapi\n *\n * The OutgoingResponseInterceptor is used in the WalletClient to intercept an outgoing response and enrich it with data.\n */\n\nexport var OutgoingResponseInterceptor = /*#__PURE__*/function () {\n  function OutgoingResponseInterceptor() {\n    _classCallCheck(this, OutgoingResponseInterceptor);\n  }\n\n  _createClass(OutgoingResponseInterceptor, null, [{\n    key: \"intercept\",\n    value: function intercept(config) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var senderId, request, message, ownAppMetadata, permissionManager, appMetadataManager, interceptorCallback, interceptorCallbackWrapper, response, errorData, _response, _response2, publicKey, address, appMetadata, permission, _response3, _response4, _response5;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                senderId = config.senderId, request = config.request, message = config.message, ownAppMetadata = config.ownAppMetadata, permissionManager = config.permissionManager, appMetadataManager = config.appMetadataManager, interceptorCallback = config.interceptorCallback; // TODO: Remove v1 compatibility in later version\n\n                interceptorCallbackWrapper = function interceptorCallbackWrapper(msg) {\n                  var untypedMessage = msg;\n                  untypedMessage.beaconId = msg.senderId;\n                  interceptorCallback(msg);\n                };\n\n                _context.t0 = message.type;\n                _context.next = _context.t0 === BeaconMessageType.Error ? 5 : _context.t0 === BeaconMessageType.Acknowledge ? 9 : _context.t0 === BeaconMessageType.PermissionResponse ? 12 : _context.t0 === BeaconMessageType.OperationResponse ? 36 : _context.t0 === BeaconMessageType.SignPayloadResponse ? 39 : _context.t0 === BeaconMessageType.BroadcastResponse ? 42 : 45;\n                break;\n\n              case 5:\n                response = {\n                  type: message.type,\n                  version: BEACON_VERSION,\n                  senderId: senderId,\n                  id: message.id,\n                  errorType: message.errorType\n                };\n\n                if (message.errorType === BeaconErrorType.TRANSACTION_INVALID_ERROR && message.errorData) {\n                  errorData = message.errorData; // Check if error data is in correct format\n\n                  if (Array.isArray(errorData) && errorData.every(function (item) {\n                    return Boolean(item.kind) && Boolean(item.id);\n                  })) {\n                    response.errorData = message.errorData;\n                  } else {\n                    logger.warn('ErrorData provided is not in correct format. It needs to be an array of RPC errors. It will not be included in the message sent to the dApp');\n                  }\n                }\n\n                interceptorCallbackWrapper(response);\n                return _context.abrupt(\"break\", 46);\n\n              case 9:\n                _response = {\n                  type: message.type,\n                  version: BEACON_VERSION,\n                  senderId: senderId,\n                  id: message.id\n                };\n                interceptorCallbackWrapper(_response);\n                return _context.abrupt(\"break\", 46);\n\n              case 12:\n                _response2 = Object.assign({\n                  senderId: senderId,\n                  version: BEACON_VERSION,\n                  appMetadata: ownAppMetadata\n                }, message); // TODO: Migration code. Remove sometime after 1.0.0 release.\n\n                publicKey = _response2.publicKey || _response2.pubkey || _response2.pubKey;\n                _context.next = 16;\n                return getAddressFromPublicKey(publicKey);\n\n              case 16:\n                address = _context.sent;\n                _context.next = 19;\n                return appMetadataManager.getAppMetadata(request.senderId);\n\n              case 19:\n                appMetadata = _context.sent;\n\n                if (appMetadata) {\n                  _context.next = 22;\n                  break;\n                }\n\n                throw new Error('AppMetadata not found');\n\n              case 22:\n                _context.next = 24;\n                return getAccountIdentifier(address, _response2.network);\n\n              case 24:\n                _context.t1 = _context.sent;\n                _context.t2 = request.senderId;\n                _context.t3 = appMetadata;\n                _context.t4 = address;\n                _context.t5 = publicKey;\n                _context.t6 = _response2.network;\n                _context.t7 = _response2.scopes;\n                _context.t8 = new Date().getTime();\n                permission = {\n                  accountIdentifier: _context.t1,\n                  senderId: _context.t2,\n                  appMetadata: _context.t3,\n                  website: '',\n                  address: _context.t4,\n                  publicKey: _context.t5,\n                  network: _context.t6,\n                  scopes: _context.t7,\n                  connectedAt: _context.t8\n                };\n                permissionManager.addPermission(permission).catch(console.error);\n                interceptorCallbackWrapper(_response2);\n                return _context.abrupt(\"break\", 46);\n\n              case 36:\n                _response3 = Object.assign({\n                  senderId: senderId,\n                  version: BEACON_VERSION\n                }, message);\n                interceptorCallbackWrapper(_response3);\n                return _context.abrupt(\"break\", 46);\n\n              case 39:\n                _response4 = Object.assign({\n                  senderId: senderId,\n                  version: BEACON_VERSION\n                }, message);\n                interceptorCallbackWrapper(_response4);\n                return _context.abrupt(\"break\", 46);\n\n              case 42:\n                _response5 = Object.assign({\n                  senderId: senderId,\n                  version: BEACON_VERSION\n                }, message);\n                interceptorCallbackWrapper(_response5);\n                return _context.abrupt(\"break\", 46);\n\n              case 45:\n                logger.log('intercept', 'Message not handled');\n\n              case 46:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n    }\n  }]);\n\n  return OutgoingResponseInterceptor;\n}();","map":{"version":3,"sources":["../../../src/interceptors/OutgoingResponseInterceptor.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BeaconMessageType } from '..';\nimport { BEACON_VERSION } from '../constants';\nimport { getAddressFromPublicKey } from '../utils/crypto';\nimport { getAccountIdentifier } from '../utils/get-account-identifier';\nimport { BeaconErrorType } from '../types/BeaconErrorType';\nimport { Logger } from '../utils/Logger';\nconst logger = new Logger('OutgoingResponseInterceptor');\n/**\n * @internalapi\n *\n * The OutgoingResponseInterceptor is used in the WalletClient to intercept an outgoing response and enrich it with data.\n */\nexport class OutgoingResponseInterceptor {\n    static intercept(config) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { senderId, request, message, ownAppMetadata, permissionManager, appMetadataManager, interceptorCallback } = config;\n            // TODO: Remove v1 compatibility in later version\n            const interceptorCallbackWrapper = (msg) => {\n                const untypedMessage = msg;\n                untypedMessage.beaconId = msg.senderId;\n                interceptorCallback(msg);\n            };\n            switch (message.type) {\n                case BeaconMessageType.Error: {\n                    const response = {\n                        type: message.type,\n                        version: BEACON_VERSION,\n                        senderId,\n                        id: message.id,\n                        errorType: message.errorType\n                    };\n                    if (message.errorType === BeaconErrorType.TRANSACTION_INVALID_ERROR && message.errorData) {\n                        const errorData = message.errorData;\n                        // Check if error data is in correct format\n                        if (Array.isArray(errorData) &&\n                            errorData.every((item) => Boolean(item.kind) && Boolean(item.id))) {\n                            response.errorData = message.errorData;\n                        }\n                        else {\n                            logger.warn('ErrorData provided is not in correct format. It needs to be an array of RPC errors. It will not be included in the message sent to the dApp');\n                        }\n                    }\n                    interceptorCallbackWrapper(response);\n                    break;\n                }\n                case BeaconMessageType.Acknowledge: {\n                    const response = {\n                        type: message.type,\n                        version: BEACON_VERSION,\n                        senderId,\n                        id: message.id\n                    };\n                    interceptorCallbackWrapper(response);\n                    break;\n                }\n                case BeaconMessageType.PermissionResponse: {\n                    const response = Object.assign({ senderId, version: BEACON_VERSION, appMetadata: ownAppMetadata }, message);\n                    // TODO: Migration code. Remove sometime after 1.0.0 release.\n                    const publicKey = response.publicKey || response.pubkey || response.pubKey;\n                    const address = yield getAddressFromPublicKey(publicKey);\n                    const appMetadata = yield appMetadataManager.getAppMetadata(request.senderId);\n                    if (!appMetadata) {\n                        throw new Error('AppMetadata not found');\n                    }\n                    const permission = {\n                        accountIdentifier: yield getAccountIdentifier(address, response.network),\n                        senderId: request.senderId,\n                        appMetadata,\n                        website: '',\n                        address,\n                        publicKey,\n                        network: response.network,\n                        scopes: response.scopes,\n                        connectedAt: new Date().getTime()\n                    };\n                    permissionManager.addPermission(permission).catch(console.error);\n                    interceptorCallbackWrapper(response);\n                    break;\n                }\n                case BeaconMessageType.OperationResponse:\n                    {\n                        const response = Object.assign({ senderId, version: BEACON_VERSION }, message);\n                        interceptorCallbackWrapper(response);\n                    }\n                    break;\n                case BeaconMessageType.SignPayloadResponse:\n                    {\n                        const response = Object.assign({ senderId, version: BEACON_VERSION }, message);\n                        interceptorCallbackWrapper(response);\n                    }\n                    break;\n                case BeaconMessageType.BroadcastResponse:\n                    {\n                        const response = Object.assign({ senderId, version: BEACON_VERSION }, message);\n                        interceptorCallbackWrapper(response);\n                    }\n                    break;\n                default:\n                    logger.log('intercept', 'Message not handled');\n            }\n        });\n    }\n}\n//# sourceMappingURL=OutgoingResponseInterceptor.js.map"]},"metadata":{},"sourceType":"module"}