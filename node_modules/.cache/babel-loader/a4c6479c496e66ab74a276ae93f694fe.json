{"ast":null,"code":"/**\n * A `Functor` is a type constructor which supports a mapping operation `map`.\n *\n * `map` can be used to turn functions `a -> b` into functions `f a -> f b` whose argument and return types use the type\n * constructor `f` to represent some computational context.\n *\n * Instances must satisfy the following laws:\n *\n * 1. Identity: `F.map(fa, a => a) <-> fa`\n * 2. Composition: `F.map(fa, a => bc(ab(a))) <-> F.map(F.map(fa, ab), bc)`\n *\n * @since 2.0.0\n */\nimport { pipe } from './function';\nexport function map(F, G) {\n  return function (f) {\n    return function (fa) {\n      return F.map(fa, function (ga) {\n        return G.map(ga, f);\n      });\n    };\n  };\n}\nexport function flap(F) {\n  return function (a) {\n    return function (fab) {\n      return F.map(fab, function (f) {\n        return f(a);\n      });\n    };\n  };\n}\nexport function bindTo(F) {\n  return function (name) {\n    return function (fa) {\n      return F.map(fa, function (a) {\n        var _a;\n\n        return _a = {}, _a[name] = a, _a;\n      });\n    };\n  };\n}\n/** @deprecated */\n\nexport function getFunctorComposition(F, G) {\n  var _map = map(F, G);\n\n  return {\n    map: function map(fga, f) {\n      return pipe(fga, _map(f));\n    }\n  };\n}","map":{"version":3,"sources":["/Users/frankenstein/projects/minter/node_modules/fp-ts/es6/Functor.js"],"names":["pipe","map","F","G","f","fa","ga","flap","a","fab","bindTo","name","_a","getFunctorComposition","_map","fga"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,IAAT,QAAqB,YAArB;AACA,OAAO,SAASC,GAAT,CAAaC,CAAb,EAAgBC,CAAhB,EAAmB;AACtB,SAAO,UAAUC,CAAV,EAAa;AAAE,WAAO,UAAUC,EAAV,EAAc;AAAE,aAAOH,CAAC,CAACD,GAAF,CAAMI,EAAN,EAAU,UAAUC,EAAV,EAAc;AAAE,eAAOH,CAAC,CAACF,GAAF,CAAMK,EAAN,EAAUF,CAAV,CAAP;AAAsB,OAAhD,CAAP;AAA2D,KAAlF;AAAqF,GAA3G;AACH;AACD,OAAO,SAASG,IAAT,CAAcL,CAAd,EAAiB;AACpB,SAAO,UAAUM,CAAV,EAAa;AAAE,WAAO,UAAUC,GAAV,EAAe;AAAE,aAAOP,CAAC,CAACD,GAAF,CAAMQ,GAAN,EAAW,UAAUL,CAAV,EAAa;AAAE,eAAOA,CAAC,CAACI,CAAD,CAAR;AAAc,OAAxC,CAAP;AAAmD,KAA3E;AAA8E,GAApG;AACH;AACD,OAAO,SAASE,MAAT,CAAgBR,CAAhB,EAAmB;AACtB,SAAO,UAAUS,IAAV,EAAgB;AAAE,WAAO,UAAUN,EAAV,EAAc;AAAE,aAAOH,CAAC,CAACD,GAAF,CAAMI,EAAN,EAAU,UAAUG,CAAV,EAAa;AAC1E,YAAII,EAAJ;;AACA,eAAQA,EAAE,GAAG,EAAL,EAASA,EAAE,CAACD,IAAD,CAAF,GAAWH,CAApB,EAAuBI,EAA/B;AACH,OAHsD,CAAP;AAG3C,KAHoB;AAGjB,GAHR;AAIH;AACD;;AACA,OAAO,SAASC,qBAAT,CAA+BX,CAA/B,EAAkCC,CAAlC,EAAqC;AACxC,MAAIW,IAAI,GAAGb,GAAG,CAACC,CAAD,EAAIC,CAAJ,CAAd;;AACA,SAAO;AACHF,IAAAA,GAAG,EAAE,aAAUc,GAAV,EAAeX,CAAf,EAAkB;AAAE,aAAOJ,IAAI,CAACe,GAAD,EAAMD,IAAI,CAACV,CAAD,CAAV,CAAX;AAA4B;AADlD,GAAP;AAGH","sourcesContent":["/**\n * A `Functor` is a type constructor which supports a mapping operation `map`.\n *\n * `map` can be used to turn functions `a -> b` into functions `f a -> f b` whose argument and return types use the type\n * constructor `f` to represent some computational context.\n *\n * Instances must satisfy the following laws:\n *\n * 1. Identity: `F.map(fa, a => a) <-> fa`\n * 2. Composition: `F.map(fa, a => bc(ab(a))) <-> F.map(F.map(fa, ab), bc)`\n *\n * @since 2.0.0\n */\nimport { pipe } from './function';\nexport function map(F, G) {\n    return function (f) { return function (fa) { return F.map(fa, function (ga) { return G.map(ga, f); }); }; };\n}\nexport function flap(F) {\n    return function (a) { return function (fab) { return F.map(fab, function (f) { return f(a); }); }; };\n}\nexport function bindTo(F) {\n    return function (name) { return function (fa) { return F.map(fa, function (a) {\n        var _a;\n        return (_a = {}, _a[name] = a, _a);\n    }); }; };\n}\n/** @deprecated */\nexport function getFunctorComposition(F, G) {\n    var _map = map(F, G);\n    return {\n        map: function (fga, f) { return pipe(fga, _map(f)); }\n    };\n}\n"]},"metadata":{},"sourceType":"module"}