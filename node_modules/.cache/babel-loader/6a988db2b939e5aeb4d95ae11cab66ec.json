{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.monoidProduct = exports.monoidSum = exports.monoidString = exports.getEndomorphismMonoid = exports.getFunctionMonoid = exports.monoidAny = exports.monoidAll = exports.fold = exports.getMeetMonoid = exports.getJoinMonoid = exports.getDualMonoid = exports.getStructMonoid = exports.getTupleMonoid = exports.concatAll = exports.monoidVoid = exports.tuple = exports.struct = exports.reverse = exports.max = exports.min = void 0;\n\nvar function_1 = require(\"./function\");\n\nvar _ = __importStar(require(\"./internal\"));\n\nvar Se = __importStar(require(\"./Semigroup\")); // -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n\n/**\n * Get a monoid where `concat` will return the minimum, based on the provided bounded order.\n *\n * The `empty` value is the `top` value.\n *\n * @example\n * import * as N from 'fp-ts/number'\n * import * as M from 'fp-ts/Monoid'\n *\n * const M1 = M.min(N.Bounded)\n *\n * assert.deepStrictEqual(M1.concat(1, 2), 1)\n *\n * @category constructors\n * @since 2.10.0\n */\n\n\nvar min = function (B) {\n  return {\n    concat: Se.min(B).concat,\n    empty: B.top\n  };\n};\n\nexports.min = min;\n/**\n * Get a monoid where `concat` will return the maximum, based on the provided bounded order.\n *\n * The `empty` value is the `bottom` value.\n *\n * @example\n * import * as N from 'fp-ts/number'\n * import * as M from 'fp-ts/Monoid'\n *\n * const M1 = M.max(N.Bounded)\n *\n * assert.deepStrictEqual(M1.concat(1, 2), 2)\n *\n * @category constructors\n * @since 2.10.0\n */\n\nvar max = function (B) {\n  return {\n    concat: Se.max(B).concat,\n    empty: B.bottom\n  };\n};\n\nexports.max = max; // -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * The dual of a `Monoid`, obtained by swapping the arguments of `concat`.\n *\n * @example\n * import { reverse } from 'fp-ts/Monoid'\n * import * as S from 'fp-ts/string'\n *\n * assert.deepStrictEqual(reverse(S.Monoid).concat('a', 'b'), 'ba')\n *\n * @category combinators\n * @since 2.10.0\n */\n\nvar reverse = function (M) {\n  return {\n    concat: Se.reverse(M).concat,\n    empty: M.empty\n  };\n};\n\nexports.reverse = reverse;\n/**\n * Given a struct of monoids returns a monoid for the struct.\n *\n * @example\n * import { struct } from 'fp-ts/Monoid'\n * import * as N from 'fp-ts/number'\n *\n * interface Point {\n *   readonly x: number\n *   readonly y: number\n * }\n *\n * const M = struct<Point>({\n *   x: N.MonoidSum,\n *   y: N.MonoidSum\n * })\n *\n * assert.deepStrictEqual(M.concat({ x: 1, y: 2 }, { x: 3, y: 4 }), { x: 4, y: 6 })\n *\n * @category combinators\n * @since 2.10.0\n */\n\nvar struct = function (monoids) {\n  var empty = {};\n\n  for (var k in monoids) {\n    if (_.has.call(monoids, k)) {\n      empty[k] = monoids[k].empty;\n    }\n  }\n\n  return {\n    concat: Se.struct(monoids).concat,\n    empty: empty\n  };\n};\n\nexports.struct = struct;\n/**\n * Given a tuple of monoids returns a monoid for the tuple.\n *\n * @example\n * import { tuple } from 'fp-ts/Monoid'\n * import * as B from 'fp-ts/boolean'\n * import * as N from 'fp-ts/number'\n * import * as S from 'fp-ts/string'\n *\n * const M1 = tuple(S.Monoid, N.MonoidSum)\n * assert.deepStrictEqual(M1.concat(['a', 1], ['b', 2]), ['ab', 3])\n *\n * const M2 = tuple(S.Monoid, N.MonoidSum, B.MonoidAll)\n * assert.deepStrictEqual(M2.concat(['a', 1, true], ['b', 2, false]), ['ab', 3, false])\n *\n * @category combinators\n * @since 2.10.0\n */\n\nvar tuple = function () {\n  var monoids = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    monoids[_i] = arguments[_i];\n  }\n\n  return {\n    concat: Se.tuple.apply(Se, monoids).concat,\n    empty: monoids.map(function (m) {\n      return m.empty;\n    })\n  };\n};\n\nexports.tuple = tuple;\n/**\n * @category instances\n * @since 2.0.0\n */\n\nexports.monoidVoid = {\n  concat: Se.semigroupVoid.concat,\n  empty: undefined\n}; // -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\n/**\n * Given a sequence of `as`, concat them and return the total.\n *\n * If `as` is empty, return the monoid `empty` value.\n *\n * @example\n * import { concatAll } from 'fp-ts/Monoid'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(concatAll(N.MonoidSum)([1, 2, 3]), 6)\n * assert.deepStrictEqual(concatAll(N.MonoidSum)([]), 0)\n *\n * @since 2.10.0\n */\n\nvar concatAll = function (M) {\n  return Se.concatAll(M)(M.empty);\n};\n\nexports.concatAll = concatAll; // -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n\n/**\n * Use [`tuple`](#tuple) instead.\n *\n * @category combinators\n * @since 2.0.0\n * @deprecated\n */\n\nexports.getTupleMonoid = exports.tuple;\n/**\n * Use [`struct`](#struct) instead.\n *\n * @category combinators\n * @since 2.0.0\n * @deprecated\n */\n\nexports.getStructMonoid = exports.struct;\n/**\n * Use [`reverse`](#reverse) instead.\n *\n * @category combinators\n * @since 2.0.0\n * @deprecated\n */\n\nexports.getDualMonoid = exports.reverse;\n/**\n * Use [`max`](#max) instead.\n *\n * @category constructors\n * @since 2.0.0\n * @deprecated\n */\n\nexports.getJoinMonoid = exports.max;\n/**\n * Use [`min`](#min) instead.\n *\n * @category constructors\n * @since 2.0.0\n * @deprecated\n */\n\nexports.getMeetMonoid = exports.min;\n/**\n * Use [`concatAll`](#concatall) instead.\n *\n * @since 2.0.0\n * @deprecated\n */\n\nexports.fold = exports.concatAll;\n/**\n * Use [`MonoidAll`](./boolean.ts.html#monoidall) instead.\n *\n * @category instances\n * @since 2.0.0\n * @deprecated\n */\n\nexports.monoidAll = {\n  // tslint:disable-next-line: deprecation\n  concat: Se.semigroupAll.concat,\n  empty: true\n};\n/**\n * Use [`MonoidAny`](./boolean.ts.html#MonoidAny) instead.\n *\n * @category instances\n * @since 2.0.0\n * @deprecated\n */\n\nexports.monoidAny = {\n  // tslint:disable-next-line: deprecation\n  concat: Se.semigroupAny.concat,\n  empty: false\n};\n/**\n * Use [`getMonoid`](./function.ts.html#getMonoid) instead.\n *\n * @category instances\n * @since 2.0.0\n * @deprecated\n */\n\nexports.getFunctionMonoid = function_1.getMonoid;\n/**\n * Use [`getEndomorphismMonoid`](./function.ts.html#getEndomorphismMonoid) instead.\n *\n * **Note**. The execution order in [`getEndomorphismMonoid`](./function.ts.html#getEndomorphismMonoid) is reversed.\n *\n * @category instances\n * @since 2.0.0\n * @deprecated\n */\n\nvar getEndomorphismMonoid = function () {\n  return exports.reverse(function_1.getEndomorphismMonoid());\n};\n\nexports.getEndomorphismMonoid = getEndomorphismMonoid;\n/**\n * Use [`Monoid`](./string.ts.html#Monoid) instead.\n *\n * @category instances\n * @since 2.0.0\n * @deprecated\n */\n\nexports.monoidString = {\n  // tslint:disable-next-line: deprecation\n  concat: Se.semigroupString.concat,\n  empty: ''\n};\n/**\n * Use [`MonoidSum`](./number.ts.html#MonoidSum) instead.\n *\n * @category instances\n * @since 2.0.0\n * @deprecated\n */\n\nexports.monoidSum = {\n  // tslint:disable-next-line: deprecation\n  concat: Se.semigroupSum.concat,\n  empty: 0\n};\n/**\n * Use [`MonoidProduct`](./number.ts.html#MonoidProduct) instead.\n *\n * @category instances\n * @since 2.0.0\n * @deprecated\n */\n\nexports.monoidProduct = {\n  // tslint:disable-next-line: deprecation\n  concat: Se.semigroupProduct.concat,\n  empty: 1\n};","map":{"version":3,"sources":["/Users/frankenstein/projects/minter/node_modules/fp-ts/lib/Monoid.js"],"names":["__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__importStar","mod","__esModule","result","prototype","hasOwnProperty","call","exports","monoidProduct","monoidSum","monoidString","getEndomorphismMonoid","getFunctionMonoid","monoidAny","monoidAll","fold","getMeetMonoid","getJoinMonoid","getDualMonoid","getStructMonoid","getTupleMonoid","concatAll","monoidVoid","tuple","struct","reverse","max","min","function_1","require","_","Se","B","concat","empty","top","bottom","M","monoids","has","_i","arguments","length","apply","map","semigroupVoid","semigroupAll","semigroupAny","getMonoid","semigroupString","semigroupSum","semigroupProduct"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.monoidProduct = exports.monoidSum = exports.monoidString = exports.getEndomorphismMonoid = exports.getFunctionMonoid = exports.monoidAny = exports.monoidAll = exports.fold = exports.getMeetMonoid = exports.getJoinMonoid = exports.getDualMonoid = exports.getStructMonoid = exports.getTupleMonoid = exports.concatAll = exports.monoidVoid = exports.tuple = exports.struct = exports.reverse = exports.max = exports.min = void 0;\nvar function_1 = require(\"./function\");\nvar _ = __importStar(require(\"./internal\"));\nvar Se = __importStar(require(\"./Semigroup\"));\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Get a monoid where `concat` will return the minimum, based on the provided bounded order.\n *\n * The `empty` value is the `top` value.\n *\n * @example\n * import * as N from 'fp-ts/number'\n * import * as M from 'fp-ts/Monoid'\n *\n * const M1 = M.min(N.Bounded)\n *\n * assert.deepStrictEqual(M1.concat(1, 2), 1)\n *\n * @category constructors\n * @since 2.10.0\n */\nvar min = function (B) { return ({\n    concat: Se.min(B).concat,\n    empty: B.top\n}); };\nexports.min = min;\n/**\n * Get a monoid where `concat` will return the maximum, based on the provided bounded order.\n *\n * The `empty` value is the `bottom` value.\n *\n * @example\n * import * as N from 'fp-ts/number'\n * import * as M from 'fp-ts/Monoid'\n *\n * const M1 = M.max(N.Bounded)\n *\n * assert.deepStrictEqual(M1.concat(1, 2), 2)\n *\n * @category constructors\n * @since 2.10.0\n */\nvar max = function (B) { return ({\n    concat: Se.max(B).concat,\n    empty: B.bottom\n}); };\nexports.max = max;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * The dual of a `Monoid`, obtained by swapping the arguments of `concat`.\n *\n * @example\n * import { reverse } from 'fp-ts/Monoid'\n * import * as S from 'fp-ts/string'\n *\n * assert.deepStrictEqual(reverse(S.Monoid).concat('a', 'b'), 'ba')\n *\n * @category combinators\n * @since 2.10.0\n */\nvar reverse = function (M) { return ({\n    concat: Se.reverse(M).concat,\n    empty: M.empty\n}); };\nexports.reverse = reverse;\n/**\n * Given a struct of monoids returns a monoid for the struct.\n *\n * @example\n * import { struct } from 'fp-ts/Monoid'\n * import * as N from 'fp-ts/number'\n *\n * interface Point {\n *   readonly x: number\n *   readonly y: number\n * }\n *\n * const M = struct<Point>({\n *   x: N.MonoidSum,\n *   y: N.MonoidSum\n * })\n *\n * assert.deepStrictEqual(M.concat({ x: 1, y: 2 }, { x: 3, y: 4 }), { x: 4, y: 6 })\n *\n * @category combinators\n * @since 2.10.0\n */\nvar struct = function (monoids) {\n    var empty = {};\n    for (var k in monoids) {\n        if (_.has.call(monoids, k)) {\n            empty[k] = monoids[k].empty;\n        }\n    }\n    return {\n        concat: Se.struct(monoids).concat,\n        empty: empty\n    };\n};\nexports.struct = struct;\n/**\n * Given a tuple of monoids returns a monoid for the tuple.\n *\n * @example\n * import { tuple } from 'fp-ts/Monoid'\n * import * as B from 'fp-ts/boolean'\n * import * as N from 'fp-ts/number'\n * import * as S from 'fp-ts/string'\n *\n * const M1 = tuple(S.Monoid, N.MonoidSum)\n * assert.deepStrictEqual(M1.concat(['a', 1], ['b', 2]), ['ab', 3])\n *\n * const M2 = tuple(S.Monoid, N.MonoidSum, B.MonoidAll)\n * assert.deepStrictEqual(M2.concat(['a', 1, true], ['b', 2, false]), ['ab', 3, false])\n *\n * @category combinators\n * @since 2.10.0\n */\nvar tuple = function () {\n    var monoids = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        monoids[_i] = arguments[_i];\n    }\n    return ({\n        concat: Se.tuple.apply(Se, monoids).concat,\n        empty: monoids.map(function (m) { return m.empty; })\n    });\n};\nexports.tuple = tuple;\n/**\n * @category instances\n * @since 2.0.0\n */\nexports.monoidVoid = {\n    concat: Se.semigroupVoid.concat,\n    empty: undefined\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Given a sequence of `as`, concat them and return the total.\n *\n * If `as` is empty, return the monoid `empty` value.\n *\n * @example\n * import { concatAll } from 'fp-ts/Monoid'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(concatAll(N.MonoidSum)([1, 2, 3]), 6)\n * assert.deepStrictEqual(concatAll(N.MonoidSum)([]), 0)\n *\n * @since 2.10.0\n */\nvar concatAll = function (M) { return Se.concatAll(M)(M.empty); };\nexports.concatAll = concatAll;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use [`tuple`](#tuple) instead.\n *\n * @category combinators\n * @since 2.0.0\n * @deprecated\n */\nexports.getTupleMonoid = exports.tuple;\n/**\n * Use [`struct`](#struct) instead.\n *\n * @category combinators\n * @since 2.0.0\n * @deprecated\n */\nexports.getStructMonoid = exports.struct;\n/**\n * Use [`reverse`](#reverse) instead.\n *\n * @category combinators\n * @since 2.0.0\n * @deprecated\n */\nexports.getDualMonoid = exports.reverse;\n/**\n * Use [`max`](#max) instead.\n *\n * @category constructors\n * @since 2.0.0\n * @deprecated\n */\nexports.getJoinMonoid = exports.max;\n/**\n * Use [`min`](#min) instead.\n *\n * @category constructors\n * @since 2.0.0\n * @deprecated\n */\nexports.getMeetMonoid = exports.min;\n/**\n * Use [`concatAll`](#concatall) instead.\n *\n * @since 2.0.0\n * @deprecated\n */\nexports.fold = exports.concatAll;\n/**\n * Use [`MonoidAll`](./boolean.ts.html#monoidall) instead.\n *\n * @category instances\n * @since 2.0.0\n * @deprecated\n */\nexports.monoidAll = {\n    // tslint:disable-next-line: deprecation\n    concat: Se.semigroupAll.concat,\n    empty: true\n};\n/**\n * Use [`MonoidAny`](./boolean.ts.html#MonoidAny) instead.\n *\n * @category instances\n * @since 2.0.0\n * @deprecated\n */\nexports.monoidAny = {\n    // tslint:disable-next-line: deprecation\n    concat: Se.semigroupAny.concat,\n    empty: false\n};\n/**\n * Use [`getMonoid`](./function.ts.html#getMonoid) instead.\n *\n * @category instances\n * @since 2.0.0\n * @deprecated\n */\nexports.getFunctionMonoid = function_1.getMonoid;\n/**\n * Use [`getEndomorphismMonoid`](./function.ts.html#getEndomorphismMonoid) instead.\n *\n * **Note**. The execution order in [`getEndomorphismMonoid`](./function.ts.html#getEndomorphismMonoid) is reversed.\n *\n * @category instances\n * @since 2.0.0\n * @deprecated\n */\nvar getEndomorphismMonoid = function () { return exports.reverse(function_1.getEndomorphismMonoid()); };\nexports.getEndomorphismMonoid = getEndomorphismMonoid;\n/**\n * Use [`Monoid`](./string.ts.html#Monoid) instead.\n *\n * @category instances\n * @since 2.0.0\n * @deprecated\n */\nexports.monoidString = {\n    // tslint:disable-next-line: deprecation\n    concat: Se.semigroupString.concat,\n    empty: ''\n};\n/**\n * Use [`MonoidSum`](./number.ts.html#MonoidSum) instead.\n *\n * @category instances\n * @since 2.0.0\n * @deprecated\n */\nexports.monoidSum = {\n    // tslint:disable-next-line: deprecation\n    concat: Se.semigroupSum.concat,\n    empty: 0\n};\n/**\n * Use [`MonoidProduct`](./number.ts.html#MonoidProduct) instead.\n *\n * @category instances\n * @since 2.0.0\n * @deprecated\n */\nexports.monoidProduct = {\n    // tslint:disable-next-line: deprecation\n    concat: Se.semigroupProduct.concat,\n    empty: 1\n};\n"]},"metadata":{},"sourceType":"script"}