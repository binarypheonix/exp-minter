{"ast":null,"code":"var _assertThisInitialized = require(\"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _wrapNativeSuper = require(\"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\n\nvar _slicedToArray = require(\"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _toConsumableArray = require(\"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _objectSpread = require(\"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _classCallCheck = require(\"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\n/*\nCSV Parse\n\nPlease look at the [project documentation](https://csv.js.org/parse/) for\nadditional information.\n*/\nvar _require = require('stream'),\n    Transform = _require.Transform;\n\nvar ResizeableBuffer = require('./ResizeableBuffer'); // white space characters\n// https://en.wikipedia.org/wiki/Whitespace_character\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes#Types\n// \\f\\n\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff\n\n\nvar tab = 9;\nvar nl = 10; // \\n, 0x0A in hexadecimal, 10 in decimal\n\nvar np = 12;\nvar cr = 13; // \\r, 0x0D in hexadÃ©cimal, 13 in decimal\n\nvar space = 32;\nvar boms = {\n  // Note, the following are equals:\n  // Buffer.from(\"\\ufeff\")\n  // Buffer.from([239, 187, 191])\n  // Buffer.from('EFBBBF', 'hex')\n  'utf8': Buffer.from([239, 187, 191]),\n  // Note, the following are equals:\n  // Buffer.from \"\\ufeff\", 'utf16le\n  // Buffer.from([255, 254])\n  'utf16le': Buffer.from([255, 254])\n};\n\nvar Parser = /*#__PURE__*/function (_Transform) {\n  \"use strict\";\n\n  _inherits(Parser, _Transform);\n\n  var _super = _createSuper(Parser);\n\n  function Parser() {\n    var _this;\n\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Parser);\n\n    _this = _super.call(this, _objectSpread(_objectSpread(_objectSpread({}, {\n      readableObjectMode: true\n    }), opts), {}, {\n      encoding: null\n    }));\n    _this.__originalOptions = opts;\n\n    _this.__normalizeOptions(opts);\n\n    return _this;\n  }\n\n  _createClass(Parser, [{\n    key: \"__normalizeOptions\",\n    value: function __normalizeOptions(opts) {\n      var options = {}; // Merge with user options\n\n      for (var opt in opts) {\n        options[underscore(opt)] = opts[opt];\n      } // Normalize option `encoding`\n      // Note: defined first because other options depends on it\n      // to convert chars/strings into buffers.\n\n\n      if (options.encoding === undefined || options.encoding === true) {\n        options.encoding = 'utf8';\n      } else if (options.encoding === null || options.encoding === false) {\n        options.encoding = null;\n      } else if (typeof options.encoding !== 'string' && options.encoding !== null) {\n        throw new CsvError('CSV_INVALID_OPTION_ENCODING', ['Invalid option encoding:', 'encoding must be a string or null to return a buffer,', \"got \".concat(JSON.stringify(options.encoding))], options);\n      } // Normalize option `bom`\n\n\n      if (options.bom === undefined || options.bom === null || options.bom === false) {\n        options.bom = false;\n      } else if (options.bom !== true) {\n        throw new CsvError('CSV_INVALID_OPTION_BOM', ['Invalid option bom:', 'bom must be true,', \"got \".concat(JSON.stringify(options.bom))], options);\n      } // Normalize option `cast`\n\n\n      var fnCastField = null;\n\n      if (options.cast === undefined || options.cast === null || options.cast === false || options.cast === '') {\n        options.cast = undefined;\n      } else if (typeof options.cast === 'function') {\n        fnCastField = options.cast;\n        options.cast = true;\n      } else if (options.cast !== true) {\n        throw new CsvError('CSV_INVALID_OPTION_CAST', ['Invalid option cast:', 'cast must be true or a function,', \"got \".concat(JSON.stringify(options.cast))], options);\n      } // Normalize option `cast_date`\n\n\n      if (options.cast_date === undefined || options.cast_date === null || options.cast_date === false || options.cast_date === '') {\n        options.cast_date = false;\n      } else if (options.cast_date === true) {\n        options.cast_date = function (value) {\n          var date = Date.parse(value);\n          return !isNaN(date) ? new Date(date) : value;\n        };\n      } else if (typeof options.cast_date !== 'function') {\n        throw new CsvError('CSV_INVALID_OPTION_CAST_DATE', ['Invalid option cast_date:', 'cast_date must be true or a function,', \"got \".concat(JSON.stringify(options.cast_date))], options);\n      } // Normalize option `columns`\n\n\n      var fnFirstLineToHeaders = null;\n\n      if (options.columns === true) {\n        // Fields in the first line are converted as-is to columns\n        fnFirstLineToHeaders = undefined;\n      } else if (typeof options.columns === 'function') {\n        fnFirstLineToHeaders = options.columns;\n        options.columns = true;\n      } else if (Array.isArray(options.columns)) {\n        options.columns = normalizeColumnsArray(options.columns);\n      } else if (options.columns === undefined || options.columns === null || options.columns === false) {\n        options.columns = false;\n      } else {\n        throw new CsvError('CSV_INVALID_OPTION_COLUMNS', ['Invalid option columns:', 'expect an object, a function or true,', \"got \".concat(JSON.stringify(options.columns))], options);\n      } // Normalize option `columns_duplicates_to_array`\n\n\n      if (options.columns_duplicates_to_array === undefined || options.columns_duplicates_to_array === null || options.columns_duplicates_to_array === false) {\n        options.columns_duplicates_to_array = false;\n      } else if (options.columns_duplicates_to_array !== true) {\n        throw new CsvError('CSV_INVALID_OPTION_COLUMNS_DUPLICATES_TO_ARRAY', ['Invalid option columns_duplicates_to_array:', 'expect an boolean,', \"got \".concat(JSON.stringify(options.columns_duplicates_to_array))], options);\n      } // Normalize option `comment`\n\n\n      if (options.comment === undefined || options.comment === null || options.comment === false || options.comment === '') {\n        options.comment = null;\n      } else {\n        if (typeof options.comment === 'string') {\n          options.comment = Buffer.from(options.comment, options.encoding);\n        }\n\n        if (!Buffer.isBuffer(options.comment)) {\n          throw new CsvError('CSV_INVALID_OPTION_COMMENT', ['Invalid option comment:', 'comment must be a buffer or a string,', \"got \".concat(JSON.stringify(options.comment))], options);\n        }\n      } // Normalize option `delimiter`\n\n\n      var delimiter_json = JSON.stringify(options.delimiter);\n      if (!Array.isArray(options.delimiter)) options.delimiter = [options.delimiter];\n\n      if (options.delimiter.length === 0) {\n        throw new CsvError('CSV_INVALID_OPTION_DELIMITER', ['Invalid option delimiter:', 'delimiter must be a non empty string or buffer or array of string|buffer,', \"got \".concat(delimiter_json)], options);\n      }\n\n      options.delimiter = options.delimiter.map(function (delimiter) {\n        if (delimiter === undefined || delimiter === null || delimiter === false) {\n          return Buffer.from(',', options.encoding);\n        }\n\n        if (typeof delimiter === 'string') {\n          delimiter = Buffer.from(delimiter, options.encoding);\n        }\n\n        if (!Buffer.isBuffer(delimiter) || delimiter.length === 0) {\n          throw new CsvError('CSV_INVALID_OPTION_DELIMITER', ['Invalid option delimiter:', 'delimiter must be a non empty string or buffer or array of string|buffer,', \"got \".concat(delimiter_json)], options);\n        }\n\n        return delimiter;\n      }); // Normalize option `escape`\n\n      if (options.escape === undefined || options.escape === true) {\n        options.escape = Buffer.from('\"', options.encoding);\n      } else if (typeof options.escape === 'string') {\n        options.escape = Buffer.from(options.escape, options.encoding);\n      } else if (options.escape === null || options.escape === false) {\n        options.escape = null;\n      }\n\n      if (options.escape !== null) {\n        if (!Buffer.isBuffer(options.escape)) {\n          throw new Error(\"Invalid Option: escape must be a buffer, a string or a boolean, got \".concat(JSON.stringify(options.escape)));\n        }\n      } // Normalize option `from`\n\n\n      if (options.from === undefined || options.from === null) {\n        options.from = 1;\n      } else {\n        if (typeof options.from === 'string' && /\\d+/.test(options.from)) {\n          options.from = parseInt(options.from);\n        }\n\n        if (Number.isInteger(options.from)) {\n          if (options.from < 0) {\n            throw new Error(\"Invalid Option: from must be a positive integer, got \".concat(JSON.stringify(opts.from)));\n          }\n        } else {\n          throw new Error(\"Invalid Option: from must be an integer, got \".concat(JSON.stringify(options.from)));\n        }\n      } // Normalize option `from_line`\n\n\n      if (options.from_line === undefined || options.from_line === null) {\n        options.from_line = 1;\n      } else {\n        if (typeof options.from_line === 'string' && /\\d+/.test(options.from_line)) {\n          options.from_line = parseInt(options.from_line);\n        }\n\n        if (Number.isInteger(options.from_line)) {\n          if (options.from_line <= 0) {\n            throw new Error(\"Invalid Option: from_line must be a positive integer greater than 0, got \".concat(JSON.stringify(opts.from_line)));\n          }\n        } else {\n          throw new Error(\"Invalid Option: from_line must be an integer, got \".concat(JSON.stringify(opts.from_line)));\n        }\n      } // Normalize options `ignore_last_delimiters`\n\n\n      if (options.ignore_last_delimiters === undefined || options.ignore_last_delimiters === null) {\n        options.ignore_last_delimiters = false;\n      } else if (typeof options.ignore_last_delimiters === 'number') {\n        options.ignore_last_delimiters = Math.floor(options.ignore_last_delimiters);\n\n        if (options.ignore_last_delimiters === 0) {\n          options.ignore_last_delimiters = false;\n        }\n      } else if (typeof options.ignore_last_delimiters !== 'boolean') {\n        throw new CsvError('CSV_INVALID_OPTION_IGNORE_LAST_DELIMITERS', ['Invalid option `ignore_last_delimiters`:', 'the value must be a boolean value or an integer,', \"got \".concat(JSON.stringify(options.ignore_last_delimiters))], options);\n      }\n\n      if (options.ignore_last_delimiters === true && options.columns === false) {\n        throw new CsvError('CSV_IGNORE_LAST_DELIMITERS_REQUIRES_COLUMNS', ['The option `ignore_last_delimiters`', 'requires the activation of the `columns` option'], options);\n      } // Normalize option `info`\n\n\n      if (options.info === undefined || options.info === null || options.info === false) {\n        options.info = false;\n      } else if (options.info !== true) {\n        throw new Error(\"Invalid Option: info must be true, got \".concat(JSON.stringify(options.info)));\n      } // Normalize option `max_record_size`\n\n\n      if (options.max_record_size === undefined || options.max_record_size === null || options.max_record_size === false) {\n        options.max_record_size = 0;\n      } else if (Number.isInteger(options.max_record_size) && options.max_record_size >= 0) {// Great, nothing to do\n      } else if (typeof options.max_record_size === 'string' && /\\d+/.test(options.max_record_size)) {\n        options.max_record_size = parseInt(options.max_record_size);\n      } else {\n        throw new Error(\"Invalid Option: max_record_size must be a positive integer, got \".concat(JSON.stringify(options.max_record_size)));\n      } // Normalize option `objname`\n\n\n      if (options.objname === undefined || options.objname === null || options.objname === false) {\n        options.objname = undefined;\n      } else if (Buffer.isBuffer(options.objname)) {\n        if (options.objname.length === 0) {\n          throw new Error(\"Invalid Option: objname must be a non empty buffer\");\n        }\n\n        if (options.encoding === null) {// Don't call `toString`, leave objname as a buffer\n        } else {\n          options.objname = options.objname.toString(options.encoding);\n        }\n      } else if (typeof options.objname === 'string') {\n        if (options.objname.length === 0) {\n          throw new Error(\"Invalid Option: objname must be a non empty string\");\n        } // Great, nothing to do\n\n      } else {\n        throw new Error(\"Invalid Option: objname must be a string or a buffer, got \".concat(options.objname));\n      } // Normalize option `on_record`\n\n\n      if (options.on_record === undefined || options.on_record === null) {\n        options.on_record = undefined;\n      } else if (typeof options.on_record !== 'function') {\n        throw new CsvError('CSV_INVALID_OPTION_ON_RECORD', ['Invalid option `on_record`:', 'expect a function,', \"got \".concat(JSON.stringify(options.on_record))], options);\n      } // Normalize option `quote`\n\n\n      if (options.quote === null || options.quote === false || options.quote === '') {\n        options.quote = null;\n      } else {\n        if (options.quote === undefined || options.quote === true) {\n          options.quote = Buffer.from('\"', options.encoding);\n        } else if (typeof options.quote === 'string') {\n          options.quote = Buffer.from(options.quote, options.encoding);\n        }\n\n        if (!Buffer.isBuffer(options.quote)) {\n          throw new Error(\"Invalid Option: quote must be a buffer or a string, got \".concat(JSON.stringify(options.quote)));\n        }\n      } // Normalize option `raw`\n\n\n      if (options.raw === undefined || options.raw === null || options.raw === false) {\n        options.raw = false;\n      } else if (options.raw !== true) {\n        throw new Error(\"Invalid Option: raw must be true, got \".concat(JSON.stringify(options.raw)));\n      } // Normalize option `record_delimiter`\n\n\n      if (!options.record_delimiter) {\n        options.record_delimiter = [];\n      } else if (!Array.isArray(options.record_delimiter)) {\n        options.record_delimiter = [options.record_delimiter];\n      }\n\n      options.record_delimiter = options.record_delimiter.map(function (rd) {\n        if (typeof rd === 'string') {\n          rd = Buffer.from(rd, options.encoding);\n        }\n\n        return rd;\n      }); // Normalize option `relax`\n\n      if (typeof options.relax === 'boolean') {// Great, nothing to do\n      } else if (options.relax === undefined || options.relax === null) {\n        options.relax = false;\n      } else {\n        throw new Error(\"Invalid Option: relax must be a boolean, got \".concat(JSON.stringify(options.relax)));\n      } // Normalize option `relax_column_count`\n\n\n      if (typeof options.relax_column_count === 'boolean') {// Great, nothing to do\n      } else if (options.relax_column_count === undefined || options.relax_column_count === null) {\n        options.relax_column_count = false;\n      } else {\n        throw new Error(\"Invalid Option: relax_column_count must be a boolean, got \".concat(JSON.stringify(options.relax_column_count)));\n      }\n\n      if (typeof options.relax_column_count_less === 'boolean') {// Great, nothing to do\n      } else if (options.relax_column_count_less === undefined || options.relax_column_count_less === null) {\n        options.relax_column_count_less = false;\n      } else {\n        throw new Error(\"Invalid Option: relax_column_count_less must be a boolean, got \".concat(JSON.stringify(options.relax_column_count_less)));\n      }\n\n      if (typeof options.relax_column_count_more === 'boolean') {// Great, nothing to do\n      } else if (options.relax_column_count_more === undefined || options.relax_column_count_more === null) {\n        options.relax_column_count_more = false;\n      } else {\n        throw new Error(\"Invalid Option: relax_column_count_more must be a boolean, got \".concat(JSON.stringify(options.relax_column_count_more)));\n      } // Normalize option `skip_empty_lines`\n\n\n      if (typeof options.skip_empty_lines === 'boolean') {// Great, nothing to do\n      } else if (options.skip_empty_lines === undefined || options.skip_empty_lines === null) {\n        options.skip_empty_lines = false;\n      } else {\n        throw new Error(\"Invalid Option: skip_empty_lines must be a boolean, got \".concat(JSON.stringify(options.skip_empty_lines)));\n      } // Normalize option `skip_lines_with_empty_values`\n\n\n      if (typeof options.skip_lines_with_empty_values === 'boolean') {// Great, nothing to do\n      } else if (options.skip_lines_with_empty_values === undefined || options.skip_lines_with_empty_values === null) {\n        options.skip_lines_with_empty_values = false;\n      } else {\n        throw new Error(\"Invalid Option: skip_lines_with_empty_values must be a boolean, got \".concat(JSON.stringify(options.skip_lines_with_empty_values)));\n      } // Normalize option `skip_lines_with_error`\n\n\n      if (typeof options.skip_lines_with_error === 'boolean') {// Great, nothing to do\n      } else if (options.skip_lines_with_error === undefined || options.skip_lines_with_error === null) {\n        options.skip_lines_with_error = false;\n      } else {\n        throw new Error(\"Invalid Option: skip_lines_with_error must be a boolean, got \".concat(JSON.stringify(options.skip_lines_with_error)));\n      } // Normalize option `rtrim`\n\n\n      if (options.rtrim === undefined || options.rtrim === null || options.rtrim === false) {\n        options.rtrim = false;\n      } else if (options.rtrim !== true) {\n        throw new Error(\"Invalid Option: rtrim must be a boolean, got \".concat(JSON.stringify(options.rtrim)));\n      } // Normalize option `ltrim`\n\n\n      if (options.ltrim === undefined || options.ltrim === null || options.ltrim === false) {\n        options.ltrim = false;\n      } else if (options.ltrim !== true) {\n        throw new Error(\"Invalid Option: ltrim must be a boolean, got \".concat(JSON.stringify(options.ltrim)));\n      } // Normalize option `trim`\n\n\n      if (options.trim === undefined || options.trim === null || options.trim === false) {\n        options.trim = false;\n      } else if (options.trim !== true) {\n        throw new Error(\"Invalid Option: trim must be a boolean, got \".concat(JSON.stringify(options.trim)));\n      } // Normalize options `trim`, `ltrim` and `rtrim`\n\n\n      if (options.trim === true && opts.ltrim !== false) {\n        options.ltrim = true;\n      } else if (options.ltrim !== true) {\n        options.ltrim = false;\n      }\n\n      if (options.trim === true && opts.rtrim !== false) {\n        options.rtrim = true;\n      } else if (options.rtrim !== true) {\n        options.rtrim = false;\n      } // Normalize option `to`\n\n\n      if (options.to === undefined || options.to === null) {\n        options.to = -1;\n      } else {\n        if (typeof options.to === 'string' && /\\d+/.test(options.to)) {\n          options.to = parseInt(options.to);\n        }\n\n        if (Number.isInteger(options.to)) {\n          if (options.to <= 0) {\n            throw new Error(\"Invalid Option: to must be a positive integer greater than 0, got \".concat(JSON.stringify(opts.to)));\n          }\n        } else {\n          throw new Error(\"Invalid Option: to must be an integer, got \".concat(JSON.stringify(opts.to)));\n        }\n      } // Normalize option `to_line`\n\n\n      if (options.to_line === undefined || options.to_line === null) {\n        options.to_line = -1;\n      } else {\n        if (typeof options.to_line === 'string' && /\\d+/.test(options.to_line)) {\n          options.to_line = parseInt(options.to_line);\n        }\n\n        if (Number.isInteger(options.to_line)) {\n          if (options.to_line <= 0) {\n            throw new Error(\"Invalid Option: to_line must be a positive integer greater than 0, got \".concat(JSON.stringify(opts.to_line)));\n          }\n        } else {\n          throw new Error(\"Invalid Option: to_line must be an integer, got \".concat(JSON.stringify(opts.to_line)));\n        }\n      }\n\n      this.info = {\n        comment_lines: 0,\n        empty_lines: 0,\n        invalid_field_length: 0,\n        lines: 1,\n        records: 0\n      };\n      this.options = options;\n      this.state = {\n        bomSkipped: false,\n        castField: fnCastField,\n        commenting: false,\n        // Current error encountered by a record\n        error: undefined,\n        enabled: options.from_line === 1,\n        escaping: false,\n        // escapeIsQuote: options.escape === options.quote,\n        escapeIsQuote: Buffer.isBuffer(options.escape) && Buffer.isBuffer(options.quote) && Buffer.compare(options.escape, options.quote) === 0,\n        expectedRecordLength: options.columns === null ? 0 : options.columns.length,\n        field: new ResizeableBuffer(20),\n        firstLineToHeaders: fnFirstLineToHeaders,\n        info: Object.assign({}, this.info),\n        needMoreDataSize: Math.max.apply(Math, [// Skip if the remaining buffer smaller than comment\n        options.comment !== null ? options.comment.length : 0].concat(_toConsumableArray(options.delimiter.map(function (delimiter) {\n          return delimiter.length;\n        })), [// Skip if the remaining buffer can be escape sequence\n        options.quote !== null ? options.quote.length : 0])),\n        previousBuf: undefined,\n        quoting: false,\n        stop: false,\n        rawBuffer: new ResizeableBuffer(100),\n        record: [],\n        recordHasError: false,\n        record_length: 0,\n        recordDelimiterMaxLength: options.record_delimiter.length === 0 ? 2 : Math.max.apply(Math, _toConsumableArray(options.record_delimiter.map(function (v) {\n          return v.length;\n        }))),\n        trimChars: [Buffer.from(' ', options.encoding)[0], Buffer.from('\\t', options.encoding)[0]],\n        wasQuoting: false,\n        wasRowDelimiter: false\n      };\n    } // Implementation of `Transform._transform`\n\n  }, {\n    key: \"_transform\",\n    value: function _transform(buf, encoding, callback) {\n      if (this.state.stop === true) {\n        return;\n      }\n\n      var err = this.__parse(buf, false);\n\n      if (err !== undefined) {\n        this.state.stop = true;\n      }\n\n      callback(err);\n    } // Implementation of `Transform._flush`\n\n  }, {\n    key: \"_flush\",\n    value: function _flush(callback) {\n      if (this.state.stop === true) {\n        return;\n      }\n\n      var err = this.__parse(undefined, true);\n\n      callback(err);\n    } // Central parser implementation\n\n  }, {\n    key: \"__parse\",\n    value: function __parse(nextBuf, end) {\n      var _this$options = this.options,\n          bom = _this$options.bom,\n          comment = _this$options.comment,\n          escape = _this$options.escape,\n          from_line = _this$options.from_line,\n          info = _this$options.info,\n          ltrim = _this$options.ltrim,\n          max_record_size = _this$options.max_record_size,\n          quote = _this$options.quote,\n          raw = _this$options.raw,\n          relax = _this$options.relax,\n          rtrim = _this$options.rtrim,\n          skip_empty_lines = _this$options.skip_empty_lines,\n          to = _this$options.to,\n          to_line = _this$options.to_line;\n      var record_delimiter = this.options.record_delimiter;\n      var _this$state = this.state,\n          bomSkipped = _this$state.bomSkipped,\n          previousBuf = _this$state.previousBuf,\n          rawBuffer = _this$state.rawBuffer,\n          escapeIsQuote = _this$state.escapeIsQuote;\n      var buf;\n\n      if (previousBuf === undefined) {\n        if (nextBuf === undefined) {\n          // Handle empty string\n          this.push(null);\n          return;\n        } else {\n          buf = nextBuf;\n        }\n      } else if (previousBuf !== undefined && nextBuf === undefined) {\n        buf = previousBuf;\n      } else {\n        buf = Buffer.concat([previousBuf, nextBuf]);\n      } // Handle UTF BOM\n\n\n      if (bomSkipped === false) {\n        if (bom === false) {\n          this.state.bomSkipped = true;\n        } else if (buf.length < 3) {\n          // No enough data\n          if (end === false) {\n            // Wait for more data\n            this.state.previousBuf = buf;\n            return;\n          }\n        } else {\n          for (var encoding in boms) {\n            if (boms[encoding].compare(buf, 0, boms[encoding].length) === 0) {\n              // Skip BOM\n              buf = buf.slice(boms[encoding].length); // Renormalize original options with the new encoding\n\n              this.__normalizeOptions(_objectSpread(_objectSpread({}, this.__originalOptions), {}, {\n                encoding: encoding\n              }));\n\n              break;\n            }\n          }\n\n          this.state.bomSkipped = true;\n        }\n      }\n\n      var bufLen = buf.length;\n      var pos;\n\n      for (pos = 0; pos < bufLen; pos++) {\n        // Ensure we get enough space to look ahead\n        // There should be a way to move this out of the loop\n        if (this.__needMoreData(pos, bufLen, end)) {\n          break;\n        }\n\n        if (this.state.wasRowDelimiter === true) {\n          this.info.lines++;\n\n          if (info === true && this.state.record.length === 0 && this.state.field.length === 0 && this.state.wasQuoting === false) {\n            this.state.info = Object.assign({}, this.info);\n          }\n\n          this.state.wasRowDelimiter = false;\n        }\n\n        if (to_line !== -1 && this.info.lines > to_line) {\n          this.state.stop = true;\n          this.push(null);\n          return;\n        } // Auto discovery of record_delimiter, unix, mac and windows supported\n\n\n        if (this.state.quoting === false && record_delimiter.length === 0) {\n          var record_delimiterCount = this.__autoDiscoverRecordDelimiter(buf, pos);\n\n          if (record_delimiterCount) {\n            record_delimiter = this.options.record_delimiter;\n          }\n        }\n\n        var chr = buf[pos];\n\n        if (raw === true) {\n          rawBuffer.append(chr);\n        }\n\n        if ((chr === cr || chr === nl) && this.state.wasRowDelimiter === false) {\n          this.state.wasRowDelimiter = true;\n        } // Previous char was a valid escape char\n        // treat the current char as a regular char\n\n\n        if (this.state.escaping === true) {\n          this.state.escaping = false;\n        } else {\n          // Escape is only active inside quoted fields\n          // We are quoting, the char is an escape chr and there is a chr to escape\n          // if(escape !== null && this.state.quoting === true && chr === escape && pos + 1 < bufLen){\n          if (escape !== null && this.state.quoting === true && this.__isEscape(buf, pos, chr) && pos + escape.length < bufLen) {\n            if (escapeIsQuote) {\n              if (this.__isQuote(buf, pos + escape.length)) {\n                this.state.escaping = true;\n                pos += escape.length - 1;\n                continue;\n              }\n            } else {\n              this.state.escaping = true;\n              pos += escape.length - 1;\n              continue;\n            }\n          } // Not currently escaping and chr is a quote\n          // TODO: need to compare bytes instead of single char\n\n\n          if (this.state.commenting === false && this.__isQuote(buf, pos)) {\n            if (this.state.quoting === true) {\n              var nextChr = buf[pos + quote.length];\n\n              var isNextChrTrimable = rtrim && this.__isCharTrimable(nextChr);\n\n              var isNextChrComment = comment !== null && this.__compareBytes(comment, buf, pos + quote.length, nextChr);\n\n              var isNextChrDelimiter = this.__isDelimiter(buf, pos + quote.length, nextChr);\n\n              var isNextChrRecordDelimiter = record_delimiter.length === 0 ? this.__autoDiscoverRecordDelimiter(buf, pos + quote.length) : this.__isRecordDelimiter(nextChr, buf, pos + quote.length); // Escape a quote\n              // Treat next char as a regular character\n\n              if (escape !== null && this.__isEscape(buf, pos, chr) && this.__isQuote(buf, pos + escape.length)) {\n                pos += escape.length - 1;\n              } else if (!nextChr || isNextChrDelimiter || isNextChrRecordDelimiter || isNextChrComment || isNextChrTrimable) {\n                this.state.quoting = false;\n                this.state.wasQuoting = true;\n                pos += quote.length - 1;\n                continue;\n              } else if (relax === false) {\n                var err = this.__error(new CsvError('CSV_INVALID_CLOSING_QUOTE', ['Invalid Closing Quote:', \"got \\\"\".concat(String.fromCharCode(nextChr), \"\\\"\"), \"at line \".concat(this.info.lines), 'instead of delimiter, record delimiter, trimable character', '(if activated) or comment'], this.options, this.__context()));\n\n                if (err !== undefined) return err;\n              } else {\n                this.state.quoting = false;\n                this.state.wasQuoting = true;\n                this.state.field.prepend(quote);\n                pos += quote.length - 1;\n              }\n            } else {\n              if (this.state.field.length !== 0) {\n                // In relax mode, treat opening quote preceded by chrs as regular\n                if (relax === false) {\n                  var _err = this.__error(new CsvError('INVALID_OPENING_QUOTE', ['Invalid Opening Quote:', \"a quote is found inside a field at line \".concat(this.info.lines)], this.options, this.__context(), {\n                    field: this.state.field\n                  }));\n\n                  if (_err !== undefined) return _err;\n                }\n              } else {\n                this.state.quoting = true;\n                pos += quote.length - 1;\n                continue;\n              }\n            }\n          }\n\n          if (this.state.quoting === false) {\n            var recordDelimiterLength = this.__isRecordDelimiter(chr, buf, pos);\n\n            if (recordDelimiterLength !== 0) {\n              // Do not emit comments which take a full line\n              var skipCommentLine = this.state.commenting && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0;\n\n              if (skipCommentLine) {\n                this.info.comment_lines++; // Skip full comment line\n              } else {\n                // Activate records emition if above from_line\n                if (this.state.enabled === false && this.info.lines + (this.state.wasRowDelimiter === true ? 1 : 0) >= from_line) {\n                  this.state.enabled = true;\n\n                  this.__resetField();\n\n                  this.__resetRecord();\n\n                  pos += recordDelimiterLength - 1;\n                  continue;\n                } // Skip if line is empty and skip_empty_lines activated\n\n\n                if (skip_empty_lines === true && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0) {\n                  this.info.empty_lines++;\n                  pos += recordDelimiterLength - 1;\n                  continue;\n                }\n\n                var errField = this.__onField();\n\n                if (errField !== undefined) return errField;\n\n                var errRecord = this.__onRecord();\n\n                if (errRecord !== undefined) return errRecord;\n\n                if (to !== -1 && this.info.records >= to) {\n                  this.state.stop = true;\n                  this.push(null);\n                  return;\n                }\n              }\n\n              this.state.commenting = false;\n              pos += recordDelimiterLength - 1;\n              continue;\n            }\n\n            if (this.state.commenting) {\n              continue;\n            }\n\n            var commentCount = comment === null ? 0 : this.__compareBytes(comment, buf, pos, chr);\n\n            if (commentCount !== 0) {\n              this.state.commenting = true;\n              continue;\n            }\n\n            var delimiterLength = this.__isDelimiter(buf, pos, chr);\n\n            if (delimiterLength !== 0) {\n              var _errField = this.__onField();\n\n              if (_errField !== undefined) return _errField;\n              pos += delimiterLength - 1;\n              continue;\n            }\n          }\n        }\n\n        if (this.state.commenting === false) {\n          if (max_record_size !== 0 && this.state.record_length + this.state.field.length > max_record_size) {\n            var _err2 = this.__error(new CsvError('CSV_MAX_RECORD_SIZE', ['Max Record Size:', 'record exceed the maximum number of tolerated bytes', \"of \".concat(max_record_size), \"at line \".concat(this.info.lines)], this.options, this.__context()));\n\n            if (_err2 !== undefined) return _err2;\n          }\n        }\n\n        var lappend = ltrim === false || this.state.quoting === true || this.state.field.length !== 0 || !this.__isCharTrimable(chr); // rtrim in non quoting is handle in __onField\n\n        var rappend = rtrim === false || this.state.wasQuoting === false;\n\n        if (lappend === true && rappend === true) {\n          this.state.field.append(chr);\n        } else if (rtrim === true && !this.__isCharTrimable(chr)) {\n          var _err3 = this.__error(new CsvError('CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE', ['Invalid Closing Quote:', 'found non trimable byte after quote', \"at line \".concat(this.info.lines)], this.options, this.__context()));\n\n          if (_err3 !== undefined) return _err3;\n        }\n      }\n\n      if (end === true) {\n        // Ensure we are not ending in a quoting state\n        if (this.state.quoting === true) {\n          var _err4 = this.__error(new CsvError('CSV_QUOTE_NOT_CLOSED', ['Quote Not Closed:', \"the parsing is finished with an opening quote at line \".concat(this.info.lines)], this.options, this.__context()));\n\n          if (_err4 !== undefined) return _err4;\n        } else {\n          // Skip last line if it has no characters\n          if (this.state.wasQuoting === true || this.state.record.length !== 0 || this.state.field.length !== 0) {\n            var _errField2 = this.__onField();\n\n            if (_errField2 !== undefined) return _errField2;\n\n            var _errRecord = this.__onRecord();\n\n            if (_errRecord !== undefined) return _errRecord;\n          } else if (this.state.wasRowDelimiter === true) {\n            this.info.empty_lines++;\n          } else if (this.state.commenting === true) {\n            this.info.comment_lines++;\n          }\n        }\n      } else {\n        this.state.previousBuf = buf.slice(pos);\n      }\n\n      if (this.state.wasRowDelimiter === true) {\n        this.info.lines++;\n        this.state.wasRowDelimiter = false;\n      }\n    }\n  }, {\n    key: \"__onRecord\",\n    value: function __onRecord() {\n      var _this$options2 = this.options,\n          columns = _this$options2.columns,\n          columns_duplicates_to_array = _this$options2.columns_duplicates_to_array,\n          encoding = _this$options2.encoding,\n          info = _this$options2.info,\n          from = _this$options2.from,\n          relax_column_count = _this$options2.relax_column_count,\n          relax_column_count_less = _this$options2.relax_column_count_less,\n          relax_column_count_more = _this$options2.relax_column_count_more,\n          raw = _this$options2.raw,\n          skip_lines_with_empty_values = _this$options2.skip_lines_with_empty_values;\n      var _this$state2 = this.state,\n          enabled = _this$state2.enabled,\n          record = _this$state2.record;\n\n      if (enabled === false) {\n        return this.__resetRecord();\n      } // Convert the first line into column names\n\n\n      var recordLength = record.length;\n\n      if (columns === true) {\n        if (isRecordEmpty(record)) {\n          this.__resetRecord();\n\n          return;\n        }\n\n        return this.__firstLineToColumns(record);\n      }\n\n      if (columns === false && this.info.records === 0) {\n        this.state.expectedRecordLength = recordLength;\n      }\n\n      if (recordLength !== this.state.expectedRecordLength) {\n        var err = columns === false ? // Todo: rename CSV_INCONSISTENT_RECORD_LENGTH to\n        // CSV_RECORD_INCONSISTENT_FIELDS_LENGTH\n        new CsvError('CSV_INCONSISTENT_RECORD_LENGTH', ['Invalid Record Length:', \"expect \".concat(this.state.expectedRecordLength, \",\"), \"got \".concat(recordLength, \" on line \").concat(this.info.lines)], this.options, this.__context(), {\n          record: record\n        }) : // Todo: rename CSV_RECORD_DONT_MATCH_COLUMNS_LENGTH to\n        // CSV_RECORD_INCONSISTENT_COLUMNS\n        new CsvError('CSV_RECORD_DONT_MATCH_COLUMNS_LENGTH', ['Invalid Record Length:', \"columns length is \".concat(columns.length, \",\"), // rename columns\n        \"got \".concat(recordLength, \" on line \").concat(this.info.lines)], this.options, this.__context(), {\n          record: record\n        });\n\n        if (relax_column_count === true || relax_column_count_less === true && recordLength < this.state.expectedRecordLength || relax_column_count_more === true && recordLength > this.state.expectedRecordLength) {\n          this.info.invalid_field_length++;\n          this.state.error = err; // Error is undefined with skip_lines_with_error\n        } else {\n          var finalErr = this.__error(err);\n\n          if (finalErr) return finalErr;\n        }\n      }\n\n      if (skip_lines_with_empty_values === true) {\n        if (isRecordEmpty(record)) {\n          this.__resetRecord();\n\n          return;\n        }\n      }\n\n      if (this.state.recordHasError === true) {\n        this.__resetRecord();\n\n        this.state.recordHasError = false;\n        return;\n      }\n\n      this.info.records++;\n\n      if (from === 1 || this.info.records >= from) {\n        if (columns !== false) {\n          var obj = {}; // Transform record array to an object\n\n          for (var i = 0, l = record.length; i < l; i++) {\n            if (columns[i] === undefined || columns[i].disabled) continue; // Turn duplicate columns into an array\n\n            if (columns_duplicates_to_array === true && obj[columns[i].name] !== undefined) {\n              if (Array.isArray(obj[columns[i].name])) {\n                obj[columns[i].name] = obj[columns[i].name].concat(record[i]);\n              } else {\n                obj[columns[i].name] = [obj[columns[i].name], record[i]];\n              }\n            } else {\n              obj[columns[i].name] = record[i];\n            }\n          }\n\n          var objname = this.options.objname;\n\n          if (objname === undefined) {\n            if (raw === true || info === true) {\n              var _err5 = this.__push(Object.assign({\n                record: obj\n              }, raw === true ? {\n                raw: this.state.rawBuffer.toString(encoding)\n              } : {}, info === true ? {\n                info: this.state.info\n              } : {}));\n\n              if (_err5) {\n                return _err5;\n              }\n            } else {\n              var _err6 = this.__push(obj);\n\n              if (_err6) {\n                return _err6;\n              }\n            }\n          } else {\n            if (raw === true || info === true) {\n              var _err7 = this.__push(Object.assign({\n                record: [obj[objname], obj]\n              }, raw === true ? {\n                raw: this.state.rawBuffer.toString(encoding)\n              } : {}, info === true ? {\n                info: this.state.info\n              } : {}));\n\n              if (_err7) {\n                return _err7;\n              }\n            } else {\n              var _err8 = this.__push([obj[objname], obj]);\n\n              if (_err8) {\n                return _err8;\n              }\n            }\n          }\n        } else {\n          if (raw === true || info === true) {\n            var _err9 = this.__push(Object.assign({\n              record: record\n            }, raw === true ? {\n              raw: this.state.rawBuffer.toString(encoding)\n            } : {}, info === true ? {\n              info: this.state.info\n            } : {}));\n\n            if (_err9) {\n              return _err9;\n            }\n          } else {\n            var _err10 = this.__push(record);\n\n            if (_err10) {\n              return _err10;\n            }\n          }\n        }\n      }\n\n      this.__resetRecord();\n    }\n  }, {\n    key: \"__firstLineToColumns\",\n    value: function __firstLineToColumns(record) {\n      var firstLineToHeaders = this.state.firstLineToHeaders;\n\n      try {\n        var headers = firstLineToHeaders === undefined ? record : firstLineToHeaders.call(null, record);\n\n        if (!Array.isArray(headers)) {\n          return this.__error(new CsvError('CSV_INVALID_COLUMN_MAPPING', ['Invalid Column Mapping:', 'expect an array from column function,', \"got \".concat(JSON.stringify(headers))], this.options, this.__context(), {\n            headers: headers\n          }));\n        }\n\n        var normalizedHeaders = normalizeColumnsArray(headers);\n        this.state.expectedRecordLength = normalizedHeaders.length;\n        this.options.columns = normalizedHeaders;\n\n        this.__resetRecord();\n\n        return;\n      } catch (err) {\n        return err;\n      }\n    }\n  }, {\n    key: \"__resetRecord\",\n    value: function __resetRecord() {\n      if (this.options.raw === true) {\n        this.state.rawBuffer.reset();\n      }\n\n      this.state.error = undefined;\n      this.state.record = [];\n      this.state.record_length = 0;\n    }\n  }, {\n    key: \"__onField\",\n    value: function __onField() {\n      var _this$options3 = this.options,\n          cast = _this$options3.cast,\n          encoding = _this$options3.encoding,\n          rtrim = _this$options3.rtrim,\n          max_record_size = _this$options3.max_record_size;\n      var _this$state3 = this.state,\n          enabled = _this$state3.enabled,\n          wasQuoting = _this$state3.wasQuoting; // Short circuit for the from_line options\n\n      if (enabled === false) {\n        /* this.options.columns !== true && */\n        return this.__resetField();\n      }\n\n      var field = this.state.field.toString(encoding);\n\n      if (rtrim === true && wasQuoting === false) {\n        field = field.trimRight();\n      }\n\n      if (cast === true) {\n        var _this$__cast = this.__cast(field),\n            _this$__cast2 = _slicedToArray(_this$__cast, 2),\n            err = _this$__cast2[0],\n            f = _this$__cast2[1];\n\n        if (err !== undefined) return err;\n        field = f;\n      }\n\n      this.state.record.push(field); // Increment record length if record size must not exceed a limit\n\n      if (max_record_size !== 0 && typeof field === 'string') {\n        this.state.record_length += field.length;\n      }\n\n      this.__resetField();\n    }\n  }, {\n    key: \"__resetField\",\n    value: function __resetField() {\n      this.state.field.reset();\n      this.state.wasQuoting = false;\n    }\n  }, {\n    key: \"__push\",\n    value: function __push(record) {\n      var on_record = this.options.on_record;\n\n      if (on_record !== undefined) {\n        var context = this.__context();\n\n        try {\n          record = on_record.call(null, record, context);\n        } catch (err) {\n          return err;\n        }\n\n        if (record === undefined || record === null) {\n          return;\n        }\n      }\n\n      this.push(record);\n    } // Return a tuple with the error and the casted value\n\n  }, {\n    key: \"__cast\",\n    value: function __cast(field) {\n      var _this$options4 = this.options,\n          columns = _this$options4.columns,\n          relax_column_count = _this$options4.relax_column_count;\n      var isColumns = Array.isArray(columns); // Dont loose time calling cast\n      // because the final record is an object\n      // and this field can't be associated to a key present in columns\n\n      if (isColumns === true && relax_column_count && this.options.columns.length <= this.state.record.length) {\n        return [undefined, undefined];\n      }\n\n      var context = this.__context();\n\n      if (this.state.castField !== null) {\n        try {\n          return [undefined, this.state.castField.call(null, field, context)];\n        } catch (err) {\n          return [err];\n        }\n      }\n\n      if (this.__isFloat(field)) {\n        return [undefined, parseFloat(field)];\n      } else if (this.options.cast_date !== false) {\n        return [undefined, this.options.cast_date.call(null, field, context)];\n      }\n\n      return [undefined, field];\n    } // Helper to test if a character is a space or a line delimiter\n\n  }, {\n    key: \"__isCharTrimable\",\n    value: function __isCharTrimable(chr) {\n      return chr === space || chr === tab || chr === cr || chr === nl || chr === np;\n    } // Keep it in case we implement the `cast_int` option\n    // __isInt(value){\n    //   // return Number.isInteger(parseInt(value))\n    //   // return !isNaN( parseInt( obj ) );\n    //   return /^(\\-|\\+)?[1-9][0-9]*$/.test(value)\n    // }\n\n  }, {\n    key: \"__isFloat\",\n    value: function __isFloat(value) {\n      return value - parseFloat(value) + 1 >= 0; // Borrowed from jquery\n    }\n  }, {\n    key: \"__compareBytes\",\n    value: function __compareBytes(sourceBuf, targetBuf, targetPos, firstByte) {\n      if (sourceBuf[0] !== firstByte) return 0;\n      var sourceLength = sourceBuf.length;\n\n      for (var i = 1; i < sourceLength; i++) {\n        if (sourceBuf[i] !== targetBuf[targetPos + i]) return 0;\n      }\n\n      return sourceLength;\n    }\n  }, {\n    key: \"__needMoreData\",\n    value: function __needMoreData(i, bufLen, end) {\n      if (end) return false;\n      var quote = this.options.quote;\n      var _this$state4 = this.state,\n          quoting = _this$state4.quoting,\n          needMoreDataSize = _this$state4.needMoreDataSize,\n          recordDelimiterMaxLength = _this$state4.recordDelimiterMaxLength;\n      var numOfCharLeft = bufLen - i - 1;\n      var requiredLength = Math.max(needMoreDataSize, // Skip if the remaining buffer smaller than record delimiter\n      recordDelimiterMaxLength, // Skip if the remaining buffer can be record delimiter following the closing quote\n      // 1 is for quote.length\n      quoting ? quote.length + recordDelimiterMaxLength : 0);\n      return numOfCharLeft < requiredLength;\n    }\n  }, {\n    key: \"__isDelimiter\",\n    value: function __isDelimiter(buf, pos, chr) {\n      var _this$options5 = this.options,\n          delimiter = _this$options5.delimiter,\n          ignore_last_delimiters = _this$options5.ignore_last_delimiters;\n\n      if (ignore_last_delimiters === true && this.state.record.length === this.options.columns.length - 1) {\n        return 0;\n      } else if (ignore_last_delimiters !== false && typeof ignore_last_delimiters === 'number' && this.state.record.length === ignore_last_delimiters - 1) {\n        return 0;\n      }\n\n      loop1: for (var i = 0; i < delimiter.length; i++) {\n        var del = delimiter[i];\n\n        if (del[0] === chr) {\n          for (var j = 1; j < del.length; j++) {\n            if (del[j] !== buf[pos + j]) continue loop1;\n          }\n\n          return del.length;\n        }\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"__isRecordDelimiter\",\n    value: function __isRecordDelimiter(chr, buf, pos) {\n      var record_delimiter = this.options.record_delimiter;\n      var recordDelimiterLength = record_delimiter.length;\n\n      loop1: for (var i = 0; i < recordDelimiterLength; i++) {\n        var rd = record_delimiter[i];\n        var rdLength = rd.length;\n\n        if (rd[0] !== chr) {\n          continue;\n        }\n\n        for (var j = 1; j < rdLength; j++) {\n          if (rd[j] !== buf[pos + j]) {\n            continue loop1;\n          }\n        }\n\n        return rd.length;\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"__isEscape\",\n    value: function __isEscape(buf, pos, chr) {\n      var escape = this.options.escape;\n      if (escape === null) return false;\n      var l = escape.length;\n\n      if (escape[0] === chr) {\n        for (var i = 0; i < l; i++) {\n          if (escape[i] !== buf[pos + i]) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"__isQuote\",\n    value: function __isQuote(buf, pos) {\n      var quote = this.options.quote;\n      if (quote === null) return false;\n      var l = quote.length;\n\n      for (var i = 0; i < l; i++) {\n        if (quote[i] !== buf[pos + i]) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"__autoDiscoverRecordDelimiter\",\n    value: function __autoDiscoverRecordDelimiter(buf, pos) {\n      var encoding = this.options.encoding;\n      var chr = buf[pos];\n\n      if (chr === cr) {\n        if (buf[pos + 1] === nl) {\n          this.options.record_delimiter.push(Buffer.from('\\r\\n', encoding));\n          this.state.recordDelimiterMaxLength = 2;\n          return 2;\n        } else {\n          this.options.record_delimiter.push(Buffer.from('\\r', encoding));\n          this.state.recordDelimiterMaxLength = 1;\n          return 1;\n        }\n      } else if (chr === nl) {\n        this.options.record_delimiter.push(Buffer.from('\\n', encoding));\n        this.state.recordDelimiterMaxLength = 1;\n        return 1;\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"__error\",\n    value: function __error(msg) {\n      var skip_lines_with_error = this.options.skip_lines_with_error;\n      var err = typeof msg === 'string' ? new Error(msg) : msg;\n\n      if (skip_lines_with_error) {\n        this.state.recordHasError = true;\n        this.emit('skip', err);\n        return undefined;\n      } else {\n        return err;\n      }\n    }\n  }, {\n    key: \"__context\",\n    value: function __context() {\n      var columns = this.options.columns;\n      var isColumns = Array.isArray(columns);\n      return {\n        column: isColumns === true ? columns.length > this.state.record.length ? columns[this.state.record.length].name : null : this.state.record.length,\n        empty_lines: this.info.empty_lines,\n        error: this.state.error,\n        header: columns === true,\n        index: this.state.record.length,\n        invalid_field_length: this.info.invalid_field_length,\n        quoting: this.state.wasQuoting,\n        lines: this.info.lines,\n        records: this.info.records\n      };\n    }\n  }]);\n\n  return Parser;\n}(Transform);\n\nvar parse = function parse() {\n  var data, options, callback;\n\n  for (var i in arguments) {\n    var argument = arguments[i];\n    var type = typeof argument;\n\n    if (data === undefined && (typeof argument === 'string' || Buffer.isBuffer(argument))) {\n      data = argument;\n    } else if (options === undefined && isObject(argument)) {\n      options = argument;\n    } else if (callback === undefined && type === 'function') {\n      callback = argument;\n    } else {\n      throw new CsvError('CSV_INVALID_ARGUMENT', ['Invalid argument:', \"got \".concat(JSON.stringify(argument), \" at index \").concat(i)], this.options);\n    }\n  }\n\n  var parser = new Parser(options);\n\n  if (callback) {\n    var records = options === undefined || options.objname === undefined ? [] : {};\n    parser.on('readable', function () {\n      var record;\n\n      while ((record = this.read()) !== null) {\n        if (options === undefined || options.objname === undefined) {\n          records.push(record);\n        } else {\n          records[record[0]] = record[1];\n        }\n      }\n    });\n    parser.on('error', function (err) {\n      callback(err, undefined, parser.info);\n    });\n    parser.on('end', function () {\n      callback(undefined, records, parser.info);\n    });\n  }\n\n  if (data !== undefined) {\n    // Give a chance for events to be registered later\n    if (typeof setImmediate === 'function') {\n      setImmediate(function () {\n        parser.write(data);\n        parser.end();\n      });\n    } else {\n      parser.write(data);\n      parser.end();\n    }\n  }\n\n  return parser;\n};\n\nvar CsvError = /*#__PURE__*/function (_Error) {\n  \"use strict\";\n\n  _inherits(CsvError, _Error);\n\n  var _super2 = _createSuper(CsvError);\n\n  function CsvError(code, message, options) {\n    var _this2;\n\n    _classCallCheck(this, CsvError);\n\n    if (Array.isArray(message)) message = message.join(' ');\n    _this2 = _super2.call(this, message);\n\n    if (Error.captureStackTrace !== undefined) {\n      Error.captureStackTrace(_assertThisInitialized(_this2), CsvError);\n    }\n\n    _this2.code = code;\n\n    for (var _len = arguments.length, contexts = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n      contexts[_key - 3] = arguments[_key];\n    }\n\n    for (var _i = 0, _contexts = contexts; _i < _contexts.length; _i++) {\n      var context = _contexts[_i];\n\n      for (var key in context) {\n        var value = context[key];\n        _this2[key] = Buffer.isBuffer(value) ? value.toString(options.encoding) : value == null ? value : JSON.parse(JSON.stringify(value));\n      }\n    }\n\n    return _this2;\n  }\n\n  return CsvError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nparse.Parser = Parser;\nparse.CsvError = CsvError;\nmodule.exports = parse;\n\nvar underscore = function underscore(str) {\n  return str.replace(/([A-Z])/g, function (_, match) {\n    return '_' + match.toLowerCase();\n  });\n};\n\nvar isObject = function isObject(obj) {\n  return typeof obj === 'object' && obj !== null && !Array.isArray(obj);\n};\n\nvar isRecordEmpty = function isRecordEmpty(record) {\n  return record.every(function (field) {\n    return field == null || field.toString && field.toString().trim() === '';\n  });\n};\n\nvar normalizeColumnsArray = function normalizeColumnsArray(columns) {\n  var normalizedColumns = [];\n\n  for (var i = 0, l = columns.length; i < l; i++) {\n    var column = columns[i];\n\n    if (column === undefined || column === null || column === false) {\n      normalizedColumns[i] = {\n        disabled: true\n      };\n    } else if (typeof column === 'string') {\n      normalizedColumns[i] = {\n        name: column\n      };\n    } else if (isObject(column)) {\n      if (typeof column.name !== 'string') {\n        throw new CsvError('CSV_OPTION_COLUMNS_MISSING_NAME', ['Option columns missing name:', \"property \\\"name\\\" is required at position \".concat(i), 'when column is an object literal']);\n      }\n\n      normalizedColumns[i] = column;\n    } else {\n      throw new CsvError('CSV_INVALID_COLUMN_DEFINITION', ['Invalid column definition:', 'expect a string or a literal object,', \"got \".concat(JSON.stringify(column), \" at position \").concat(i)]);\n    }\n  }\n\n  return normalizedColumns;\n};","map":{"version":3,"sources":["/Users/frankenstein/projects/minter/node_modules/csv-parse/lib/index.js"],"names":["require","Transform","ResizeableBuffer","tab","nl","np","cr","space","boms","Buffer","from","Parser","opts","readableObjectMode","encoding","__originalOptions","__normalizeOptions","options","opt","underscore","undefined","CsvError","JSON","stringify","bom","fnCastField","cast","cast_date","value","date","Date","parse","isNaN","fnFirstLineToHeaders","columns","Array","isArray","normalizeColumnsArray","columns_duplicates_to_array","comment","isBuffer","delimiter_json","delimiter","length","map","escape","Error","test","parseInt","Number","isInteger","from_line","ignore_last_delimiters","Math","floor","info","max_record_size","objname","toString","on_record","quote","raw","record_delimiter","rd","relax","relax_column_count","relax_column_count_less","relax_column_count_more","skip_empty_lines","skip_lines_with_empty_values","skip_lines_with_error","rtrim","ltrim","trim","to","to_line","comment_lines","empty_lines","invalid_field_length","lines","records","state","bomSkipped","castField","commenting","error","enabled","escaping","escapeIsQuote","compare","expectedRecordLength","field","firstLineToHeaders","Object","assign","needMoreDataSize","max","previousBuf","quoting","stop","rawBuffer","record","recordHasError","record_length","recordDelimiterMaxLength","v","trimChars","wasQuoting","wasRowDelimiter","buf","callback","err","__parse","nextBuf","end","push","concat","slice","bufLen","pos","__needMoreData","record_delimiterCount","__autoDiscoverRecordDelimiter","chr","append","__isEscape","__isQuote","nextChr","isNextChrTrimable","__isCharTrimable","isNextChrComment","__compareBytes","isNextChrDelimiter","__isDelimiter","isNextChrRecordDelimiter","__isRecordDelimiter","__error","String","fromCharCode","__context","prepend","recordDelimiterLength","skipCommentLine","__resetField","__resetRecord","errField","__onField","errRecord","__onRecord","commentCount","delimiterLength","lappend","rappend","recordLength","isRecordEmpty","__firstLineToColumns","finalErr","obj","i","l","disabled","name","__push","headers","call","normalizedHeaders","reset","trimRight","__cast","f","context","isColumns","__isFloat","parseFloat","sourceBuf","targetBuf","targetPos","firstByte","sourceLength","numOfCharLeft","requiredLength","loop1","del","j","rdLength","msg","emit","column","header","index","data","arguments","argument","type","isObject","parser","on","read","setImmediate","write","code","message","join","captureStackTrace","contexts","key","module","exports","str","replace","_","match","toLowerCase","every","normalizedColumns"],"mappings":"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","sourcesContent":["\n/*\nCSV Parse\n\nPlease look at the [project documentation](https://csv.js.org/parse/) for\nadditional information.\n*/\n\nconst { Transform } = require('stream')\nconst ResizeableBuffer = require('./ResizeableBuffer')\n\n// white space characters\n// https://en.wikipedia.org/wiki/Whitespace_character\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes#Types\n// \\f\\n\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff\nconst tab = 9\nconst nl = 10 // \\n, 0x0A in hexadecimal, 10 in decimal\nconst np = 12\nconst cr = 13 // \\r, 0x0D in hexadÃ©cimal, 13 in decimal\nconst space = 32\nconst boms = {\n  // Note, the following are equals:\n  // Buffer.from(\"\\ufeff\")\n  // Buffer.from([239, 187, 191])\n  // Buffer.from('EFBBBF', 'hex')\n  'utf8': Buffer.from([239, 187, 191]),\n  // Note, the following are equals:\n  // Buffer.from \"\\ufeff\", 'utf16le\n  // Buffer.from([255, 254])\n  'utf16le': Buffer.from([255, 254])\n}\n\nclass Parser extends Transform {\n  constructor(opts = {}){\n    super({...{readableObjectMode: true}, ...opts, encoding: null})\n    this.__originalOptions = opts\n    this.__normalizeOptions(opts)\n  }\n  __normalizeOptions(opts){\n    const options = {}\n    // Merge with user options\n    for(let opt in opts){\n      options[underscore(opt)] = opts[opt]\n    }\n    // Normalize option `encoding`\n    // Note: defined first because other options depends on it\n    // to convert chars/strings into buffers.\n    if(options.encoding === undefined || options.encoding === true){\n      options.encoding = 'utf8'\n    }else if(options.encoding === null || options.encoding === false){\n      options.encoding = null\n    }else if(typeof options.encoding !== 'string' && options.encoding !== null){\n      throw new CsvError('CSV_INVALID_OPTION_ENCODING', [\n        'Invalid option encoding:',\n        'encoding must be a string or null to return a buffer,',\n        `got ${JSON.stringify(options.encoding)}`\n      ], options)\n    }\n    // Normalize option `bom`\n    if(options.bom === undefined || options.bom === null || options.bom === false){\n      options.bom = false\n    }else if(options.bom !== true){\n      throw new CsvError('CSV_INVALID_OPTION_BOM', [\n        'Invalid option bom:', 'bom must be true,',\n        `got ${JSON.stringify(options.bom)}`\n      ], options)\n    }\n    // Normalize option `cast`\n    let fnCastField = null\n    if(options.cast === undefined || options.cast === null || options.cast === false || options.cast === ''){\n      options.cast = undefined\n    }else if(typeof options.cast === 'function'){\n      fnCastField = options.cast\n      options.cast = true\n    }else if(options.cast !== true){\n      throw new CsvError('CSV_INVALID_OPTION_CAST', [\n        'Invalid option cast:', 'cast must be true or a function,',\n        `got ${JSON.stringify(options.cast)}`\n      ], options)\n    }\n    // Normalize option `cast_date`\n    if(options.cast_date === undefined || options.cast_date === null || options.cast_date === false || options.cast_date === ''){\n      options.cast_date = false\n    }else if(options.cast_date === true){\n      options.cast_date = function(value){\n        const date = Date.parse(value)\n        return !isNaN(date) ? new Date(date) : value\n      }\n    }else if(typeof options.cast_date !== 'function'){\n      throw new CsvError('CSV_INVALID_OPTION_CAST_DATE', [\n        'Invalid option cast_date:', 'cast_date must be true or a function,',\n        `got ${JSON.stringify(options.cast_date)}`\n      ], options)\n    }\n    // Normalize option `columns`\n    let fnFirstLineToHeaders = null\n    if(options.columns === true){\n      // Fields in the first line are converted as-is to columns\n      fnFirstLineToHeaders = undefined\n    }else if(typeof options.columns === 'function'){\n      fnFirstLineToHeaders = options.columns\n      options.columns = true\n    }else if(Array.isArray(options.columns)){\n      options.columns = normalizeColumnsArray(options.columns)\n    }else if(options.columns === undefined || options.columns === null || options.columns === false){\n      options.columns = false\n    }else{\n      throw new CsvError('CSV_INVALID_OPTION_COLUMNS', [\n        'Invalid option columns:',\n        'expect an object, a function or true,',\n        `got ${JSON.stringify(options.columns)}`\n      ], options)\n    }\n    // Normalize option `columns_duplicates_to_array`\n    if(options.columns_duplicates_to_array === undefined || options.columns_duplicates_to_array === null || options.columns_duplicates_to_array === false){\n      options.columns_duplicates_to_array = false\n    }else if(options.columns_duplicates_to_array !== true){\n      throw new CsvError('CSV_INVALID_OPTION_COLUMNS_DUPLICATES_TO_ARRAY', [\n        'Invalid option columns_duplicates_to_array:',\n        'expect an boolean,',\n        `got ${JSON.stringify(options.columns_duplicates_to_array)}`\n      ], options)\n    }\n    // Normalize option `comment`\n    if(options.comment === undefined || options.comment === null || options.comment === false || options.comment === ''){\n      options.comment = null\n    }else{\n      if(typeof options.comment === 'string'){\n        options.comment = Buffer.from(options.comment, options.encoding)\n      }\n      if(!Buffer.isBuffer(options.comment)){\n        throw new CsvError('CSV_INVALID_OPTION_COMMENT', [\n          'Invalid option comment:',\n          'comment must be a buffer or a string,',\n          `got ${JSON.stringify(options.comment)}`\n        ], options)\n      }\n    }\n    // Normalize option `delimiter`\n    const delimiter_json = JSON.stringify(options.delimiter)\n    if(!Array.isArray(options.delimiter)) options.delimiter = [options.delimiter]\n    if(options.delimiter.length === 0){\n      throw new CsvError('CSV_INVALID_OPTION_DELIMITER', [\n        'Invalid option delimiter:',\n        'delimiter must be a non empty string or buffer or array of string|buffer,',\n        `got ${delimiter_json}`\n      ], options)\n    }\n    options.delimiter = options.delimiter.map(function(delimiter){\n      if(delimiter === undefined || delimiter === null || delimiter === false){\n        return Buffer.from(',', options.encoding)\n      }\n      if(typeof delimiter === 'string'){\n        delimiter = Buffer.from(delimiter, options.encoding)\n      }\n      if( !Buffer.isBuffer(delimiter) || delimiter.length === 0){\n        throw new CsvError('CSV_INVALID_OPTION_DELIMITER', [\n          'Invalid option delimiter:',\n          'delimiter must be a non empty string or buffer or array of string|buffer,',\n          `got ${delimiter_json}`\n        ], options)\n      }\n      return delimiter\n    })\n    // Normalize option `escape`\n    if(options.escape === undefined || options.escape === true){\n      options.escape = Buffer.from('\"', options.encoding)\n    }else if(typeof options.escape === 'string'){\n      options.escape = Buffer.from(options.escape, options.encoding)\n    }else if (options.escape === null || options.escape === false){\n      options.escape = null\n    }\n    if(options.escape !== null){\n      if(!Buffer.isBuffer(options.escape)){\n        throw new Error(`Invalid Option: escape must be a buffer, a string or a boolean, got ${JSON.stringify(options.escape)}`)\n      }\n    }\n    // Normalize option `from`\n    if(options.from === undefined || options.from === null){\n      options.from = 1\n    }else{\n      if(typeof options.from === 'string' && /\\d+/.test(options.from)){\n        options.from = parseInt(options.from)\n      }\n      if(Number.isInteger(options.from)){\n        if(options.from < 0){\n          throw new Error(`Invalid Option: from must be a positive integer, got ${JSON.stringify(opts.from)}`)\n        }\n      }else{\n        throw new Error(`Invalid Option: from must be an integer, got ${JSON.stringify(options.from)}`)\n      }\n    }\n    // Normalize option `from_line`\n    if(options.from_line === undefined || options.from_line === null){\n      options.from_line = 1\n    }else{\n      if(typeof options.from_line === 'string' && /\\d+/.test(options.from_line)){\n        options.from_line = parseInt(options.from_line)\n      }\n      if(Number.isInteger(options.from_line)){\n        if(options.from_line <= 0){\n          throw new Error(`Invalid Option: from_line must be a positive integer greater than 0, got ${JSON.stringify(opts.from_line)}`)\n        }\n      }else{\n        throw new Error(`Invalid Option: from_line must be an integer, got ${JSON.stringify(opts.from_line)}`)\n      }\n    }\n    // Normalize options `ignore_last_delimiters`\n    if(options.ignore_last_delimiters === undefined || options.ignore_last_delimiters === null){\n      options.ignore_last_delimiters = false\n    }else if(typeof options.ignore_last_delimiters === 'number'){\n      options.ignore_last_delimiters = Math.floor(options.ignore_last_delimiters)\n      if(options.ignore_last_delimiters === 0){\n        options.ignore_last_delimiters = false\n      }\n    }else if(typeof options.ignore_last_delimiters !== 'boolean'){\n      throw new CsvError('CSV_INVALID_OPTION_IGNORE_LAST_DELIMITERS', [\n        'Invalid option `ignore_last_delimiters`:',\n        'the value must be a boolean value or an integer,',\n        `got ${JSON.stringify(options.ignore_last_delimiters)}`\n      ], options)\n    }\n    if(options.ignore_last_delimiters === true && options.columns === false){\n      throw new CsvError('CSV_IGNORE_LAST_DELIMITERS_REQUIRES_COLUMNS', [\n        'The option `ignore_last_delimiters`',\n        'requires the activation of the `columns` option'\n      ], options)\n    }\n    // Normalize option `info`\n    if(options.info === undefined || options.info === null || options.info === false){\n      options.info = false\n    }else if(options.info !== true){\n      throw new Error(`Invalid Option: info must be true, got ${JSON.stringify(options.info)}`)\n    }\n    // Normalize option `max_record_size`\n    if(options.max_record_size === undefined || options.max_record_size === null || options.max_record_size === false){\n      options.max_record_size = 0\n    }else if(Number.isInteger(options.max_record_size) && options.max_record_size >= 0){\n      // Great, nothing to do\n    }else if(typeof options.max_record_size === 'string' && /\\d+/.test(options.max_record_size)){\n      options.max_record_size = parseInt(options.max_record_size)\n    }else{\n      throw new Error(`Invalid Option: max_record_size must be a positive integer, got ${JSON.stringify(options.max_record_size)}`)\n    }\n    // Normalize option `objname`\n    if(options.objname === undefined || options.objname === null || options.objname === false){\n      options.objname = undefined\n    }else if(Buffer.isBuffer(options.objname)){\n      if(options.objname.length === 0){\n        throw new Error(`Invalid Option: objname must be a non empty buffer`)\n      }\n      if(options.encoding === null){\n        // Don't call `toString`, leave objname as a buffer\n      }else{\n        options.objname = options.objname.toString(options.encoding)\n      }\n    }else if(typeof options.objname === 'string'){\n      if(options.objname.length === 0){\n        throw new Error(`Invalid Option: objname must be a non empty string`)\n      }\n      // Great, nothing to do\n    }else{\n      throw new Error(`Invalid Option: objname must be a string or a buffer, got ${options.objname}`)\n    }\n    // Normalize option `on_record`\n    if(options.on_record === undefined || options.on_record === null){\n      options.on_record = undefined\n    }else if(typeof options.on_record !== 'function'){\n      throw new CsvError('CSV_INVALID_OPTION_ON_RECORD', [\n        'Invalid option `on_record`:',\n        'expect a function,',\n        `got ${JSON.stringify(options.on_record)}`\n      ], options)\n    }\n    // Normalize option `quote`\n    if(options.quote === null || options.quote === false || options.quote === ''){\n      options.quote = null\n    }else{\n      if(options.quote === undefined || options.quote === true){\n        options.quote = Buffer.from('\"', options.encoding)\n      }else if(typeof options.quote === 'string'){\n        options.quote = Buffer.from(options.quote, options.encoding)\n      }\n      if(!Buffer.isBuffer(options.quote)){\n        throw new Error(`Invalid Option: quote must be a buffer or a string, got ${JSON.stringify(options.quote)}`)\n      }\n    }\n    // Normalize option `raw`\n    if(options.raw === undefined || options.raw === null || options.raw === false){\n      options.raw = false\n    }else if(options.raw !== true){\n      throw new Error(`Invalid Option: raw must be true, got ${JSON.stringify(options.raw)}`)\n    }\n    // Normalize option `record_delimiter`\n    if(!options.record_delimiter){\n      options.record_delimiter = []\n    }else if(!Array.isArray(options.record_delimiter)){\n      options.record_delimiter = [options.record_delimiter]\n    }\n    options.record_delimiter = options.record_delimiter.map( function(rd){\n      if(typeof rd === 'string'){\n        rd = Buffer.from(rd, options.encoding)\n      }\n      return rd\n    })\n    // Normalize option `relax`\n    if(typeof options.relax === 'boolean'){\n      // Great, nothing to do\n    }else if(options.relax === undefined || options.relax === null){\n      options.relax = false\n    }else{\n      throw new Error(`Invalid Option: relax must be a boolean, got ${JSON.stringify(options.relax)}`)\n    }\n    // Normalize option `relax_column_count`\n    if(typeof options.relax_column_count === 'boolean'){\n      // Great, nothing to do\n    }else if(options.relax_column_count === undefined || options.relax_column_count === null){\n      options.relax_column_count = false\n    }else{\n      throw new Error(`Invalid Option: relax_column_count must be a boolean, got ${JSON.stringify(options.relax_column_count)}`)\n    }\n    if(typeof options.relax_column_count_less === 'boolean'){\n      // Great, nothing to do\n    }else if(options.relax_column_count_less === undefined || options.relax_column_count_less === null){\n      options.relax_column_count_less = false\n    }else{\n      throw new Error(`Invalid Option: relax_column_count_less must be a boolean, got ${JSON.stringify(options.relax_column_count_less)}`)\n    }\n    if(typeof options.relax_column_count_more === 'boolean'){\n      // Great, nothing to do\n    }else if(options.relax_column_count_more === undefined || options.relax_column_count_more === null){\n      options.relax_column_count_more = false\n    }else{\n      throw new Error(`Invalid Option: relax_column_count_more must be a boolean, got ${JSON.stringify(options.relax_column_count_more)}`)\n    }\n    // Normalize option `skip_empty_lines`\n    if(typeof options.skip_empty_lines === 'boolean'){\n      // Great, nothing to do\n    }else if(options.skip_empty_lines === undefined || options.skip_empty_lines === null){\n      options.skip_empty_lines = false\n    }else{\n      throw new Error(`Invalid Option: skip_empty_lines must be a boolean, got ${JSON.stringify(options.skip_empty_lines)}`)\n    }\n    // Normalize option `skip_lines_with_empty_values`\n    if(typeof options.skip_lines_with_empty_values === 'boolean'){\n      // Great, nothing to do\n    }else if(options.skip_lines_with_empty_values === undefined || options.skip_lines_with_empty_values === null){\n      options.skip_lines_with_empty_values = false\n    }else{\n      throw new Error(`Invalid Option: skip_lines_with_empty_values must be a boolean, got ${JSON.stringify(options.skip_lines_with_empty_values)}`)\n    }\n    // Normalize option `skip_lines_with_error`\n    if(typeof options.skip_lines_with_error === 'boolean'){\n      // Great, nothing to do\n    }else if(options.skip_lines_with_error === undefined || options.skip_lines_with_error === null){\n      options.skip_lines_with_error = false\n    }else{\n      throw new Error(`Invalid Option: skip_lines_with_error must be a boolean, got ${JSON.stringify(options.skip_lines_with_error)}`)\n    }\n    // Normalize option `rtrim`\n    if(options.rtrim === undefined || options.rtrim === null || options.rtrim === false){\n      options.rtrim = false\n    }else if(options.rtrim !== true){\n      throw new Error(`Invalid Option: rtrim must be a boolean, got ${JSON.stringify(options.rtrim)}`)\n    }\n    // Normalize option `ltrim`\n    if(options.ltrim === undefined || options.ltrim === null || options.ltrim === false){\n      options.ltrim = false\n    }else if(options.ltrim !== true){\n      throw new Error(`Invalid Option: ltrim must be a boolean, got ${JSON.stringify(options.ltrim)}`)\n    }\n    // Normalize option `trim`\n    if(options.trim === undefined || options.trim === null || options.trim === false){\n      options.trim = false\n    }else if(options.trim !== true){\n      throw new Error(`Invalid Option: trim must be a boolean, got ${JSON.stringify(options.trim)}`)\n    }\n    // Normalize options `trim`, `ltrim` and `rtrim`\n    if(options.trim === true && opts.ltrim !== false){\n      options.ltrim = true\n    }else if(options.ltrim !== true){\n      options.ltrim = false\n    }\n    if(options.trim === true && opts.rtrim !== false){\n      options.rtrim = true\n    }else if(options.rtrim !== true){\n      options.rtrim = false\n    }\n    // Normalize option `to`\n    if(options.to === undefined || options.to === null){\n      options.to = -1\n    }else{\n      if(typeof options.to === 'string' && /\\d+/.test(options.to)){\n        options.to = parseInt(options.to)\n      }\n      if(Number.isInteger(options.to)){\n        if(options.to <= 0){\n          throw new Error(`Invalid Option: to must be a positive integer greater than 0, got ${JSON.stringify(opts.to)}`)\n        }\n      }else{\n        throw new Error(`Invalid Option: to must be an integer, got ${JSON.stringify(opts.to)}`)\n      }\n    }\n    // Normalize option `to_line`\n    if(options.to_line === undefined || options.to_line === null){\n      options.to_line = -1\n    }else{\n      if(typeof options.to_line === 'string' && /\\d+/.test(options.to_line)){\n        options.to_line = parseInt(options.to_line)\n      }\n      if(Number.isInteger(options.to_line)){\n        if(options.to_line <= 0){\n          throw new Error(`Invalid Option: to_line must be a positive integer greater than 0, got ${JSON.stringify(opts.to_line)}`)\n        }\n      }else{\n        throw new Error(`Invalid Option: to_line must be an integer, got ${JSON.stringify(opts.to_line)}`)\n      }\n    }\n    this.info = {\n      comment_lines: 0,\n      empty_lines: 0,\n      invalid_field_length: 0,\n      lines: 1,\n      records: 0\n    }\n    this.options = options\n    this.state = {\n      bomSkipped: false,\n      castField: fnCastField,\n      commenting: false,\n      // Current error encountered by a record\n      error: undefined,\n      enabled: options.from_line === 1,\n      escaping: false,\n      // escapeIsQuote: options.escape === options.quote,\n      escapeIsQuote: Buffer.isBuffer(options.escape) && Buffer.isBuffer(options.quote) && Buffer.compare(options.escape, options.quote) === 0,\n      expectedRecordLength: options.columns === null ? 0 : options.columns.length,\n      field: new ResizeableBuffer(20),\n      firstLineToHeaders: fnFirstLineToHeaders,\n      info: Object.assign({}, this.info),\n      needMoreDataSize: Math.max(\n        // Skip if the remaining buffer smaller than comment\n        options.comment !== null ? options.comment.length : 0,\n        // Skip if the remaining buffer can be delimiter\n        ...options.delimiter.map( (delimiter) => delimiter.length),\n        // Skip if the remaining buffer can be escape sequence\n        options.quote !== null ? options.quote.length : 0,\n      ),\n      previousBuf: undefined,\n      quoting: false,\n      stop: false,\n      rawBuffer: new ResizeableBuffer(100),\n      record: [],\n      recordHasError: false,\n      record_length: 0,\n      recordDelimiterMaxLength: options.record_delimiter.length === 0 ? 2 : Math.max(...options.record_delimiter.map( (v) => v.length)),\n      trimChars: [Buffer.from(' ', options.encoding)[0], Buffer.from('\\t', options.encoding)[0]],\n      wasQuoting: false,\n      wasRowDelimiter: false\n    }\n  }\n  // Implementation of `Transform._transform`\n  _transform(buf, encoding, callback){\n    if(this.state.stop === true){\n      return\n    }\n    const err = this.__parse(buf, false)\n    if(err !== undefined){\n      this.state.stop = true\n    }\n    callback(err)\n  }\n  // Implementation of `Transform._flush`\n  _flush(callback){\n    if(this.state.stop === true){\n      return\n    }\n    const err = this.__parse(undefined, true)\n    callback(err)\n  }\n  // Central parser implementation\n  __parse(nextBuf, end){\n    const {bom, comment, escape, from_line, info, ltrim, max_record_size, quote, raw, relax, rtrim, skip_empty_lines, to, to_line} = this.options\n    let {record_delimiter} = this.options\n    const {bomSkipped, previousBuf, rawBuffer, escapeIsQuote} = this.state\n    let buf\n    if(previousBuf === undefined){\n      if(nextBuf === undefined){\n        // Handle empty string\n        this.push(null)\n        return\n      }else{\n        buf = nextBuf\n      }\n    }else if(previousBuf !== undefined && nextBuf === undefined){\n      buf = previousBuf\n    }else{\n      buf = Buffer.concat([previousBuf, nextBuf])\n    }\n    // Handle UTF BOM\n    if(bomSkipped === false){\n      if(bom === false){\n        this.state.bomSkipped = true\n      }else if(buf.length < 3){\n        // No enough data\n        if(end === false){\n          // Wait for more data\n          this.state.previousBuf = buf\n          return\n        }\n      }else{\n        for(let encoding in boms){\n          if(boms[encoding].compare(buf, 0, boms[encoding].length) === 0){\n            // Skip BOM\n            buf = buf.slice(boms[encoding].length)\n            // Renormalize original options with the new encoding\n            this.__normalizeOptions({...this.__originalOptions, encoding: encoding})\n            break\n          }\n        }\n        this.state.bomSkipped = true\n      }\n    }\n    const bufLen = buf.length\n    let pos\n    for(pos = 0; pos < bufLen; pos++){\n      // Ensure we get enough space to look ahead\n      // There should be a way to move this out of the loop\n      if(this.__needMoreData(pos, bufLen, end)){\n        break\n      }\n      if(this.state.wasRowDelimiter === true){\n        this.info.lines++\n        if(info === true && this.state.record.length === 0 && this.state.field.length === 0 && this.state.wasQuoting === false){\n          this.state.info = Object.assign({}, this.info)\n        }\n        this.state.wasRowDelimiter = false\n      }\n      if(to_line !== -1 && this.info.lines > to_line){\n        this.state.stop = true\n        this.push(null)\n        return\n      }\n      // Auto discovery of record_delimiter, unix, mac and windows supported\n      if(this.state.quoting === false && record_delimiter.length === 0){\n        const record_delimiterCount = this.__autoDiscoverRecordDelimiter(buf, pos)\n        if(record_delimiterCount){\n          record_delimiter = this.options.record_delimiter\n        }\n      }\n      const chr = buf[pos]\n      if(raw === true){\n        rawBuffer.append(chr)\n      }\n      if((chr === cr || chr === nl) && this.state.wasRowDelimiter === false ){\n        this.state.wasRowDelimiter = true\n      }\n      // Previous char was a valid escape char\n      // treat the current char as a regular char\n      if(this.state.escaping === true){\n        this.state.escaping = false\n      }else{\n        // Escape is only active inside quoted fields\n        // We are quoting, the char is an escape chr and there is a chr to escape\n        // if(escape !== null && this.state.quoting === true && chr === escape && pos + 1 < bufLen){\n        if(escape !== null && this.state.quoting === true && this.__isEscape(buf, pos, chr) && pos + escape.length < bufLen){\n          if(escapeIsQuote){\n            if(this.__isQuote(buf, pos+escape.length)){\n              this.state.escaping = true\n              pos += escape.length - 1\n              continue\n            }\n          }else{\n            this.state.escaping = true\n            pos += escape.length - 1\n            continue\n          }\n        }\n        // Not currently escaping and chr is a quote\n        // TODO: need to compare bytes instead of single char\n        if(this.state.commenting === false && this.__isQuote(buf, pos)){\n          if(this.state.quoting === true){\n            const nextChr = buf[pos+quote.length]\n            const isNextChrTrimable = rtrim && this.__isCharTrimable(nextChr)\n            const isNextChrComment = comment !== null && this.__compareBytes(comment, buf, pos+quote.length, nextChr)\n            const isNextChrDelimiter = this.__isDelimiter(buf, pos+quote.length, nextChr)\n            const isNextChrRecordDelimiter = record_delimiter.length === 0 ? this.__autoDiscoverRecordDelimiter(buf, pos+quote.length) : this.__isRecordDelimiter(nextChr, buf, pos+quote.length)\n            // Escape a quote\n            // Treat next char as a regular character\n            if(escape !== null && this.__isEscape(buf, pos, chr) && this.__isQuote(buf, pos + escape.length)){\n              pos += escape.length - 1\n            }else if(!nextChr || isNextChrDelimiter || isNextChrRecordDelimiter || isNextChrComment || isNextChrTrimable){\n              this.state.quoting = false\n              this.state.wasQuoting = true\n              pos += quote.length - 1\n              continue\n            }else if(relax === false){\n              const err = this.__error(\n                new CsvError('CSV_INVALID_CLOSING_QUOTE', [\n                  'Invalid Closing Quote:',\n                  `got \"${String.fromCharCode(nextChr)}\"`,\n                  `at line ${this.info.lines}`,\n                  'instead of delimiter, record delimiter, trimable character',\n                  '(if activated) or comment',\n                ], this.options, this.__context())\n              )\n              if(err !== undefined) return err\n            }else{\n              this.state.quoting = false\n              this.state.wasQuoting = true\n              this.state.field.prepend(quote)\n              pos += quote.length - 1\n            }\n          }else{\n            if(this.state.field.length !== 0){\n              // In relax mode, treat opening quote preceded by chrs as regular\n              if( relax === false ){\n                const err = this.__error(\n                  new CsvError('INVALID_OPENING_QUOTE', [\n                    'Invalid Opening Quote:',\n                    `a quote is found inside a field at line ${this.info.lines}`,\n                  ], this.options, this.__context(), {\n                    field: this.state.field,\n                  })\n                )\n                if(err !== undefined) return err\n              }\n            }else{\n              this.state.quoting = true\n              pos += quote.length - 1\n              continue\n            }\n          }\n        }\n        if(this.state.quoting === false){\n          let recordDelimiterLength = this.__isRecordDelimiter(chr, buf, pos)\n          if(recordDelimiterLength !== 0){\n            // Do not emit comments which take a full line\n            const skipCommentLine = this.state.commenting && (this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0)\n            if(skipCommentLine){\n              this.info.comment_lines++\n              // Skip full comment line\n            }else{\n              // Activate records emition if above from_line\n              if(this.state.enabled === false && this.info.lines + (this.state.wasRowDelimiter === true ? 1: 0) >= from_line){\n                this.state.enabled = true\n                this.__resetField()\n                this.__resetRecord()\n                pos += recordDelimiterLength - 1\n                continue\n              }\n              // Skip if line is empty and skip_empty_lines activated\n              if(skip_empty_lines === true && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0){\n                this.info.empty_lines++\n                pos += recordDelimiterLength - 1\n                continue\n              }\n              const errField = this.__onField()\n              if(errField !== undefined) return errField\n              const errRecord = this.__onRecord()\n              if(errRecord !== undefined) return errRecord\n              if(to !== -1 && this.info.records >= to){\n                this.state.stop = true\n                this.push(null)\n                return\n              }\n            }\n            this.state.commenting = false\n            pos += recordDelimiterLength - 1\n            continue\n          }\n          if(this.state.commenting){\n            continue\n          }\n          const commentCount = comment === null ? 0 : this.__compareBytes(comment, buf, pos, chr)\n          if(commentCount !== 0){\n            this.state.commenting = true\n            continue\n          }\n          let delimiterLength = this.__isDelimiter(buf, pos, chr)\n          if(delimiterLength !== 0){\n            const errField = this.__onField()\n            if(errField !== undefined) return errField\n            pos += delimiterLength - 1\n            continue\n          }\n        }\n      }\n      if(this.state.commenting === false){\n        if(max_record_size !== 0 && this.state.record_length + this.state.field.length > max_record_size){\n          const err = this.__error(\n            new CsvError('CSV_MAX_RECORD_SIZE', [\n              'Max Record Size:',\n              'record exceed the maximum number of tolerated bytes',\n              `of ${max_record_size}`,\n              `at line ${this.info.lines}`,\n            ], this.options, this.__context())\n          )\n          if(err !== undefined) return err\n        }\n      }\n\n      const lappend = ltrim === false || this.state.quoting === true || this.state.field.length !== 0 || !this.__isCharTrimable(chr)\n      // rtrim in non quoting is handle in __onField\n      const rappend = rtrim === false || this.state.wasQuoting === false\n      if( lappend === true && rappend === true ){\n        this.state.field.append(chr)\n      }else if(rtrim === true && !this.__isCharTrimable(chr)){\n        const err = this.__error(\n          new CsvError('CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE', [\n            'Invalid Closing Quote:',\n            'found non trimable byte after quote',\n            `at line ${this.info.lines}`,\n          ], this.options, this.__context())\n        )\n        if(err !== undefined) return err\n      }\n    }\n    if(end === true){\n      // Ensure we are not ending in a quoting state\n      if(this.state.quoting === true){\n        const err = this.__error(\n          new CsvError('CSV_QUOTE_NOT_CLOSED', [\n            'Quote Not Closed:',\n            `the parsing is finished with an opening quote at line ${this.info.lines}`,\n          ], this.options, this.__context())\n        )\n        if(err !== undefined) return err\n      }else{\n        // Skip last line if it has no characters\n        if(this.state.wasQuoting === true || this.state.record.length !== 0 || this.state.field.length !== 0){\n          const errField = this.__onField()\n          if(errField !== undefined) return errField\n          const errRecord = this.__onRecord()\n          if(errRecord !== undefined) return errRecord\n        }else if(this.state.wasRowDelimiter === true){\n          this.info.empty_lines++\n        }else if(this.state.commenting === true){\n          this.info.comment_lines++\n        }\n      }\n    }else{\n      this.state.previousBuf = buf.slice(pos)\n    }\n    if(this.state.wasRowDelimiter === true){\n      this.info.lines++\n      this.state.wasRowDelimiter = false\n    }\n  }\n  __onRecord(){\n    const {columns, columns_duplicates_to_array, encoding, info, from, relax_column_count, relax_column_count_less, relax_column_count_more, raw, skip_lines_with_empty_values} = this.options\n    const {enabled, record} = this.state\n    if(enabled === false){\n      return this.__resetRecord()\n    }\n    // Convert the first line into column names\n    const recordLength = record.length\n    if(columns === true){\n      if(isRecordEmpty(record)){\n        this.__resetRecord()\n        return\n      }\n      return this.__firstLineToColumns(record)\n    }\n    if(columns === false && this.info.records === 0){\n      this.state.expectedRecordLength = recordLength\n    }\n    if(recordLength !== this.state.expectedRecordLength){\n      const err = columns === false ?\n        // Todo: rename CSV_INCONSISTENT_RECORD_LENGTH to\n        // CSV_RECORD_INCONSISTENT_FIELDS_LENGTH\n        new CsvError('CSV_INCONSISTENT_RECORD_LENGTH', [\n          'Invalid Record Length:',\n          `expect ${this.state.expectedRecordLength},`,\n          `got ${recordLength} on line ${this.info.lines}`,\n        ], this.options, this.__context(), {\n          record: record,\n        })\n      :\n        // Todo: rename CSV_RECORD_DONT_MATCH_COLUMNS_LENGTH to\n        // CSV_RECORD_INCONSISTENT_COLUMNS\n        new CsvError('CSV_RECORD_DONT_MATCH_COLUMNS_LENGTH', [\n          'Invalid Record Length:',\n          `columns length is ${columns.length},`, // rename columns\n          `got ${recordLength} on line ${this.info.lines}`,\n        ], this.options, this.__context(), {\n          record: record,\n        })\n      if(relax_column_count === true ||\n        (relax_column_count_less === true && recordLength < this.state.expectedRecordLength) ||\n        (relax_column_count_more === true && recordLength > this.state.expectedRecordLength) ){\n        this.info.invalid_field_length++\n        this.state.error = err\n      // Error is undefined with skip_lines_with_error\n      }else{\n        const finalErr = this.__error(err)\n        if(finalErr) return finalErr\n      }\n    }\n    if(skip_lines_with_empty_values === true){\n      if(isRecordEmpty(record)){\n        this.__resetRecord()\n        return\n      }\n    }\n    if(this.state.recordHasError === true){\n      this.__resetRecord()\n      this.state.recordHasError = false\n      return\n    }\n    this.info.records++\n    if(from === 1 || this.info.records >= from){\n      if(columns !== false){\n        const obj = {}\n        // Transform record array to an object\n        for(let i = 0, l = record.length; i < l; i++){\n          if(columns[i] === undefined || columns[i].disabled) continue\n          // Turn duplicate columns into an array\n          if (columns_duplicates_to_array === true && obj[columns[i].name] !== undefined) {\n            if (Array.isArray(obj[columns[i].name])) {\n              obj[columns[i].name] = obj[columns[i].name].concat(record[i])\n            } else {\n              obj[columns[i].name] = [obj[columns[i].name], record[i]]\n            }\n          } else {\n            obj[columns[i].name] = record[i]\n          }\n        }\n        const {objname} = this.options\n        if(objname === undefined){\n          if(raw === true || info === true){\n            const err = this.__push(Object.assign(\n              {record: obj},\n              (raw === true ? {raw: this.state.rawBuffer.toString(encoding)}: {}),\n              (info === true ? {info: this.state.info}: {})\n            ))\n            if(err){\n              return err\n            }\n          }else{\n            const err = this.__push(obj)\n            if(err){\n              return err\n            }\n          }\n        }else{\n          if(raw === true || info === true){\n            const err = this.__push(Object.assign(\n              {record: [obj[objname], obj]},\n              raw === true ? {raw: this.state.rawBuffer.toString(encoding)}: {},\n              info === true ? {info: this.state.info}: {}\n            ))\n            if(err){\n              return err\n            }\n          }else{\n            const err = this.__push([obj[objname], obj])\n            if(err){\n              return err\n            }\n          }\n        }\n      }else{\n        if(raw === true || info === true){\n          const err = this.__push(Object.assign(\n            {record: record},\n            raw === true ? {raw: this.state.rawBuffer.toString(encoding)}: {},\n            info === true ? {info: this.state.info}: {}\n          ))\n          if(err){\n            return err\n          }\n        }else{\n          const err = this.__push(record)\n          if(err){\n            return err\n          }\n        }\n      }\n    }\n    this.__resetRecord()\n  }\n  __firstLineToColumns(record){\n    const {firstLineToHeaders} = this.state\n    try{\n      const headers = firstLineToHeaders === undefined ? record : firstLineToHeaders.call(null, record)\n      if(!Array.isArray(headers)){\n        return this.__error(\n          new CsvError('CSV_INVALID_COLUMN_MAPPING', [\n            'Invalid Column Mapping:',\n            'expect an array from column function,',\n            `got ${JSON.stringify(headers)}`\n          ], this.options, this.__context(), {\n            headers: headers,\n          })\n        )\n      }\n      const normalizedHeaders = normalizeColumnsArray(headers)\n      this.state.expectedRecordLength = normalizedHeaders.length\n      this.options.columns = normalizedHeaders\n      this.__resetRecord()\n      return\n    }catch(err){\n      return err\n    }\n  }\n  __resetRecord(){\n    if(this.options.raw === true){\n      this.state.rawBuffer.reset()\n    }\n    this.state.error = undefined\n    this.state.record = []\n    this.state.record_length = 0\n  }\n  __onField(){\n    const {cast, encoding, rtrim, max_record_size} = this.options\n    const {enabled, wasQuoting} = this.state\n    // Short circuit for the from_line options\n    if(enabled === false){ /* this.options.columns !== true && */\n      return this.__resetField()\n    }\n    let field = this.state.field.toString(encoding)\n    if(rtrim === true && wasQuoting === false){\n      field = field.trimRight()\n    }\n    if(cast === true){\n      const [err, f] = this.__cast(field)\n      if(err !== undefined) return err\n      field = f\n    }\n    this.state.record.push(field)\n    // Increment record length if record size must not exceed a limit\n    if(max_record_size !== 0 && typeof field === 'string'){\n      this.state.record_length += field.length\n    }\n    this.__resetField()\n  }\n  __resetField(){\n    this.state.field.reset()\n    this.state.wasQuoting = false\n  }\n  __push(record){\n    const {on_record} = this.options\n    if(on_record !== undefined){\n      const context = this.__context()\n      try{\n        record = on_record.call(null, record, context)\n      }catch(err){\n        return err\n      }\n      if(record === undefined || record === null){ return }\n    }\n    this.push(record)\n  }\n  // Return a tuple with the error and the casted value\n  __cast(field){\n    const {columns, relax_column_count} = this.options\n    const isColumns = Array.isArray(columns)\n    // Dont loose time calling cast\n    // because the final record is an object\n    // and this field can't be associated to a key present in columns\n    if( isColumns === true && relax_column_count && this.options.columns.length <= this.state.record.length ){\n      return [undefined, undefined]\n    }\n    const context = this.__context()\n    if(this.state.castField !== null){\n      try{\n        return [undefined, this.state.castField.call(null, field, context)]\n      }catch(err){\n        return [err]\n      }\n    }\n    if(this.__isFloat(field)){\n      return [undefined, parseFloat(field)]\n    }else if(this.options.cast_date !== false){\n      return [undefined, this.options.cast_date.call(null, field, context)]\n    }\n    return [undefined, field]\n  }\n  // Helper to test if a character is a space or a line delimiter\n  __isCharTrimable(chr){\n    return chr === space || chr === tab || chr === cr || chr === nl || chr === np\n  }\n  // Keep it in case we implement the `cast_int` option\n  // __isInt(value){\n  //   // return Number.isInteger(parseInt(value))\n  //   // return !isNaN( parseInt( obj ) );\n  //   return /^(\\-|\\+)?[1-9][0-9]*$/.test(value)\n  // }\n  __isFloat(value){\n    return (value - parseFloat( value ) + 1) >= 0 // Borrowed from jquery\n  }\n  __compareBytes(sourceBuf, targetBuf, targetPos, firstByte){\n    if(sourceBuf[0] !== firstByte) return 0\n    const sourceLength = sourceBuf.length\n    for(let i = 1; i < sourceLength; i++){\n      if(sourceBuf[i] !== targetBuf[targetPos+i]) return 0\n    }\n    return sourceLength\n  }\n  __needMoreData(i, bufLen, end){\n    if(end) return false\n    const {quote} = this.options\n    const {quoting, needMoreDataSize, recordDelimiterMaxLength} = this.state\n    const numOfCharLeft = bufLen - i - 1\n    const requiredLength = Math.max(\n      needMoreDataSize,\n      // Skip if the remaining buffer smaller than record delimiter\n      recordDelimiterMaxLength,\n      // Skip if the remaining buffer can be record delimiter following the closing quote\n      // 1 is for quote.length\n      quoting ? (quote.length + recordDelimiterMaxLength) : 0,\n    )\n    return numOfCharLeft < requiredLength\n  }\n  __isDelimiter(buf, pos, chr){\n    const {delimiter, ignore_last_delimiters} = this.options\n    if(ignore_last_delimiters === true && this.state.record.length === this.options.columns.length - 1){\n      return 0\n    }else if(ignore_last_delimiters !== false && typeof ignore_last_delimiters === 'number' && this.state.record.length === ignore_last_delimiters - 1){\n      return 0\n    }\n    loop1: for(let i = 0; i < delimiter.length; i++){\n      const del = delimiter[i]\n      if(del[0] === chr){\n        for(let j = 1; j < del.length; j++){\n          if(del[j] !== buf[pos+j]) continue loop1\n        }\n        return del.length\n      }\n    }\n    return 0\n  }\n  __isRecordDelimiter(chr, buf, pos){\n    const {record_delimiter} = this.options\n    const recordDelimiterLength = record_delimiter.length\n    loop1: for(let i = 0; i < recordDelimiterLength; i++){\n      const rd = record_delimiter[i]\n      const rdLength = rd.length\n      if(rd[0] !== chr){\n        continue\n      }\n      for(let j = 1; j < rdLength; j++){\n        if(rd[j] !== buf[pos+j]){\n          continue loop1\n        }\n      }\n      return rd.length\n    }\n    return 0\n  }\n  __isEscape(buf, pos, chr){\n    const {escape} = this.options\n    if(escape === null) return false\n    const l = escape.length\n    if(escape[0] === chr){\n      for(let i = 0; i < l; i++){\n        if(escape[i] !== buf[pos+i]){\n          return false\n        }\n      }\n      return true\n    }\n    return false\n  }\n  __isQuote(buf, pos){\n    const {quote} = this.options\n    if(quote === null) return false\n    const l = quote.length\n    for(let i = 0; i < l; i++){\n      if(quote[i] !== buf[pos+i]){\n        return false\n      }\n    }\n    return true\n  }\n  __autoDiscoverRecordDelimiter(buf, pos){\n    const {encoding} = this.options\n    const chr = buf[pos]\n    if(chr === cr){\n      if(buf[pos+1] === nl){\n        this.options.record_delimiter.push(Buffer.from('\\r\\n', encoding))\n        this.state.recordDelimiterMaxLength = 2\n        return 2\n      }else{\n        this.options.record_delimiter.push(Buffer.from('\\r', encoding))\n        this.state.recordDelimiterMaxLength = 1\n        return 1\n      }\n    }else if(chr === nl){\n      this.options.record_delimiter.push(Buffer.from('\\n', encoding))\n      this.state.recordDelimiterMaxLength = 1\n      return 1\n    }\n    return 0\n  }\n  __error(msg){\n    const {skip_lines_with_error} = this.options\n    const err = typeof msg === 'string' ? new Error(msg) : msg\n    if(skip_lines_with_error){\n      this.state.recordHasError = true\n      this.emit('skip', err)\n      return undefined\n    }else{\n      return err\n    }\n  }\n  __context(){\n    const {columns} = this.options\n    const isColumns = Array.isArray(columns)\n    return {\n      column: isColumns === true ?\n        ( columns.length > this.state.record.length ?\n          columns[this.state.record.length].name :\n          null\n        ) :\n        this.state.record.length,\n      empty_lines: this.info.empty_lines,\n      error: this.state.error,\n      header: columns === true,\n      index: this.state.record.length,\n      invalid_field_length: this.info.invalid_field_length,\n      quoting: this.state.wasQuoting,\n      lines: this.info.lines,\n      records: this.info.records\n    }\n  }\n}\n\nconst parse = function(){\n  let data, options, callback\n  for(let i in arguments){\n    const argument = arguments[i]\n    const type = typeof argument\n    if(data === undefined && (typeof argument === 'string' || Buffer.isBuffer(argument))){\n      data = argument\n    }else if(options === undefined && isObject(argument)){\n      options = argument\n    }else if(callback === undefined && type === 'function'){\n      callback = argument\n    }else{\n      throw new CsvError('CSV_INVALID_ARGUMENT', [\n        'Invalid argument:',\n        `got ${JSON.stringify(argument)} at index ${i}`\n      ], this.options)\n    }\n  }\n  const parser = new Parser(options)\n  if(callback){\n    const records = options === undefined || options.objname === undefined ? [] : {}\n    parser.on('readable', function(){\n      let record\n      while((record = this.read()) !== null){\n        if(options === undefined || options.objname === undefined){\n          records.push(record)\n        }else{\n          records[record[0]] = record[1]\n        }\n      }\n    })\n    parser.on('error', function(err){\n      callback(err, undefined, parser.info)\n    })\n    parser.on('end', function(){\n      callback(undefined, records, parser.info)\n    })\n  }\n  if(data !== undefined){\n    // Give a chance for events to be registered later\n    if(typeof setImmediate === 'function'){\n      setImmediate(function(){\n        parser.write(data)\n        parser.end()\n      })\n    }else{\n      parser.write(data)\n      parser.end()\n    }\n  }\n  return parser\n}\n\nclass CsvError extends Error {\n  constructor(code, message, options, ...contexts) {\n    if(Array.isArray(message)) message = message.join(' ')\n    super(message)\n    if(Error.captureStackTrace !== undefined){\n      Error.captureStackTrace(this, CsvError)\n    }\n    this.code = code\n    for(const context of contexts){\n      for(const key in context){\n        const value = context[key]\n        this[key] = Buffer.isBuffer(value) ? value.toString(options.encoding) : value == null ? value : JSON.parse(JSON.stringify(value))\n      }\n    }\n  }\n}\n\nparse.Parser = Parser\n\nparse.CsvError = CsvError\n\nmodule.exports = parse\n\nconst underscore = function(str){\n  return str.replace(/([A-Z])/g, function(_, match){\n    return '_' + match.toLowerCase()\n  })\n}\n\nconst isObject = function(obj){\n  return (typeof obj === 'object' && obj !== null && !Array.isArray(obj))\n}\n\nconst isRecordEmpty = function(record){\n  return record.every( (field) => field == null || field.toString && field.toString().trim() === '' )\n}\n\nconst normalizeColumnsArray = function(columns){\n  const normalizedColumns = [];\n  for(let i = 0, l = columns.length; i < l; i++){\n    const column = columns[i]\n    if(column === undefined || column === null || column === false){\n      normalizedColumns[i] = { disabled: true }\n    }else if(typeof column === 'string'){\n      normalizedColumns[i] = { name: column }\n    }else if(isObject(column)){\n      if(typeof column.name !== 'string'){\n        throw new CsvError('CSV_OPTION_COLUMNS_MISSING_NAME', [\n          'Option columns missing name:',\n          `property \"name\" is required at position ${i}`,\n          'when column is an object literal'\n        ])\n      }\n      normalizedColumns[i] = column\n    }else{\n      throw new CsvError('CSV_INVALID_COLUMN_DEFINITION', [\n        'Invalid column definition:',\n        'expect a string or a literal object,',\n        `got ${JSON.stringify(column)} at position ${i}`\n      ])\n    }\n  }\n  return normalizedColumns;\n}\n"]},"metadata":{},"sourceType":"script"}