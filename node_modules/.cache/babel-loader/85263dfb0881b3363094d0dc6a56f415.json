{"ast":null,"code":"import _regeneratorRuntime from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _classCallCheck from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { ExposedPromise } from '../../utils/exposed-promise';\nimport { generateGUID } from '../../utils/generate-uuid';\nimport { getKeypairFromSeed, toHex } from '../../utils/crypto';\nimport { StorageKey } from '../..';\nimport { BeaconEventHandler } from '../../events';\nimport { SDK_VERSION } from '../../constants';\nimport { windowRef } from '../../MockWindow';\n/**\n * @internalapi\n *\n * The beacon client is an abstract client that handles everything that is shared between all other clients.\n * Specifically, it handles managing the beaconId and and the local keypair.\n */\n\nexport var BeaconClient = /*#__PURE__*/function () {\n  function BeaconClient(config) {\n    _classCallCheck(this, BeaconClient);\n\n    /** The beaconId is a public key that is used to identify one specific application (dapp or wallet).\n     * This is used inside a message to specify the sender, for example.\n     */\n    this._beaconId = new ExposedPromise();\n    this.events = new BeaconEventHandler();\n    /**\n     * The local keypair that is used for the communication encryption\n     */\n\n    this._keyPair = new ExposedPromise();\n\n    if (!config.name) {\n      throw new Error('Name not set');\n    }\n\n    if (!config.storage) {\n      throw new Error('Storage not set');\n    }\n\n    this.name = config.name;\n    this.iconUrl = config.iconUrl;\n    this.appUrl = config.appUrl;\n    this.storage = config.storage; // TODO: This is a temporary \"fix\" to prevent users from creating multiple Client instances\n\n    if (windowRef.beaconCreatedClientInstance) {\n      console.warn('[BEACON] It looks like you created multiple Beacon SDK Client instances. This can lead to problems. Only create one instance and re-use it everywhere.');\n    } else {\n      ;\n      windowRef.beaconCreatedClientInstance = true;\n    }\n\n    this.initSDK().catch(console.error);\n  }\n\n  _createClass(BeaconClient, [{\n    key: \"beaconId\",\n    get: function get() {\n      return this._beaconId.promise;\n    }\n  }, {\n    key: \"keyPair\",\n    get: function get() {\n      return this._keyPair.promise;\n    }\n    /**\n     * This resets the SDK. After using this method, this instance is no longer usable. You will have to instanciate a new client.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.removeBeaconEntriesFromStorage();\n\n              case 2:\n                windowRef.beaconCreatedClientInstance = false;\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * This method initializes the SDK by setting some values in the storage and generating a keypair.\n     */\n\n  }, {\n    key: \"initSDK\",\n    value: function initSDK() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _this = this;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                this.storage.set(StorageKey.BEACON_SDK_VERSION, SDK_VERSION).catch(console.error);\n                this.loadOrCreateBeaconSecret().catch(console.error);\n                return _context2.abrupt(\"return\", this.keyPair.then(function (keyPair) {\n                  _this._beaconId.resolve(toHex(keyPair.publicKey));\n                }));\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n    /**\n     * Removes all beacon values from the storage.\n     */\n\n  }, {\n    key: \"removeBeaconEntriesFromStorage\",\n    value: function removeBeaconEntriesFromStorage() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var _this2 = this;\n\n        var allKeys;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                allKeys = Object.values(StorageKey);\n                _context3.next = 3;\n                return Promise.all(allKeys.map(function (key) {\n                  return _this2.storage.delete(key);\n                }));\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n    }\n    /**\n     * This method tries to load the seed from storage, if it doesn't exist, a new one will be created and persisted.\n     */\n\n  }, {\n    key: \"loadOrCreateBeaconSecret\",\n    value: function loadOrCreateBeaconSecret() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var storageValue, key;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.storage.get(StorageKey.BEACON_SDK_SECRET_SEED);\n\n              case 2:\n                storageValue = _context4.sent;\n\n                if (!(storageValue && typeof storageValue === 'string')) {\n                  _context4.next = 11;\n                  break;\n                }\n\n                _context4.t0 = this._keyPair;\n                _context4.next = 7;\n                return getKeypairFromSeed(storageValue);\n\n              case 7:\n                _context4.t1 = _context4.sent;\n\n                _context4.t0.resolve.call(_context4.t0, _context4.t1);\n\n                _context4.next = 21;\n                break;\n\n              case 11:\n                _context4.next = 13;\n                return generateGUID();\n\n              case 13:\n                key = _context4.sent;\n                _context4.next = 16;\n                return this.storage.set(StorageKey.BEACON_SDK_SECRET_SEED, key);\n\n              case 16:\n                _context4.t2 = this._keyPair;\n                _context4.next = 19;\n                return getKeypairFromSeed(key);\n\n              case 19:\n                _context4.t3 = _context4.sent;\n\n                _context4.t2.resolve.call(_context4.t2, _context4.t3);\n\n              case 21:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n  }]);\n\n  return BeaconClient;\n}();","map":{"version":3,"sources":["../../../../src/clients/beacon-client/BeaconClient.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ExposedPromise } from '../../utils/exposed-promise';\nimport { generateGUID } from '../../utils/generate-uuid';\nimport { getKeypairFromSeed, toHex } from '../../utils/crypto';\nimport { StorageKey } from '../..';\nimport { BeaconEventHandler } from '../../events';\nimport { SDK_VERSION } from '../../constants';\nimport { windowRef } from '../../MockWindow';\n/**\n * @internalapi\n *\n * The beacon client is an abstract client that handles everything that is shared between all other clients.\n * Specifically, it handles managing the beaconId and and the local keypair.\n */\nexport class BeaconClient {\n    constructor(config) {\n        /** The beaconId is a public key that is used to identify one specific application (dapp or wallet).\n         * This is used inside a message to specify the sender, for example.\n         */\n        this._beaconId = new ExposedPromise();\n        this.events = new BeaconEventHandler();\n        /**\n         * The local keypair that is used for the communication encryption\n         */\n        this._keyPair = new ExposedPromise();\n        if (!config.name) {\n            throw new Error('Name not set');\n        }\n        if (!config.storage) {\n            throw new Error('Storage not set');\n        }\n        this.name = config.name;\n        this.iconUrl = config.iconUrl;\n        this.appUrl = config.appUrl;\n        this.storage = config.storage;\n        // TODO: This is a temporary \"fix\" to prevent users from creating multiple Client instances\n        if (windowRef.beaconCreatedClientInstance) {\n            console.warn('[BEACON] It looks like you created multiple Beacon SDK Client instances. This can lead to problems. Only create one instance and re-use it everywhere.');\n        }\n        else {\n            ;\n            windowRef.beaconCreatedClientInstance = true;\n        }\n        this.initSDK().catch(console.error);\n    }\n    get beaconId() {\n        return this._beaconId.promise;\n    }\n    get keyPair() {\n        return this._keyPair.promise;\n    }\n    /**\n     * This resets the SDK. After using this method, this instance is no longer usable. You will have to instanciate a new client.\n     */\n    destroy() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.removeBeaconEntriesFromStorage();\n            windowRef.beaconCreatedClientInstance = false;\n        });\n    }\n    /**\n     * This method initializes the SDK by setting some values in the storage and generating a keypair.\n     */\n    initSDK() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.storage.set(StorageKey.BEACON_SDK_VERSION, SDK_VERSION).catch(console.error);\n            this.loadOrCreateBeaconSecret().catch(console.error);\n            return this.keyPair.then((keyPair) => {\n                this._beaconId.resolve(toHex(keyPair.publicKey));\n            });\n        });\n    }\n    /**\n     * Removes all beacon values from the storage.\n     */\n    removeBeaconEntriesFromStorage() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const allKeys = Object.values(StorageKey);\n            yield Promise.all(allKeys.map((key) => this.storage.delete(key)));\n        });\n    }\n    /**\n     * This method tries to load the seed from storage, if it doesn't exist, a new one will be created and persisted.\n     */\n    loadOrCreateBeaconSecret() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const storageValue = yield this.storage.get(StorageKey.BEACON_SDK_SECRET_SEED);\n            if (storageValue && typeof storageValue === 'string') {\n                this._keyPair.resolve(yield getKeypairFromSeed(storageValue));\n            }\n            else {\n                const key = yield generateGUID();\n                yield this.storage.set(StorageKey.BEACON_SDK_SECRET_SEED, key);\n                this._keyPair.resolve(yield getKeypairFromSeed(key));\n            }\n        });\n    }\n}\n//# sourceMappingURL=BeaconClient.js.map"]},"metadata":{},"sourceType":"module"}