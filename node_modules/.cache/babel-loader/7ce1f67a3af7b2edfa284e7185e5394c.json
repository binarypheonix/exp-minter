{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getApplicativeComposition = exports.getApplicativeMonoid = void 0;\n/**\n * The `Applicative` type class extends the `Apply` type class with a `of` function, which can be used to create values\n * of type `f a` from values of type `a`.\n *\n * Where `Apply` provides the ability to lift functions of two or more arguments to functions whose arguments are\n * wrapped using `f`, and `Functor` provides the ability to lift functions of one argument, `pure` can be seen as the\n * function which lifts functions of _zero_ arguments. That is, `Applicative` functors support a lifting operation for\n * any number of function arguments.\n *\n * Instances must satisfy the following laws in addition to the `Apply` laws:\n *\n * 1. Identity: `A.ap(A.of(a => a), fa) <-> fa`\n * 2. Homomorphism: `A.ap(A.of(ab), A.of(a)) <-> A.of(ab(a))`\n * 3. Interchange: `A.ap(fab, A.of(a)) <-> A.ap(A.of(ab => ab(a)), fab)`\n *\n * Note. `Functor`'s `map` can be derived: `A.map(x, f) = A.ap(A.of(f), x)`\n *\n * @since 2.0.0\n */\n\nvar Apply_1 = require(\"./Apply\");\n\nvar function_1 = require(\"./function\");\n\nvar Functor_1 = require(\"./Functor\");\n\nfunction getApplicativeMonoid(F) {\n  var f = Apply_1.getApplySemigroup(F);\n  return function (M) {\n    return {\n      concat: f(M).concat,\n      empty: F.of(M.empty)\n    };\n  };\n}\n\nexports.getApplicativeMonoid = getApplicativeMonoid;\n/** @deprecated */\n\nfunction getApplicativeComposition(F, G) {\n  var map = Functor_1.getFunctorComposition(F, G).map;\n\n  var _ap = Apply_1.ap(F, G);\n\n  return {\n    map: map,\n    of: function (a) {\n      return F.of(G.of(a));\n    },\n    ap: function (fgab, fga) {\n      return function_1.pipe(fgab, _ap(fga));\n    }\n  };\n}\n\nexports.getApplicativeComposition = getApplicativeComposition;","map":{"version":3,"sources":["/Users/frankenstein/projects/minter/node_modules/fp-ts/lib/Applicative.js"],"names":["Object","defineProperty","exports","value","getApplicativeComposition","getApplicativeMonoid","Apply_1","require","function_1","Functor_1","F","f","getApplySemigroup","M","concat","empty","of","G","map","getFunctorComposition","_ap","ap","a","fgab","fga","pipe"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,yBAAR,GAAoCF,OAAO,CAACG,oBAAR,GAA+B,KAAK,CAAxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIC,OAAO,GAAGC,OAAO,CAAC,SAAD,CAArB;;AACA,IAAIC,UAAU,GAAGD,OAAO,CAAC,YAAD,CAAxB;;AACA,IAAIE,SAAS,GAAGF,OAAO,CAAC,WAAD,CAAvB;;AACA,SAASF,oBAAT,CAA8BK,CAA9B,EAAiC;AAC7B,MAAIC,CAAC,GAAGL,OAAO,CAACM,iBAAR,CAA0BF,CAA1B,CAAR;AACA,SAAO,UAAUG,CAAV,EAAa;AAAE,WAAQ;AAC1BC,MAAAA,MAAM,EAAEH,CAAC,CAACE,CAAD,CAAD,CAAKC,MADa;AAE1BC,MAAAA,KAAK,EAAEL,CAAC,CAACM,EAAF,CAAKH,CAAC,CAACE,KAAP;AAFmB,KAAR;AAGjB,GAHL;AAIH;;AACDb,OAAO,CAACG,oBAAR,GAA+BA,oBAA/B;AACA;;AACA,SAASD,yBAAT,CAAmCM,CAAnC,EAAsCO,CAAtC,EAAyC;AACrC,MAAIC,GAAG,GAAGT,SAAS,CAACU,qBAAV,CAAgCT,CAAhC,EAAmCO,CAAnC,EAAsCC,GAAhD;;AACA,MAAIE,GAAG,GAAGd,OAAO,CAACe,EAAR,CAAWX,CAAX,EAAcO,CAAd,CAAV;;AACA,SAAO;AACHC,IAAAA,GAAG,EAAEA,GADF;AAEHF,IAAAA,EAAE,EAAE,UAAUM,CAAV,EAAa;AAAE,aAAOZ,CAAC,CAACM,EAAF,CAAKC,CAAC,CAACD,EAAF,CAAKM,CAAL,CAAL,CAAP;AAAuB,KAFvC;AAGHD,IAAAA,EAAE,EAAE,UAAUE,IAAV,EAAgBC,GAAhB,EAAqB;AAAE,aAAOhB,UAAU,CAACiB,IAAX,CAAgBF,IAAhB,EAAsBH,GAAG,CAACI,GAAD,CAAzB,CAAP;AAAyC;AAHjE,GAAP;AAKH;;AACDtB,OAAO,CAACE,yBAAR,GAAoCA,yBAApC","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getApplicativeComposition = exports.getApplicativeMonoid = void 0;\n/**\n * The `Applicative` type class extends the `Apply` type class with a `of` function, which can be used to create values\n * of type `f a` from values of type `a`.\n *\n * Where `Apply` provides the ability to lift functions of two or more arguments to functions whose arguments are\n * wrapped using `f`, and `Functor` provides the ability to lift functions of one argument, `pure` can be seen as the\n * function which lifts functions of _zero_ arguments. That is, `Applicative` functors support a lifting operation for\n * any number of function arguments.\n *\n * Instances must satisfy the following laws in addition to the `Apply` laws:\n *\n * 1. Identity: `A.ap(A.of(a => a), fa) <-> fa`\n * 2. Homomorphism: `A.ap(A.of(ab), A.of(a)) <-> A.of(ab(a))`\n * 3. Interchange: `A.ap(fab, A.of(a)) <-> A.ap(A.of(ab => ab(a)), fab)`\n *\n * Note. `Functor`'s `map` can be derived: `A.map(x, f) = A.ap(A.of(f), x)`\n *\n * @since 2.0.0\n */\nvar Apply_1 = require(\"./Apply\");\nvar function_1 = require(\"./function\");\nvar Functor_1 = require(\"./Functor\");\nfunction getApplicativeMonoid(F) {\n    var f = Apply_1.getApplySemigroup(F);\n    return function (M) { return ({\n        concat: f(M).concat,\n        empty: F.of(M.empty)\n    }); };\n}\nexports.getApplicativeMonoid = getApplicativeMonoid;\n/** @deprecated */\nfunction getApplicativeComposition(F, G) {\n    var map = Functor_1.getFunctorComposition(F, G).map;\n    var _ap = Apply_1.ap(F, G);\n    return {\n        map: map,\n        of: function (a) { return F.of(G.of(a)); },\n        ap: function (fgab, fga) { return function_1.pipe(fgab, _ap(fga)); }\n    };\n}\nexports.getApplicativeComposition = getApplicativeComposition;\n"]},"metadata":{},"sourceType":"script"}