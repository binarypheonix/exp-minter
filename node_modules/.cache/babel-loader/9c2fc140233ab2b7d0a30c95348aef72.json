{"ast":null,"code":"import _regeneratorRuntime from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _classCallCheck from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/frankenstein/projects/minter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { Logger } from '../utils/Logger';\nimport { TransportStatus, Transport, TransportType, P2PCommunicationClient, Origin } from '..';\nimport { PeerManager } from '../managers/PeerManager';\nvar logger = new Logger('P2PTransport');\n/**\n * @internalapi\n *\n *\n */\n\nexport var P2PTransport = /*#__PURE__*/function (_Transport) {\n  _inherits(P2PTransport, _Transport);\n\n  var _super2 = _createSuper(P2PTransport);\n\n  function P2PTransport(name, keyPair, storage, matrixNodes, storageKey, iconUrl, appUrl) {\n    var _this;\n\n    _classCallCheck(this, P2PTransport);\n\n    _this = _super2.call(this, name, new P2PCommunicationClient(name, keyPair, 1, storage, matrixNodes, iconUrl, appUrl), new PeerManager(storage, storageKey));\n    _this.type = TransportType.P2P;\n    return _this;\n  }\n\n  _createClass(P2PTransport, [{\n    key: \"connect\",\n    value: function connect() {\n      var _this2 = this;\n\n      var _super = Object.create(null, {\n        connect: {\n          get: function get() {\n            return _get(_getPrototypeOf(P2PTransport.prototype), \"connect\", _this2);\n          }\n        }\n      });\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _this3 = this;\n\n        var knownPeers, connectionPromises;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(this._isConnected !== TransportStatus.NOT_CONNECTED)) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 2:\n                logger.log('connect');\n                this._isConnected = TransportStatus.CONNECTING;\n                _context2.next = 6;\n                return this.client.start();\n\n              case 6:\n                _context2.next = 8;\n                return this.getPeers();\n\n              case 8:\n                knownPeers = _context2.sent;\n\n                if (knownPeers.length > 0) {\n                  logger.log('connect', \"connecting to \".concat(knownPeers.length, \" peers\"));\n                  connectionPromises = knownPeers.map(function (peer) {\n                    return __awaiter(_this3, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                      return _regeneratorRuntime.wrap(function _callee$(_context) {\n                        while (1) {\n                          switch (_context.prev = _context.next) {\n                            case 0:\n                              return _context.abrupt(\"return\", this.listen(peer.publicKey));\n\n                            case 1:\n                            case \"end\":\n                              return _context.stop();\n                          }\n                        }\n                      }, _callee, this);\n                    }));\n                  });\n                  Promise.all(connectionPromises).catch(function (error) {\n                    return logger.error('connect', error);\n                  });\n                }\n\n                _context2.next = 12;\n                return this.startOpenChannelListener();\n\n              case 12:\n                return _context2.abrupt(\"return\", _super.connect.call(this));\n\n              case 13:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      var _this4 = this;\n\n      var _super = Object.create(null, {\n        disconnect: {\n          get: function get() {\n            return _get(_getPrototypeOf(P2PTransport.prototype), \"disconnect\", _this4);\n          }\n        }\n      });\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.client.stop();\n\n              case 2:\n                return _context3.abrupt(\"return\", _super.disconnect.call(this));\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n  }, {\n    key: \"startOpenChannelListener\",\n    value: function startOpenChannelListener() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n    }\n  }, {\n    key: \"getPairingRequestInfo\",\n    value: function getPairingRequestInfo() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt(\"return\", this.client.getPairingRequestInfo());\n\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n    }\n  }, {\n    key: \"listen\",\n    value: function listen(publicKey) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        var _this5 = this;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this.client.listenForEncryptedMessage(publicKey, function (message) {\n                  var connectionContext = {\n                    origin: Origin.P2P,\n                    id: publicKey\n                  };\n\n                  _this5.notifyListeners(message, connectionContext).catch(function (error) {\n                    throw error;\n                  });\n                }).catch(function (error) {\n                  throw error;\n                });\n\n              case 2:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n    }\n  }], [{\n    key: \"isAvailable\",\n    value: function isAvailable() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                return _context7.abrupt(\"return\", Promise.resolve(true));\n\n              case 1:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7);\n      }));\n    }\n  }]);\n\n  return P2PTransport;\n}(Transport);","map":{"version":3,"sources":["../../../src/transports/P2PTransport.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Logger } from '../utils/Logger';\nimport { TransportStatus, Transport, TransportType, P2PCommunicationClient, Origin } from '..';\nimport { PeerManager } from '../managers/PeerManager';\nconst logger = new Logger('P2PTransport');\n/**\n * @internalapi\n *\n *\n */\nexport class P2PTransport extends Transport {\n    constructor(name, keyPair, storage, matrixNodes, storageKey, iconUrl, appUrl) {\n        super(name, new P2PCommunicationClient(name, keyPair, 1, storage, matrixNodes, iconUrl, appUrl), new PeerManager(storage, storageKey));\n        this.type = TransportType.P2P;\n    }\n    static isAvailable() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return Promise.resolve(true);\n        });\n    }\n    connect() {\n        const _super = Object.create(null, {\n            connect: { get: () => super.connect }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._isConnected !== TransportStatus.NOT_CONNECTED) {\n                return;\n            }\n            logger.log('connect');\n            this._isConnected = TransportStatus.CONNECTING;\n            yield this.client.start();\n            const knownPeers = yield this.getPeers();\n            if (knownPeers.length > 0) {\n                logger.log('connect', `connecting to ${knownPeers.length} peers`);\n                const connectionPromises = knownPeers.map((peer) => __awaiter(this, void 0, void 0, function* () { return this.listen(peer.publicKey); }));\n                Promise.all(connectionPromises).catch((error) => logger.error('connect', error));\n            }\n            yield this.startOpenChannelListener();\n            return _super.connect.call(this);\n        });\n    }\n    disconnect() {\n        const _super = Object.create(null, {\n            disconnect: { get: () => super.disconnect }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.client.stop();\n            return _super.disconnect.call(this);\n        });\n    }\n    startOpenChannelListener() {\n        return __awaiter(this, void 0, void 0, function* () {\n            //\n        });\n    }\n    getPairingRequestInfo() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.client.getPairingRequestInfo();\n        });\n    }\n    listen(publicKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.client\n                .listenForEncryptedMessage(publicKey, (message) => {\n                const connectionContext = {\n                    origin: Origin.P2P,\n                    id: publicKey\n                };\n                this.notifyListeners(message, connectionContext).catch((error) => {\n                    throw error;\n                });\n            })\n                .catch((error) => {\n                throw error;\n            });\n        });\n    }\n}\n//# sourceMappingURL=P2PTransport.js.map"]},"metadata":{},"sourceType":"module"}