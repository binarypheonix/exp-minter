import { BigNumber } from 'bignumber.js';
import { MichelsonMap } from '@taquito/taquito';
export declare type unit = (true | undefined) & {
    __type: 'unit';
};
export declare type address = string & {
    __type: 'address';
};
export declare type bytes = string & {
    __type: 'bytes';
};
export declare type contract = string & {
    __type: 'contract';
};
export declare type operation = string & {
    __type: 'operation';
};
export declare type key = string & {
    __type: 'key';
};
export declare type key_hash = string & {
    __type: 'key_hash';
};
export declare type signature = string & {
    __type: 'signature';
};
export declare type ticket = string & {
    __type: 'ticket';
};
export declare type timestamp = string & {
    __type: 'timestamp';
};
export declare type int = BigNumber & {
    __type: 'int';
};
export declare type nat = BigNumber & {
    __type: 'nat';
};
export declare type mutez = BigNumber & {
    __type: 'mutez';
};
export declare type tez = BigNumber & {
    __type: 'tez';
};
export declare type MMap<K, V> = Omit<MichelsonMap<K, V>, 'get'> & {
    get: (key: K) => V;
};
export declare type BigMap<K, V> = Omit<MichelsonMap<K, V>, 'get'> & {
    get: (key: K) => Promise<V>;
};
declare type asMapParamOf<K, V> = K extends string ? {
    [key: string]: V;
} | Array<{
    key: K;
    value: V;
}> : K extends number ? {
    [key: number]: V;
} | Array<{
    key: K;
    value: V;
}> : Array<{
    key: K;
    value: V;
}>;
declare function asMap<K, V>(value: asMapParamOf<K, V>): MMap<K, V>;
declare function add<T extends BigNumber>(a: T, b: T): T;
declare function subtract<T extends BigNumber>(a: T, b: T): T;
/** tas: Tezos 'as' casting for strict types */
export declare const tas: {
    address: (value: string) => address;
    bytes: (value: string) => bytes;
    contract: (value: string) => contract;
    timestamp: (value: string | Date) => timestamp;
    int: (value: number | BigNumber | string) => int;
    nat: (value: number | BigNumber | string) => nat;
    mutez: (value: number | BigNumber | string) => mutez;
    tez: (value: number | BigNumber | string) => tez;
    map: typeof asMap;
    bigMap: <K, V>(value: asMapParamOf<K, V>) => BigMap<K, V>;
    add: typeof add;
    subtract: typeof subtract;
    number: (value: string | BigNumber) => number;
};
export {};
